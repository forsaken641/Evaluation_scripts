{
   "repo": "repo:^awtk-1.7.0$@4de4a37",
   "patch_hash": "401ee841c3e938d76d65f42c5d112444cce95397",
   "vul_hash": "e01afa1c6d53eeae93210830968c1f0c111c1b36",
   "result": {
      "src/awtk_global.c": [
         {
            "type": "func",
            "name": "tk_init_assets",
            "line_range": [
               114,
               134
            ],
            "source_code": "ret_t tk_init_assets(void) {\n  uint32_t i = 0;\n  uint32_t nr = assets_manager()->assets.size;\n  const asset_info_t** all = (const asset_info_t**)(assets_manager()->assets.elms);\n\n  for (i = 0; i < nr; i++) {\n    const asset_info_t* iter = all[i];\n    switch (iter->type) {\n      case ASSET_TYPE_FONT:\n        tk_add_font(iter);\n        break;\n      case ASSET_TYPE_STYLE:\n        if (theme()->data == NULL && strcmp(iter->name, \"default\") == 0) {\n          theme_set_theme_data(theme(), iter->data);\n        }\n        break;\n    }\n  }\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  121,
                  "all[i]"
               ]
            ]
         },
         {
            "type": "func",
            "name": "tk_quit",
            "line_range": [
               400,
               403
            ],
            "source_code": "ret_t tk_quit() {\n  timer_add(tk_quit_idle, NULL, 0);\n  return RET_OK;\n}",
            "key_variables": [
               [
                  414,
                  "info->lcd_orientation"
               ]
            ]
         },
         {
            "type": "func",
            "name": "idle_callback_info_create",
            "line_range": [
               447,
               455
            ],
            "source_code": "static idle_callback_info_t* idle_callback_info_create(tk_callback_t func, void* ctx) {\n  idle_callback_info_t* info = TKMEM_ZALLOC(idle_callback_info_t);\n  return_value_if_fail(info != NULL, NULL);\n\n  info->func = func;\n  info->ctx = ctx;\n\n  return info;\n}",
            "key_variables": [
               [
                  504,
                  "info->result"
               ]
            ]
         }
      ],
      "src/base/assets_manager.c": [
         {
            "type": "func",
            "name": "asset_cache_cmp_type",
            "line_range": [
               34,
               43
            ],
            "source_code": "static int asset_cache_cmp_type(const void* a, const void* b) {\n  const asset_info_t* aa = (const asset_info_t*)a;\n  const asset_info_t* bb = (const asset_info_t*)b;\n\n  if (aa->is_in_rom) {\n    return -1;\n  }\n\n  return aa->type - bb->type;\n}",
            "key_variables": [
               [
                  43,
                  "bb->type"
               ]
            ]
         },
         {
            "type": "func",
            "name": "asset_cache_cmp_type_and_name",
            "line_range": [
               45,
               58
            ],
            "source_code": "static int asset_cache_cmp_type_and_name(const void* a, const void* b) {\n  const asset_info_t* aa = (const asset_info_t*)a;\n  const asset_info_t* bb = (const asset_info_t*)b;\n\n  if (aa->is_in_rom) {\n    return -1;\n  }\n\n  if (aa->type == bb->type) {\n    return tk_str_cmp(aa->name, bb->name);\n  } else {\n    return aa->type - bb->type;\n  }\n}",
            "key_variables": [
               [
                  57,
                  "bb->type"
               ]
            ]
         },
         {
            "type": "func",
            "name": "assets_manager_get_system_info",
            "line_range": [
               94,
               98
            ],
            "source_code": "static system_info_t* assets_manager_get_system_info(assets_manager_t* am) {\n  return_value_if_fail(am != NULL, NULL);\n\n  return am->system_info != NULL ? am->system_info : system_info();\n}",
            "key_variables": [
               [
                  105,
                  "am->res_root"
               ]
            ]
         },
         {
            "type": "func",
            "name": "assets_manager_build_asset_filename",
            "line_range": [
               183,
               208
            ],
            "source_code": "ret_t assets_manager_build_asset_filename(assets_manager_t* am, char* path, uint32_t size,\n                                          const char* theme, bool_t ratio_sensitive,\n                                          const char* subpath, const char* name,\n                                          const char* extname) {\n  const char* ratio = NULL;\n  const char* res_root = assets_manager_get_res_root(am);\n  system_info_t* sysinfo = assets_manager_get_system_info(am);\n  return_value_if_fail(sysinfo != NULL, RET_BAD_PARAMS);\n  ratio = device_pixel_ratio_to_str(sysinfo->device_pixel_ratio);\n\n  if (ratio_sensitive) {\n    if (build_asset_filename_custom(am, path, size, theme, ratio, subpath, name, extname) ==\n        RET_OK) {\n      return RET_OK;\n    }\n\n    return build_asset_filename_default(path, size, res_root, theme, ratio, subpath, name, extname);\n  } else {\n    if (build_asset_filename_custom(am, path, size, theme, NULL, subpath, name, extname) ==\n        RET_OK) {\n      return RET_OK;\n    }\n\n    return build_asset_filename_default(path, size, res_root, theme, NULL, subpath, name, extname);\n  }\n}",
            "key_variables": [
               [
                  213,
                  "path[MAX_PATH + 1]"
               ]
            ]
         },
         {
            "type": "func",
            "name": "try_load_image",
            "line_range": [
               210,
               259
            ],
            "source_code": "static asset_info_t* try_load_image(assets_manager_t* am, const char* theme, const char* name,\n                                    asset_image_type_t subtype, bool_t ratio) {\n  char path[MAX_PATH + 1];\n  const char* extname = NULL;\n  const char* subpath = ratio ? \"images\" : \"images/xx\";\n\n  switch (subtype) {\n    case ASSET_TYPE_IMAGE_JPG: {\n      extname = \".jpg\";\n      break;\n    }\n    case ASSET_TYPE_IMAGE_PNG: {\n      extname = \".png\";\n      break;\n    }\n    case ASSET_TYPE_IMAGE_GIF: {\n      extname = \".gif\";\n      break;\n    }\n    case ASSET_TYPE_IMAGE_BMP: {\n      extname = \".bmp\";\n      break;\n    }\n    case ASSET_TYPE_IMAGE_BSVG: {\n      extname = \".bsvg\";\n      subpath = \"images/svg\";\n      break;\n    }\n    case ASSET_TYPE_IMAGE_OTHER: {\n      extname = \"\";\n      break;\n    }\n    default: {\n      return NULL;\n    }\n  }\n\n  return_value_if_fail(assets_manager_build_asset_filename(am, path, MAX_PATH, theme, ratio,\n                                                           subpath, name, extname) == RET_OK,\n                       NULL);\n\n  if (subtype == ASSET_TYPE_IMAGE_JPG && !asset_loader_exist(am->loader, path)) {\n    uint32_t len = strlen(path);\n    return_value_if_fail(MAX_PATH > len, NULL);\n    memcpy(path + len - 4, \".jpeg\", 5);\n    path[len + 1] = '\\0';\n  }\n\n  return asset_loader_load(am->loader, ASSET_TYPE_IMAGE, subtype, path, name);\n}",
            "key_variables": [
               [
                  264,
                  "path[MAX_PATH + 1]"
               ]
            ]
         },
         {
            "type": "func",
            "name": "assets_manager_set_locale_info",
            "line_range": [
               618,
               626
            ],
            "source_code": "ret_t assets_manager_set_locale_info(assets_manager_t* am, locale_info_t* locale_info) {\n  return_value_if_fail(am != NULL, RET_BAD_PARAMS);\n\n  if (locale_info != NULL) {\n    am->locale_info = locale_info;\n  }\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  666,
                  "all[i]"
               ]
            ]
         },
         {
            "type": "func",
            "name": "assets_manager_ref_impl",
            "line_range": [
               675,
               686
            ],
            "source_code": "static const asset_info_t* assets_manager_ref_impl(assets_manager_t* am, asset_type_t type,\n                                                   uint16_t subtype, const char* name) {\n  const asset_info_t* info = assets_manager_find_in_cache(am, type, subtype, name);\n\n  if (info == NULL) {\n    info = assets_manager_load_ex(am, type, subtype, name);\n  } else {\n    asset_info_ref((asset_info_t*)info);\n  }\n\n  return info;\n}",
            "key_variables": [
               [
                  704,
                  "locale[TK_NAME_LEN + 1]"
               ],
               [
                  705,
                  "real_name[TK_NAME_LEN + 1]"
               ],
               [
                  706,
                  "locale_info->language"
               ],
               [
                  707,
                  "locale_info->country"
               ]
            ]
         }
      ],
      "src/base/asset_loader_default.c": [
         {
            "type": "func",
            "name": "load_asset_with_mmap",
            "line_range": [
               27,
               45
            ],
            "source_code": "static asset_info_t* load_asset_with_mmap(uint16_t type, uint16_t subtype, const char* path,\n                                          const char* name) {\n#ifdef LOAD_ASSET_WITH_MMAP\n  if (file_get_size(path) >= MMAP_ASSET_MIN_SIZE) {\n    asset_info_t* info = asset_info_create(type, subtype, name, 0);\n    return_value_if_fail(info != NULL, NULL);\n\n    info->map = mmap_create(path, FALSE, FALSE);\n    if (info->map != NULL) {\n      info->data = info->map->data;\n      info->size = info->map->size;\n      return info;\n    } else {\n      asset_info_destroy(info);\n    }\n  }\n#endif /*LOAD_ASSET_WITH_MMAP*/\n  return NULL;\n}",
            "key_variables": [
               [
                  37,
                  "map->data"
               ],
               [
                  38,
                  "map->size"
               ]
            ]
         }
      ],
      "src/base/bidi.c": [
         {
            "type": "func",
            "name": "bidi_init",
            "line_range": [
               87,
               96
            ],
            "source_code": "bidi_t* bidi_init(bidi_t* bidi, bool_t alloc_l2v, bool_t alloc_v2l, bidi_type_t type) {\n  return_value_if_fail(bidi != NULL, NULL);\n  memset(bidi, 0x00, sizeof(*bidi));\n\n  bidi->request_type = type;\n  bidi->alloc_l2v = alloc_l2v;\n  bidi->alloc_v2l = alloc_v2l;\n\n  return bidi;\n}",
            "key_variables": [
               [
                  105,
                  "bidi->vis_str_static"
               ]
            ]
         }
      ],
      "src/base/bitmap.c": [
         {
            "type": "func",
            "name": "bitmap_init_rgba8888",
            "line_range": [
               236,
               263
            ],
            "source_code": "ret_t bitmap_init_rgba8888(bitmap_t* bitmap, uint32_t w, uint32_t h, const uint8_t* data,\n                           uint32_t comp) {\n  uint32_t i = 0;\n  uint32_t j = 0;\n  uint8_t* bdata = bitmap_lock_buffer_for_write(bitmap);\n  return_value_if_fail(bdata != NULL && data != NULL, RET_BAD_PARAMS);\n\n  if (comp == 4) {\n    for (i = 0; i < h; i++) {\n      memcpy((uint8_t*)(bdata) + i * bitmap->line_length, data + i * w * 4, w * 4);\n    }\n  } else {\n    const uint8_t* s = data;\n    uint8_t* d = (uint8_t*)(bdata);\n    for (j = 0; j < h; j++) {\n      d = (uint8_t*)(bdata) + j * bitmap->line_length;\n      for (i = 0; i < w; i++) {\n        *d++ = *s++;\n        *d++ = *s++;\n        *d++ = *s++;\n        *d++ = 0xff;\n      }\n    }\n  }\n  bitmap_unlock_buffer(bitmap);\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  252,
                  "bitmap->line_length"
               ],
               [
                  276,
                  "bitmap->line_length"
               ],
               [
                  278,
                  "s[2]"
               ],
               [
                  279,
                  "s[1]"
               ],
               [
                  280,
                  "s[0]"
               ],
               [
                  281,
                  "s[3]"
               ]
            ]
         },
         {
            "type": "func",
            "name": "bitmap_init_bgra8888",
            "line_range": [
               265,
               288
            ],
            "source_code": "ret_t bitmap_init_bgra8888(bitmap_t* bitmap, uint32_t w, uint32_t h, const uint8_t* data,\n                           uint32_t comp) {\n  uint32_t i = 0;\n  uint32_t j = 0;\n  const uint8_t* s = data;\n  uint8_t* bdata = bitmap_lock_buffer_for_write(bitmap);\n  uint8_t* d = bdata;\n\n  /*bgra=rgba*/\n  for (j = 0; j < h; j++) {\n    d = (uint8_t*)(bdata) + j * bitmap->line_length;\n    for (i = 0; i < w; i++) {\n      d[0] = s[2];\n      d[1] = s[1];\n      d[2] = s[0];\n      d[3] = (comp == 3) ? 0xff : s[3];\n      d += 4;\n      s += comp;\n    }\n  }\n  bitmap_unlock_buffer(bitmap);\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  302,
                  "s[0]"
               ],
               [
                  303,
                  "s[1]"
               ],
               [
                  304,
                  "s[2]"
               ]
            ]
         },
         {
            "type": "func",
            "name": "bitmap_init_rgb565",
            "line_range": [
               290,
               313
            ],
            "source_code": "ret_t bitmap_init_rgb565(bitmap_t* bitmap, uint32_t w, uint32_t h, const uint8_t* data,\n                         uint32_t comp) {\n  uint32_t i = 0;\n  uint32_t j = 0;\n  const uint8_t* s = data;\n  uint8_t* bdata = bitmap_lock_buffer_for_write(bitmap);\n  uint16_t* d = (uint16_t*)(bdata);\n\n  for (j = 0; j < h; j++) {\n    d = (uint16_t*)((bdata) + j * bitmap->line_length);\n    for (i = 0; i < w; i++) {\n      uint8_t r = s[0];\n      uint8_t g = s[1];\n      uint8_t b = s[2];\n\n      *d++ = rgb_to_rgb565(r, g, b);\n\n      s += comp;\n    }\n  }\n  bitmap_unlock_buffer(bitmap);\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  327,
                  "s[0]"
               ],
               [
                  328,
                  "s[1]"
               ],
               [
                  329,
                  "s[2]"
               ],
               [
                  352,
                  "s[0]"
               ],
               [
                  353,
                  "s[1]"
               ],
               [
                  354,
                  "s[2]"
               ],
               [
                  357,
                  "s[3]"
               ]
            ]
         },
         {
            "type": "func",
            "name": "bitmap_init_mono",
            "line_range": [
               340,
               371
            ],
            "source_code": "ret_t bitmap_init_mono(bitmap_t* bitmap, uint32_t w, uint32_t h, const uint8_t* data,\n                       uint32_t comp) {\n  uint32_t i = 0;\n  uint32_t j = 0;\n  bool_t pixel = FALSE;\n  const uint8_t* s = data;\n  uint8_t* bdata = bitmap_lock_buffer_for_write(bitmap);\n  uint8_t* d = (uint8_t*)(bdata);\n\n  for (j = 0; j < h; j++) {\n    for (i = 0; i < w; i++) {\n      uint8_t r = s[0];\n      uint8_t g = s[1];\n      uint8_t b = s[2];\n\n      if (comp == 4) {\n        uint8_t a = s[3];\n        r = (r * a) >> 8;\n        g = (g * a) >> 8;\n        b = (b * a) >> 8;\n      }\n\n      pixel = rgb_to_gray(r, g, b) > 10;\n      bitmap_mono_set_pixel(d, w, h, i, j, pixel);\n\n      s += comp;\n    }\n  }\n  bitmap_unlock_buffer(bitmap);\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  383,
                  "s[0]"
               ],
               [
                  384,
                  "s[1]"
               ],
               [
                  385,
                  "s[2]"
               ],
               [
                  388,
                  "s[3]"
               ]
            ]
         },
         {
            "type": "func",
            "name": "bitmap_set_line_length",
            "line_range": [
               511,
               522
            ],
            "source_code": "ret_t bitmap_set_line_length(bitmap_t* bitmap, uint32_t line_length) {\n  return_value_if_fail(bitmap != NULL, RET_BAD_PARAMS);\n\n  if (bitmap->format == BITMAP_FMT_MONO) {\n    bitmap->line_length = TK_BITMAP_MONO_LINE_LENGTH(bitmap->w);\n  } else {\n    uint32_t bpp = bitmap_get_bpp(bitmap);\n    bitmap->line_length = tk_max(bitmap->w * bpp, line_length);\n  }\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  532,
                  "bitmap->line_length"
               ]
            ]
         },
         {
            "type": "func",
            "name": "bitmap_get_line_length",
            "line_range": [
               524,
               532
            ],
            "source_code": "uint32_t bitmap_get_line_length(bitmap_t* bitmap) {\n  return_value_if_fail(bitmap != NULL, 0);\n\n  if (bitmap->line_length == 0) {\n    bitmap_set_line_length(bitmap, 0);\n  }\n\n  return bitmap->line_length;\n}",
            "key_variables": [
               [
                  543,
                  "s[a_index]"
               ]
            ]
         },
         {
            "type": "func",
            "name": "bitmap_premulti_alpha",
            "line_range": [
               554,
               585
            ],
            "source_code": "ret_t bitmap_premulti_alpha(bitmap_t* bitmap) {\n  ret_t ret = RET_FAIL;\n  uint8_t* bitmap_data = NULL;\n  return_value_if_fail(bitmap != NULL, RET_BAD_PARAMS);\n\n  if (bitmap->flags & BITMAP_FLAG_PREMULTI_ALPHA) {\n    return RET_OK;\n  }\n\n  bitmap_data = bitmap_lock_buffer_for_write(bitmap);\n  return_value_if_fail(bitmap != NULL, RET_BAD_PARAMS);\n\n  switch (bitmap->format) {\n    case BITMAP_FMT_RGBA8888:\n    case BITMAP_FMT_BGRA8888: {\n      ret = rgba_data_premulti_alpha(bitmap_data, 3, bitmap->w, bitmap->h);\n      break;\n    }\n    case BITMAP_FMT_ABGR8888:\n    case BITMAP_FMT_ARGB8888: {\n      ret = rgba_data_premulti_alpha(bitmap_data, 0, bitmap->w, bitmap->h);\n      break;\n    }\n  }\n\n  if (ret == RET_OK) {\n    bitmap->flags = bitmap->flags | BITMAP_FLAG_PREMULTI_ALPHA;\n  }\n  bitmap_unlock_buffer(bitmap);\n\n  return ret;\n}",
            "key_variables": [
               [
                  604,
                  "bitmap->name"
               ],
               [
                  633,
                  "bitmap->h"
               ],
               [
                  635,
                  "bitmap->w"
               ]
            ]
         },
         {
            "type": "func",
            "name": "bitmap_lock_buffer_for_read",
            "line_range": [
               756,
               768
            ],
            "source_code": "uint8_t* bitmap_lock_buffer_for_read(bitmap_t* bitmap) {\n  return_value_if_fail(bitmap != NULL, NULL);\n\n  if (bitmap->buffer != NULL) {\n    if (!graphic_buffer_is_valid_for(bitmap->buffer, bitmap)) {\n      assert(!\" graphic_buffer is not valid \");\n      return NULL;\n    }\n    return graphic_buffer_lock_for_read(bitmap->buffer);\n  } else {\n    return NULL;\n  }\n}",
            "key_variables": [
               [
                  807,
                  "bitmap->h"
               ],
               [
                  809,
                  "bitmap->w"
               ]
            ]
         }
      ],
      "src/base/canvas.c": [
         {
            "type": "block",
            "name": "block",
            "line_range": "",
            "source_code": "",
            "key_variables": [
               44,
               "img->h"
            ]
         },
         {
            "type": "block",
            "name": "block",
            "line_range": "",
            "source_code": "",
            "key_variables": [
               52,
               "o->w"
            ]
         },
         {
            "type": "block",
            "name": "block",
            "line_range": "",
            "source_code": "",
            "key_variables": [
               57,
               "o->h"
            ]
         },
         {
            "type": "func",
            "name": "canvas_fix_rect",
            "line_range": [
               92,
               128
            ],
            "source_code": "static rect_t* canvas_fix_rect(const rect_t* r, rect_t* o) {\n\n  if (r != NULL) {\n\n    *o = *r;\n\n\n\n    if (o->w < 0) {\n\n      o->w = -o->w;\n\n      o->x = o->x - o->w + 1;\n\n    }\n\n\n\n    if (o->h < 0) {\n\n      o->h = -o->h;\n\n      o->y = o->y - o->h + 1;\n\n    }\n\n\n\n    return o;\n\n  } else {\n\n    return NULL;\n\n  }\n\n}",
            "key_variables": [
               [
                  138,
                  "c->clip_left"
               ],
               [
                  139,
                  "c->clip_top"
               ]
            ]
         },
         {
            "type": "func",
            "name": "canvas_get_width",
            "line_range": [
               196,
               204
            ],
            "source_code": "wh_t canvas_get_width(canvas_t* c) {\n\n  return_value_if_fail(c != NULL, 0);\n\n\n\n  return lcd_get_width(c->lcd);\n\n}",
            "key_variables": [
               [
                  233,
                  "c->ox"
               ],
               [
                  234,
                  "c->oy"
               ]
            ]
         },
         {
            "type": "func",
            "name": "canvas_set_assets_manager",
            "line_range": [
               236,
               264
            ],
            "source_code": "ret_t canvas_set_assets_manager(canvas_t* c, assets_manager_t* assets_manager) {\n\n  vgcanvas_t* vgcanvas = NULL;\n\n  return_value_if_fail(c != NULL && assets_manager != NULL, RET_BAD_PARAMS);\n\n\n\n  vgcanvas = lcd_get_vgcanvas(c->lcd);\n\n  c->assets_manager = assets_manager;\n\n  if (vgcanvas != NULL) {\n\n    vgcanvas_set_assets_manager(vgcanvas, assets_manager);\n\n  }\n\n  if (c->font_manager != NULL) {\n\n    font_manager_set_assets_manager(c->font_manager, assets_manager);\n\n  }\n\n\n\n  return RET_OK;\n\n}",
            "key_variables": [
               [
                  307,
                  "str[i]"
               ]
            ]
         },
         {
            "type": "func",
            "name": "canvas_get_clip_rect",
            "line_range": [
               268,
               292
            ],
            "source_code": "ret_t canvas_get_clip_rect(canvas_t* c, rect_t* r) {\n\n  return_value_if_fail(c != NULL && r != NULL, RET_BAD_PARAMS);\n\n\n\n  r->x = c->clip_left;\n\n  r->y = c->clip_top;\n\n  r->w = c->clip_right - c->clip_left + 1;\n\n  r->h = c->clip_bottom - c->clip_top + 1;\n\n\n\n  if (c->lcd->get_clip_rect != NULL) {\n\n    return lcd_get_clip_rect(c->lcd, r);\n\n  }\n\n  return RET_OK;\n\n}",
            "key_variables": [
               [
                  467,
                  "c->clip_left"
               ],
               [
                  468,
                  "c->clip_top"
               ],
               [
                  469,
                  "c->clip_right"
               ],
               [
                  470,
                  "c->clip_bottom"
               ],
               [
                  472,
                  "real_points[MAX_POINTS_PER_DRAW]"
               ]
            ]
         },
         {
            "type": "func",
            "name": "canvas_set_fill_color",
            "line_range": [
               480,
               492
            ],
            "source_code": "ret_t canvas_set_fill_color(canvas_t* c, color_t color) {\n\n  return_value_if_fail(c != NULL, RET_BAD_PARAMS);\n\n\n\n  lcd_set_fill_color(c->lcd, color);\n\n\n\n  return RET_OK;\n\n}",
            "key_variables": [
               [
                  481,
                  "c->ox"
               ],
               [
                  482,
                  "c->oy"
               ]
            ]
         },
         {
            "type": "func",
            "name": "canvas_set_global_alpha",
            "line_range": [
               528,
               542
            ],
            "source_code": "ret_t canvas_set_global_alpha(canvas_t* c, uint8_t alpha) {\n\n  return_value_if_fail(c != NULL, RET_BAD_PARAMS);\n\n\n\n  c->global_alpha = alpha;\n\n  lcd_set_global_alpha(c->lcd, alpha);\n\n\n\n  return RET_OK;\n\n}",
            "key_variables": [
               [
                  567,
                  "c->lcd"
               ]
            ]
         },
         {
            "type": "func",
            "name": "canvas_measure_text_default",
            "line_range": [
               598,
               630
            ],
            "source_code": "static float_t canvas_measure_text_default(canvas_t* c, const wchar_t* str, uint32_t nr) {\n\n  glyph_t g;\n\n  float_t w = 0;\n\n  uint32_t i = 0;\n\n  return_value_if_fail(c != NULL && str != NULL && c->font != NULL, 0);\n\n\n\n  for (i = 0; i < nr; i++) {\n\n    wchar_t chr = str[i];\n\n    if (font_get_glyph(c->font, chr, c->font_size, &g) == RET_OK) {\n\n      w += g.advance + 1;\n\n    } else {\n\n      w += 4;\n\n    }\n\n  }\n\n\n\n  return w;\n\n}",
            "key_variables": [
               [
                  671,
                  "c->font_size"
               ]
            ]
         },
         {
            "type": "func",
            "name": "canvas_measure_text",
            "line_range": [
               634,
               650
            ],
            "source_code": "float_t canvas_measure_text(canvas_t* c, const wchar_t* str, uint32_t nr) {\n\n  return_value_if_fail(c != NULL && c->lcd != NULL && str != NULL, 0);\n\n\n\n  if (c->lcd->measure_text) {\n\n    return lcd_measure_text(c->lcd, str, nr);\n\n  } else {\n\n    return canvas_measure_text_default(c, str, nr);\n\n  }\n\n}",
            "key_variables": [
               [
                  693,
                  "c->font_size"
               ],
               [
                  697,
                  "str[i]"
               ],
               [
                  760,
                  "d->x"
               ],
               [
                  761,
                  "d->y"
               ]
            ]
         },
         {
            "type": "func",
            "name": "canvas_measure_utf8",
            "line_range": [
               654,
               678
            ],
            "source_code": "float_t canvas_measure_utf8(canvas_t* c, const char* str) {\n\n  wstr_t s;\n\n  float_t ret = 0;\n\n  return_value_if_fail(c != NULL && c->lcd != NULL && str != NULL, 0);\n\n\n\n  wstr_init(&s, 0);\n\n  return_value_if_fail(wstr_set_utf8(&s, str) == RET_OK, 0);\n\n\n\n  ret = canvas_measure_text(c, s.str, s.size);\n\n  wstr_reset(&s);\n\n\n\n  return ret;\n\n}",
            "key_variables": [
               [
                  781,
                  "d->w"
               ],
               [
                  782,
                  "d->h"
               ]
            ]
         },
         {
            "type": "func",
            "name": "canvas_measure_text",
            "line_range": [
               634,
               650
            ],
            "source_code": "float_t canvas_measure_text(canvas_t* c, const wchar_t* str, uint32_t nr) {\n\n  return_value_if_fail(c != NULL && c->lcd != NULL && str != NULL, 0);\n\n\n\n  if (c->lcd->measure_text) {\n\n    return lcd_measure_text(c->lcd, str, nr);\n\n  } else {\n\n    return canvas_measure_text_default(c, str, nr);\n\n  }\n\n}",
            "key_variables": [
               [
                  805,
                  "dst->x"
               ],
               [
                  806,
                  "dst->y"
               ],
               [
                  807,
                  "dst->w"
               ]
            ]
         },
         {
            "type": "func",
            "name": "canvas_measure_utf8",
            "line_range": [
               654,
               678
            ],
            "source_code": "float_t canvas_measure_utf8(canvas_t* c, const char* str) {\n\n  wstr_t s;\n\n  float_t ret = 0;\n\n  return_value_if_fail(c != NULL && c->lcd != NULL && str != NULL, 0);\n\n\n\n  wstr_init(&s, 0);\n\n  return_value_if_fail(wstr_set_utf8(&s, str) == RET_OK, 0);\n\n\n\n  ret = canvas_measure_text(c, s.str, s.size);\n\n  wstr_reset(&s);\n\n\n\n  return ret;\n\n}",
            "key_variables": [
               [
                  808,
                  "dst->h"
               ]
            ]
         },
         {
            "type": "func",
            "name": "canvas_begin_frame",
            "line_range": [
               682,
               776
            ],
            "source_code": "ret_t canvas_begin_frame(canvas_t* c, const dirty_rects_t* dirty_rects, lcd_draw_mode_t draw_mode) {\n\n  rect_t dirty_rect;\n\n  ret_t ret = RET_OK;\n\n  return_value_if_fail(c != NULL, RET_BAD_PARAMS);\n\n  if (c->began_frame) {\n\n    return RET_OK;\n\n  } else {\n\n    c->began_frame = TRUE;\n\n  }\n\n\n\n  if (c->begin_frame) {\n\n    return c->begin_frame(c, dirty_rects, draw_mode);\n\n  }\n\n\n\n  c->ox = 0;\n\n  c->oy = 0;\n\n\n\n  canvas_set_global_alpha(c, 0xff);\n\n  lcd_set_canvas(c->lcd, c);\n\n  /* 把当前帧的脏矩形列表传入到 lcd 中和 fb 的脏矩形列表合并得出新的脏矩形列表。*/\n\n  if (c->lcd->support_dirty_rect) {\n\n    ret = lcd_begin_frame(c->lcd, dirty_rects, draw_mode);\n\n  } else {\n\n    ret = lcd_begin_frame(c->lcd, NULL, draw_mode);\n\n  }\n\n  return_value_if_fail(ret == RET_OK, ret);\n\n  /* 获取新的最大的脏矩形，然后设置裁剪区 */\n\n  ret = lcd_get_dirty_rect(c->lcd, &dirty_rect);\n\n  if (c->lcd->support_dirty_rect && ret == RET_OK) {\n\n    if (draw_mode == LCD_DRAW_NORMAL && c->lcd->type == LCD_VGCANVAS) {\n\n      rect_t r = dirty_rect;\n\n\n\n      /*for vgcanvas anti alias*/\n\n      r.x--;\n\n      r.y--;\n\n      r.w += 2;\n\n      r.h += 2;\n\n\n\n      canvas_set_clip_rect(c, &r);\n\n    } else {\n\n      canvas_set_clip_rect(c, &dirty_rect);\n\n    }\n\n  } else {\n\n    canvas_set_clip_rect(c, NULL);\n\n  }\n\n\n\n  return ret;\n\n}",
            "key_variables": [
               [
                  828,
                  "src_in->x"
               ],
               [
                  829,
                  "src_in->y"
               ],
               [
                  830,
                  "src_in->w"
               ],
               [
                  831,
                  "src_in->h"
               ],
               [
                  847,
                  "dst->x"
               ],
               [
                  848,
                  "dst->y"
               ]
            ]
         },
         {
            "type": "func",
            "name": "canvas_draw_vline",
            "line_range": [
               856,
               874
            ],
            "source_code": "ret_t canvas_draw_vline(canvas_t* c, xy_t x, xy_t y, wh_t h) {\n\n  return_value_if_fail(c != NULL, RET_BAD_PARAMS);\n\n\n\n  if (h < 0) {\n\n    h = -h;\n\n    y = y - h + 1;\n\n  }\n\n\n\n  return canvas_draw_vline_impl(c, c->ox + x, c->oy + y, h);\n\n}",
            "key_variables": [
               [
                  864,
                  "c->ox"
               ],
               [
                  865,
                  "c->oy"
               ],
               [
                  866,
                  "dst_in->w"
               ],
               [
                  867,
                  "dst_in->h"
               ],
               [
                  883,
                  "c->ox"
               ],
               [
                  884,
                  "c->oy"
               ],
               [
                  885,
                  "dst_in->w"
               ],
               [
                  886,
                  "dst_in->h"
               ],
               [
                  902,
                  "c->ox"
               ],
               [
                  903,
                  "c->oy"
               ],
               [
                  904,
                  "dst_in->w"
               ],
               [
                  905,
                  "dst_in->h"
               ],
               [
                  923,
                  "img->w"
               ],
               [
                  924,
                  "img->h"
               ]
            ]
         },
         {
            "type": "func",
            "name": "canvas_draw_line_impl",
            "line_range": [
               878,
               906
            ],
            "source_code": "static ret_t canvas_draw_line_impl(canvas_t* c, xy_t x1, xy_t y1, xy_t x2, xy_t y2) {\n\n  if ((x1 < c->clip_left && x2 < c->clip_left) || (x1 > c->clip_right && x2 > c->clip_right) ||\n\n      (y1 < c->clip_top && y2 < c->clip_top) || (y1 > c->clip_bottom && y2 > c->clip_bottom)) {\n\n    return RET_OK;\n\n  }\n\n\n\n  if (x1 == x2) {\n\n    return canvas_draw_vline_impl(c, x1, y1, tk_abs(y2 - y1) + 1);\n\n  } else if (y1 == y2) {\n\n    return canvas_draw_hline_impl(c, x1, y1, tk_abs(x2 - x1) + 1);\n\n  } else {\n\n    assert(!\"Not implemented yet, please use vgcanvas to draw line\");\n\n    return RET_NOT_IMPL;\n\n  }\n\n}",
            "key_variables": [
               [
                  950,
                  "img->w"
               ],
               [
                  951,
                  "img->h"
               ],
               [
                  952,
                  "dst->w"
               ],
               [
                  953,
                  "dst->h"
               ]
            ]
         },
         {
            "type": "func",
            "name": "canvas_draw_points_impl",
            "line_range": [
               978,
               1010
            ],
            "source_code": "static ret_t canvas_draw_points_impl(canvas_t* c, const point_t* points, uint32_t nr) {\n\n  uint32_t i = 0;\n\n  const point_t* p = points;\n\n  uint32_t n = (nr / MAX_POINTS_PER_DRAW);\n\n  uint32_t r = (nr % MAX_POINTS_PER_DRAW);\n\n\n\n  for (i = 0; i <= n; i++) {\n\n    if (i == n) {\n\n      canvas_do_draw_points(c, p, r);\n\n    } else {\n\n      canvas_do_draw_points(c, p, MAX_POINTS_PER_DRAW);\n\n      p += MAX_POINTS_PER_DRAW;\n\n    }\n\n  }\n\n\n\n  return RET_OK;\n\n}",
            "key_variables": [
               [
                  1039,
                  "img->w"
               ],
               [
                  1040,
                  "img->h"
               ]
            ]
         },
         {
            "type": "func",
            "name": "canvas_fill_rect_impl",
            "line_range": [
               1026,
               1058
            ],
            "source_code": "static ret_t canvas_fill_rect_impl(canvas_t* c, xy_t x, xy_t y, wh_t w, wh_t h) {\n\n  xy_t x2 = x + w - 1;\n\n  xy_t y2 = y + h - 1;\n\n\n\n  if (x > c->clip_right || x2 < c->clip_left || y > c->clip_bottom || y2 < c->clip_top) {\n\n    return RET_OK;\n\n  }\n\n\n\n  x = tk_max(x, c->clip_left);\n\n  y = tk_max(y, c->clip_top);\n\n  x2 = tk_min(x2, c->clip_right);\n\n  y2 = tk_min(y2, c->clip_bottom);\n\n  w = x2 - x + 1;\n\n  h = y2 - y + 1;\n\n\n\n  return lcd_fill_rect(c->lcd, x, y, w, h);\n\n}",
            "key_variables": [
               [
                  1064,
                  "img->w"
               ],
               [
                  1065,
                  "img->h"
               ],
               [
                  1066,
                  "dst->w"
               ],
               [
                  1067,
                  "dst->h"
               ],
               [
                  1112,
                  "img->w"
               ],
               [
                  1113,
                  "img->h"
               ],
               [
                  1135,
                  "img->w"
               ],
               [
                  1136,
                  "img->h"
               ],
               [
                  1137,
                  "dst->w"
               ],
               [
                  1138,
                  "dst->h"
               ]
            ]
         },
         {
            "type": "func",
            "name": "canvas_fill_rect",
            "line_range": [
               1062,
               1072
            ],
            "source_code": "ret_t canvas_fill_rect(canvas_t* c, xy_t x, xy_t y, wh_t w, wh_t h) {\n\n  return_value_if_fail(c != NULL, RET_BAD_PARAMS);\n\n\n\n  fix_xywh(x, y, w, h);\n\n  return canvas_fill_rect_impl(c, c->ox + x, c->oy + y, w, h);\n\n}",
            "key_variables": [
               [
                  1186,
                  "img->w"
               ],
               [
                  1187,
                  "img->h"
               ]
            ]
         },
         {
            "type": "func",
            "name": "canvas_fill_rect_gradient_impl",
            "line_range": [
               1076,
               1176
            ],
            "source_code": "static ret_t canvas_fill_rect_gradient_impl(canvas_t* c, xy_t x, xy_t y, wh_t w, wh_t h,\n\n                                            gradient_t* gradient) {\n\n  xy_t x2 = x + w - 1;\n\n  xy_t y2 = y + h - 1;\n\n  vgcanvas_t* vg = NULL;\n\n\n\n  if (x > c->clip_right || x2 < c->clip_left || y > c->clip_bottom || y2 < c->clip_top) {\n\n    return RET_OK;\n\n  }\n\n\n\n  x = tk_max(x, c->clip_left);\n\n  y = tk_max(y, c->clip_top);\n\n  x2 = tk_min(x2, c->clip_right);\n\n  y2 = tk_min(y2, c->clip_bottom);\n\n  w = x2 - x + 1;\n\n  h = y2 - y + 1;\n\n  if (w == 0 || h == 0) {\n\n    return RET_OK;\n\n  }\n\n\n\n  /*FIXME: to support general cases*/\n\n  return_value_if_fail(gradient->type == GRADIENT_LINEAR && gradient->degree == 180,\n\n                       RET_BAD_PARAMS);\n\n\n\n#ifndef WITH_GPU\n\n  if (gradient->type == GRADIENT_LINEAR) {\n\n    if (gradient->degree == 180) {\n\n      uint32_t i = 0;\n\n      lcd_t* lcd = c->lcd;\n\n      for (i = 0; i < h; i++) {\n\n        float offset = (float)i / (float)h;\n\n        color_t color = gradient_get_color(gradient, offset);\n\n        lcd_set_stroke_color(lcd, color);\n\n        lcd_draw_hline(lcd, x, y + i, w);\n\n      }\n\n      return RET_OK;\n\n    }\n\n  }\n\n#endif\n\n  vg = canvas_get_vgcanvas(c);\n\n  if (vg != NULL) {\n\n    vg_gradient_t vg_gradient;\n\n    rect_t rect = {x, y, w, h};\n\n    vg_gradient_init_with_gradient(&vg_gradient, &rect, gradient);\n\n    vgcanvas_set_fill_gradient(vg, &vg_gradient);\n\n    vgcanvas_rect(vg, x, y, w, h);\n\n    vgcanvas_fill(vg);\n\n  }\n\n\n\n  return RET_NOT_IMPL;\n\n}",
            "key_variables": [
               [
                  1224,
                  "img->w"
               ],
               [
                  1225,
                  "img->h"
               ],
               [
                  1226,
                  "dst->w"
               ]
            ]
         },
         {
            "type": "func",
            "name": "canvas_fill_rect",
            "line_range": [
               1062,
               1072
            ],
            "source_code": "ret_t canvas_fill_rect(canvas_t* c, xy_t x, xy_t y, wh_t w, wh_t h) {\n\n  return_value_if_fail(c != NULL, RET_BAD_PARAMS);\n\n\n\n  fix_xywh(x, y, w, h);\n\n  return canvas_fill_rect_impl(c, c->ox + x, c->oy + y, w, h);\n\n}",
            "key_variables": [
               [
                  1227,
                  "dst->h"
               ]
            ]
         },
         {
            "type": "func",
            "name": "canvas_fill_rect_gradient",
            "line_range": [
               1180,
               1190
            ],
            "source_code": "ret_t canvas_fill_rect_gradient(canvas_t* c, xy_t x, xy_t y, wh_t w, wh_t h, gradient_t* gradient) {\n\n  return_value_if_fail(c != NULL, RET_BAD_PARAMS);\n\n\n\n  fix_xywh(x, y, w, h);\n\n  return canvas_fill_rect_gradient_impl(c, c->ox + x, c->oy + y, w, h, gradient);\n\n}",
            "key_variables": [
               [
                  1269,
                  "img->w"
               ],
               [
                  1270,
                  "img->h"
               ]
            ]
         },
         {
            "type": "func",
            "name": "canvas_fill_rect_gradient_impl",
            "line_range": [
               1076,
               1176
            ],
            "source_code": "static ret_t canvas_fill_rect_gradient_impl(canvas_t* c, xy_t x, xy_t y, wh_t w, wh_t h,\n\n                                            gradient_t* gradient) {\n\n  xy_t x2 = x + w - 1;\n\n  xy_t y2 = y + h - 1;\n\n  vgcanvas_t* vg = NULL;\n\n\n\n  if (x > c->clip_right || x2 < c->clip_left || y > c->clip_bottom || y2 < c->clip_top) {\n\n    return RET_OK;\n\n  }\n\n\n\n  x = tk_max(x, c->clip_left);\n\n  y = tk_max(y, c->clip_top);\n\n  x2 = tk_min(x2, c->clip_right);\n\n  y2 = tk_min(y2, c->clip_bottom);\n\n  w = x2 - x + 1;\n\n  h = y2 - y + 1;\n\n  if (w == 0 || h == 0) {\n\n    return RET_OK;\n\n  }\n\n\n\n  /*FIXME: to support general cases*/\n\n  return_value_if_fail(gradient->type == GRADIENT_LINEAR && gradient->degree == 180,\n\n                       RET_BAD_PARAMS);\n\n\n\n#ifndef WITH_GPU\n\n  if (gradient->type == GRADIENT_LINEAR) {\n\n    if (gradient->degree == 180) {\n\n      uint32_t i = 0;\n\n      lcd_t* lcd = c->lcd;\n\n      for (i = 0; i < h; i++) {\n\n        float offset = (float)i / (float)h;\n\n        color_t color = gradient_get_color(gradient, offset);\n\n        lcd_set_stroke_color(lcd, color);\n\n        lcd_draw_hline(lcd, x, y + i, w);\n\n      }\n\n      return RET_OK;\n\n    }\n\n  }\n\n#endif\n\n  vg = canvas_get_vgcanvas(c);\n\n  if (vg != NULL) {\n\n    vg_gradient_t vg_gradient;\n\n    rect_t rect = {x, y, w, h};\n\n    vg_gradient_init_with_gradient(&vg_gradient, &rect, gradient);\n\n    vgcanvas_set_fill_gradient(vg, &vg_gradient);\n\n    vgcanvas_rect(vg, x, y, w, h);\n\n    vgcanvas_fill(vg);\n\n  }\n\n\n\n  return RET_NOT_IMPL;\n\n}",
            "key_variables": [
               [
                  1271,
                  "dst->w"
               ],
               [
                  1272,
                  "dst->h"
               ]
            ]
         },
         {
            "type": "func",
            "name": "canvas_stroke_rect_impl",
            "line_range": [
               1244,
               1270
            ],
            "source_code": "static ret_t canvas_stroke_rect_impl(canvas_t* c, xy_t x, xy_t y, wh_t w, wh_t h) {\n\n  return_value_if_fail(c != NULL && c->lcd != NULL && w > 0 && h > 0, RET_BAD_PARAMS);\n\n\n\n  if (c->lcd->stroke_rect != NULL) {\n\n    lcd_stroke_rect(c->lcd, x, y, w, h);\n\n  } else {\n\n    canvas_draw_hline_impl(c, x, y, w);\n\n    canvas_draw_hline_impl(c, x, y + h - 1, w);\n\n    canvas_draw_vline_impl(c, x, y, h);\n\n    canvas_draw_vline_impl(c, x + w - 1, y, h);\n\n  }\n\n\n\n  return RET_OK;\n\n}",
            "key_variables": [
               [
                  1315,
                  "img->w"
               ],
               [
                  1316,
                  "img->h"
               ],
               [
                  1317,
                  "dst->w"
               ],
               [
                  1318,
                  "dst->h"
               ]
            ]
         },
         {
            "type": "func",
            "name": "canvas_stroke_rect",
            "line_range": [
               1274,
               1284
            ],
            "source_code": "ret_t canvas_stroke_rect(canvas_t* c, xy_t x, xy_t y, wh_t w, wh_t h) {\n\n  return_value_if_fail(c != NULL, RET_BAD_PARAMS);\n\n\n\n  fix_xywh(x, y, w, h);\n\n  return canvas_stroke_rect_impl(c, c->ox + x, c->oy + y, w, h);\n\n}",
            "key_variables": [
               [
                  1360,
                  "img->w"
               ],
               [
                  1361,
                  "img->h"
               ],
               [
                  1362,
                  "dst->w"
               ],
               [
                  1363,
                  "dst->h"
               ]
            ]
         },
         {
            "type": "func",
            "name": "canvas_draw_char_impl",
            "line_range": [
               1336,
               1356
            ],
            "source_code": "static ret_t canvas_draw_char_impl(canvas_t* c, wchar_t chr, xy_t x, xy_t y) {\n\n  glyph_t g;\n\n  font_size_t font_size = c->font_size;\n\n  font_vmetrics_t vmetrics = font_get_vmetrics(c->font, c->font_size);\n\n  return_value_if_fail(font_get_glyph(c->font, chr, font_size, &g) == RET_OK, RET_BAD_PARAMS);\n\n\n\n  x += g.x;\n\n  y += vmetrics.ascent + g.y;\n\n\n\n  return canvas_draw_glyph(c, &g, x, y);\n\n}",
            "key_variables": [
               [
                  1409,
                  "img->w"
               ],
               [
                  1410,
                  "img->h"
               ],
               [
                  1411,
                  "dst->w"
               ],
               [
                  1412,
                  "dst->h"
               ]
            ]
         },
         {
            "type": "func",
            "name": "canvas_draw_text",
            "line_range": [
               1460,
               1474
            ],
            "source_code": "ret_t canvas_draw_text(canvas_t* c, const wchar_t* str, uint32_t nr, xy_t x, xy_t y) {\n\n  return_value_if_fail(c != NULL && c->lcd != NULL && str != NULL, RET_BAD_PARAMS);\n\n  if (c->lcd->draw_text != NULL) {\n\n    return lcd_draw_text(c->lcd, str, nr, c->ox + x, c->oy + y);\n\n  } else {\n\n    return canvas_draw_text_impl(c, str, nr, c->ox + x, c->oy + y, FALSE);\n\n  }\n\n}",
            "key_variables": [
               [
                  1511,
                  "img->w"
               ],
               [
                  1517,
                  "img->w"
               ],
               [
                  1536,
                  "img->h"
               ],
               [
                  1542,
                  "img->h"
               ],
               [
                  1563,
                  "img->h"
               ],
               [
                  1564,
                  "img->w"
               ],
               [
                  1566,
                  "img->w"
               ],
               [
                  1567,
                  "img->h"
               ],
               [
                  1588,
                  "src->w"
               ],
               [
                  1589,
                  "src->h"
               ]
            ]
         },
         {
            "type": "func",
            "name": "canvas_draw_text_impl",
            "line_range": [
               1372,
               1456
            ],
            "source_code": "static ret_t canvas_draw_text_impl(canvas_t* c, const wchar_t* str, uint32_t nr, xy_t x, xy_t y,\n\n                                   bool_t line_breaker) {\n\n  glyph_t g;\n\n  uint32_t i = 0;\n\n  xy_t left = x;\n\n  font_vmetrics_t vmetrics = font_get_vmetrics(c->font, c->font_size);\n\n  font_size_t font_size = c->font_size;\n\n  int32_t baseline = vmetrics.ascent;\n\n  return_value_if_fail(c->font != NULL, RET_BAD_PARAMS);\n\n  for (i = 0; i < nr; i++) {\n\n    wchar_t chr = str[i];\n\n\n\n    if (chr == '\\r' || chr == '\\n') {\n\n      if ((i + 1) == nr) {\n\n        break;\n\n      }\n\n\n\n      if (chr == '\\r' && str[i + 1] == '\\n') {\n\n        i++;\n\n      }\n\n\n\n      if (line_breaker) {\n\n        y += font_size;\n\n        x = left;\n\n        continue;\n\n      } else {\n\n        chr = ' ';\n\n      }\n\n    }\n\n\n\n    if (font_get_glyph(c->font, chr, c->font_size, &g) == RET_OK) {\n\n      xy_t xx = x + g.x;\n\n      xy_t yy = y + g.y + baseline;\n\n\n\n      canvas_draw_glyph(c, &g, xx, yy);\n\n      x += g.advance + 1;\n\n    } else {\n\n      x += 4;\n\n    }\n\n  }\n\n\n\n  return RET_OK;\n\n}",
            "key_variables": [
               [
                  1593,
                  "src->w"
               ]
            ]
         },
         {
            "type": "func",
            "name": "canvas_draw_text",
            "line_range": [
               1460,
               1474
            ],
            "source_code": "ret_t canvas_draw_text(canvas_t* c, const wchar_t* str, uint32_t nr, xy_t x, xy_t y) {\n\n  return_value_if_fail(c != NULL && c->lcd != NULL && str != NULL, RET_BAD_PARAMS);\n\n  if (c->lcd->draw_text != NULL) {\n\n    return lcd_draw_text(c->lcd, str, nr, c->ox + x, c->oy + y);\n\n  } else {\n\n    return canvas_draw_text_impl(c, str, nr, c->ox + x, c->oy + y, FALSE);\n\n  }\n\n}",
            "key_variables": [
               [
                  1594,
                  "src->h"
               ]
            ]
         },
         {
            "type": "func",
            "name": "canvas_do_draw_image",
            "line_range": [
               1506,
               1590
            ],
            "source_code": "static ret_t canvas_do_draw_image(canvas_t* c, bitmap_t* img, const rect_t* s, const rect_t* d) {\n\n  rectf_t src;\n\n  rectf_t dst;\n\n  float_t scale_w = 0;\n\n  float_t scale_h = 0;\n\n\n\n  xy_t x = d->x;\n\n  xy_t y = d->y;\n\n  xy_t x2 = d->x + d->w - 1;\n\n  xy_t y2 = d->y + d->h - 1;\n\n\n\n  if (d->w <= 0 || d->h <= 0 || s->w <= 0 || s->h <= 0 || x > c->clip_right || x2 < c->clip_left ||\n\n      y > c->clip_bottom || y2 < c->clip_top) {\n\n    return RET_OK;\n\n  }\n\n\n\n  dst.x = tk_max(x, c->clip_left);\n\n  dst.y = tk_max(y, c->clip_top);\n\n  dst.w = tk_min(x2, c->clip_right) - dst.x + 1;\n\n  dst.h = tk_min(y2, c->clip_bottom) - dst.y + 1;\n\n\n\n  /* 因为 blend 函数中缩放，使用 256 倍的定点数，所以这里为了减低多次转换数据出现误差 */\n\n  scale_w = ((s->w << 8) / d->w / 256.0f);\n\n  scale_h = ((s->h << 8) / d->h / 256.0f);\n\n\n\n  src.x = s->x + (dst.x - x) * scale_w;\n\n  src.y = s->y + (dst.y - y) * scale_h;\n\n  src.w = dst.w * s->w / d->w;\n\n  src.h = dst.h * s->h / d->h;\n\n\n\n  if (src.x >= img->w || src.y >= img->h) {\n\n    return RET_OK;\n\n  }\n\n\n\n  src.w = tk_min((img->w - src.x), src.w);\n\n  src.h = tk_min((img->h - src.y), src.h);\n\n\n\n  if (src.w <= 0 || src.h <= 0 || dst.w <= 0 || dst.h <= 0) {\n\n    return RET_OK;\n\n  }\n\n\n\n  return lcd_draw_image(c->lcd, img, &src, &dst);\n\n}",
            "key_variables": [
               [
                  1723,
                  "lcd->ratio"
               ],
               [
                  1777,
                  "src_r->w"
               ],
               [
                  1785,
                  "src_r->h"
               ]
            ]
         },
         {
            "type": "func",
            "name": "canvas_draw_utf8",
            "line_range": [
               1478,
               1502
            ],
            "source_code": "ret_t canvas_draw_utf8(canvas_t* c, const char* str, xy_t x, xy_t y) {\n\n  wstr_t s;\n\n  ret_t ret = RET_FAIL;\n\n  return_value_if_fail(c != NULL && c->lcd != NULL && str != NULL, RET_BAD_PARAMS);\n\n\n\n  wstr_init(&s, 0);\n\n  return_value_if_fail(wstr_set_utf8(&s, str) == RET_OK, RET_OOM);\n\n\n\n  ret = canvas_draw_text(c, s.str, s.size, x, y);\n\n  wstr_reset(&s);\n\n\n\n  return ret;\n\n}",
            "key_variables": [
               [
                  1788,
                  "dst->x"
               ],
               [
                  1789,
                  "dst->y"
               ]
            ]
         },
         {
            "type": "func",
            "name": "canvas_draw_image",
            "line_range": [
               1594,
               1620
            ],
            "source_code": "ret_t canvas_draw_image(canvas_t* c, bitmap_t* img, const rect_t* src, const rect_t* dst_in) {\n\n  rect_t d;\n\n  rect_t r_fix = rect_init(0, 0, 0, 0);\n\n  rect_t* dst = canvas_fix_rect(dst_in, &r_fix);\n\n\n\n  return_value_if_fail(c != NULL && img != NULL && src != NULL && dst != NULL, RET_BAD_PARAMS);\n\n\n\n  d.x = c->ox + dst->x;\n\n  d.y = c->oy + dst->y;\n\n  d.w = dst->w;\n\n  d.h = dst->h;\n\n\n\n  return canvas_do_draw_image(c, img, src, &d);\n\n}",
            "key_variables": [
               [
                  1811,
                  "lcd->ratio"
               ]
            ]
         },
         {
            "type": "func",
            "name": "canvas_draw_image_repeat",
            "line_range": [
               1828,
               1854
            ],
            "source_code": "ret_t canvas_draw_image_repeat(canvas_t* c, bitmap_t* img, const rect_t* dst_in) {\n\n  rect_t s;\n\n  rect_t r_fix = rect_init(0, 0, 0, 0);\n\n  rect_t* dst = canvas_fix_rect(dst_in, &r_fix);\n\n  return_value_if_fail(c != NULL && img != NULL && dst != NULL, RET_BAD_PARAMS);\n\n\n\n  s.x = 0;\n\n  s.y = 0;\n\n  s.w = img->w;\n\n  s.h = img->h;\n\n  canvas_draw_image_repeat_impl(c, img, &s, dst_in);\n\n\n\n  return RET_OK;\n\n}",
            "key_variables": [
               [
                  1832,
                  "c->lcd"
               ],
               [
                  1836,
                  "fps[20]"
               ],
               [
                  1837,
                  "wfps[20]"
               ],
               [
                  1879,
                  "r->y"
               ],
               [
                  1891,
                  "r->x"
               ]
            ]
         }
      ],
      "src/base/children_layouter_factory.c": [
         {
            "type": "block",
            "name": "block",
            "line_range": "",
            "source_code": "",
            "key_variables": [
               37,
               "type[TK_NAME_LEN + 1]"
            ]
         }
      ],
      "src/base/data_reader_asset.c": [
         {
            "type": "func",
            "name": "data_reader_asset_get_size",
            "line_range": [
               52,
               57
            ],
            "source_code": "static uint64_t data_reader_asset_get_size(data_reader_t* reader) {\n  data_reader_asset_t* asset = (data_reader_asset_t*)reader;\n  return_value_if_fail(asset != NULL && asset->info != NULL, 0);\n\n  return asset->info->size;\n}",
            "key_variables": [
               [
                  57,
                  "info->size"
               ]
            ]
         },
         {
            "type": "func",
            "name": "data_reader_asset_destroy",
            "line_range": [
               59,
               66
            ],
            "source_code": "static ret_t data_reader_asset_destroy(data_reader_t* reader) {\n  data_reader_asset_t* asset = (data_reader_asset_t*)reader;\n\n  assets_manager_unref(assets_manager(), (asset_info_t*)(asset->info));\n  TKMEM_FREE(asset);\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  77,
                  "type[TK_NAME_LEN + 1]"
               ]
            ]
         }
      ],
      "src/base/date_time_format.c": [
         {
            "type": "func",
            "name": "translate_month",
            "line_range": [
               46,
               54
            ],
            "source_code": "static wchar_t* translate_month(wchar_t* str, uint32_t size, uint32_t month) {\n  return_value_if_fail(month < 13 && month > 0, NULL);\n\n  static const char* const months[] = {\"Jan\", \"Feb\", \"Mar\",  \"Apr\", \"May\", \"Jun\",\n                                       \"Jul\", \"Aug\", \"Sept\", \"Oct\", \"Nov\", \"Dec\"};\n\n  const char* utf8 = locale_info_tr(locale_info(), months[month - 1]);\n  return tk_utf8_to_utf16(utf8, str, size);\n}",
            "key_variables": [
               [
                  58,
                  "temp[32]"
               ]
            ]
         }
      ],
      "src/base/dialog.c": [
         {
            "type": "func",
            "name": "dialog_set_prop",
            "line_range": [
               47,
               70
            ],
            "source_code": "static ret_t dialog_set_prop(widget_t* widget, const char* name, const value_t* v) {\n  dialog_t* dialog = DIALOG(widget);\n  return_value_if_fail(dialog != NULL, RET_BAD_PARAMS);\n\n  if (tk_str_eq(name, WIDGET_PROP_HIGHLIGHT)) {\n    dialog->highlight = tk_str_copy(dialog->highlight, value_str(v));\n\n    return RET_OK;\n  } else if (tk_str_eq(name, WIDGET_PROP_SELF_LAYOUT)) {\n    self_layouter_t* self_layout = widget->self_layout;\n    if (self_layouter_default_is_valid(self_layout)) {\n      if (self_layouter_get_param_int(self_layout, \"x_attr\", 0) == X_ATTR_UNDEF) {\n        self_layouter_set_param_str(self_layout, \"x\", \"c\");\n      }\n\n      if (self_layouter_get_param_int(self_layout, \"y_attr\", 0) == Y_ATTR_UNDEF) {\n        self_layouter_set_param_str(self_layout, \"y\", \"m\");\n      }\n    }\n    return RET_OK;\n  }\n\n  return window_base_set_prop(widget, name, v);\n}",
            "key_variables": [
               [
                  57,
                  "widget->self_layout"
               ]
            ]
         },
         {
            "type": "func",
            "name": "dialog_get_title",
            "line_range": [
               131,
               136
            ],
            "source_code": "widget_t* dialog_get_title(widget_t* widget) {\n  dialog_t* dialog = DIALOG(widget);\n  return_value_if_fail(dialog != NULL, NULL);\n\n  return dialog->title;\n}",
            "key_variables": [
               [
                  136,
                  "dialog->title"
               ],
               [
                  143,
                  "dialog->client"
               ]
            ]
         },
         {
            "type": "func",
            "name": "is_dialog_opened",
            "line_range": [
               167,
               180
            ],
            "source_code": "static bool_t is_dialog_opened(widget_t* widget) {\n  int32_t stage = widget_get_prop_int(widget, WIDGET_PROP_STAGE, WINDOW_STAGE_NONE);\n\n  if (stage == WINDOW_STAGE_OPENED) return TRUE;\n  if (stage != WINDOW_STAGE_SUSPEND || widget->parent == NULL) return FALSE;\n\n  WIDGET_FOR_EACH_CHILD_BEGIN_R(widget->parent, iter, i)\n  if (iter == widget) break;\n  if (!tk_str_eq(iter->vt->type, WIDGET_TYPE_DIALOG)) continue;\n  dialog_t* dialog = DIALOG(iter);\n  if (dialog == NULL || !dialog->quited) return FALSE;\n  WIDGET_FOR_EACH_CHILD_END()\n  return TRUE;\n}",
            "key_variables": [
               [
                  204,
                  "dialog->quited"
               ]
            ]
         },
         {
            "type": "func",
            "name": "dialog_quit",
            "line_range": [
               182,
               197
            ],
            "source_code": "ret_t dialog_quit(widget_t* widget, uint32_t code) {\n#ifdef AWTK_WEB\n  log_debug(\"awtk web not support dialog_modal\\n\");\n  dialog_close(widget);\n#else\n  dialog_t* dialog = DIALOG(widget);\n  return_value_if_fail(dialog != NULL && !(dialog->quited), RET_BAD_PARAMS);\n  return_value_if_fail(is_dialog_opened(widget), RET_BAD_PARAMS);\n\n  dialog->quited = TRUE;\n  dialog->quit_code = (dialog_quit_code_t)code;\n  main_loop_quit(main_loop());\n#endif /*AWTK_WEB*/\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  211,
                  "dialog->is_model"
               ]
            ]
         }
      ],
      "src/base/dialog_highlighter_factory.c": [
         {
            "type": "block",
            "name": "block",
            "line_range": "",
            "source_code": "",
            "key_variables": [
               37,
               "type[TK_NAME_LEN + 1]"
            ]
         }
      ],
      "src/base/enums.c": [
         {
            "type": "func",
            "name": "easing_type_find",
            "line_range": [
               389,
               391
            ],
            "source_code": "const key_type_value_t* easing_type_find(const char* name) {\n  return find_item(easing_type_name_value, ARRAY_SIZE(easing_type_name_value), name);\n}",
            "key_variables": [
               [
                  399,
                  "fixed_name[TK_NAME_LEN + 1]"
               ]
            ]
         }
      ],
      "src/base/events.c": [
         {
            "type": "func",
            "name": "window_event_cast",
            "line_range": [
               77,
               85
            ],
            "source_code": "window_event_t* window_event_cast(event_t* event) {\n  return_value_if_fail(event != NULL, NULL);\n  return_value_if_fail(event->type == EVT_WINDOW_WILL_OPEN || event->type == EVT_WINDOW_OPEN ||\n                           event->type == EVT_WINDOW_CLOSE,\n                       NULL);\n  return_value_if_fail(event->size == sizeof(window_event_t), NULL);\n\n  return (window_event_t*)event;\n}",
            "key_variables": [
               [
                  89,
                  "evt->x"
               ],
               [
                  90,
                  "evt->y"
               ]
            ]
         }
      ],
      "src/base/event_recorder_player.c": [
         {
            "type": "func",
            "name": "event_recorder_player_play",
            "line_range": [
               57,
               115
            ],
            "source_code": "static ret_t event_recorder_player_play(event_recorder_player_t* p) {\n  log_event_t event;\n  event_t* e = NULL;\n  int64_t duration = 0;\n\n  if (p->fp == NULL) {\n    return RET_REMOVE;\n  }\n\n  if (p->last_event_time > 0) {\n    event_queue_req_t req;\n    memset(&req, 0x00, sizeof(req));\n    e = (event_t*)&(p->pending_event);\n    memcpy(&req, e, sizeof(p->pending_event));\n    main_loop_queue_event(main_loop(), &req);\n  } else {\n    log_debug(\"prepare first event\\n\");\n  }\n\n  e = (event_t*)&event;\n  memset(&event, 0x00, sizeof(event));\n  if (!fs_file_eof(p->fp) && fs_file_read(p->fp, &event, sizeof(event)) == sizeof(event)) {\n    if (p->last_event_time == 0) {\n      p->last_event_time = e->time;\n    }\n\n    memcpy(&(p->pending_event), &event, sizeof(event));\n    duration = e->time - p->last_event_time;\n    p->last_event_time = e->time;\n\n    if (duration < 0) {\n      duration = 0;\n    }\n\n    if (duration > 100 * 1000) {\n      duration = 100;\n    }\n\n    timer_modify(p->timer_id, duration);\n\n    return RET_REPEAT;\n  } else {\n    p->times--;\n    if (p->times > 0) {\n      fs_file_seek(p->fp, 0);\n      p->last_event_time = 0;\n      log_debug(\"play event remain times: %d\\n\", p->times);\n\n      return RET_REPEAT;\n    } else {\n      p->playing = FALSE;\n      fs_file_close(p->fp);\n      p->fp = NULL;\n\n      log_debug(\"play event done\\n\");\n      return RET_REMOVE;\n    }\n  }\n}",
            "key_variables": [
               [
                  81,
                  "e->time"
               ],
               [
                  85,
                  "p->last_event_time"
               ],
               [
                  86,
                  "e->time"
               ]
            ]
         }
      ],
      "src/base/font_manager.c": [
         {
            "type": "func",
            "name": "font_manager_init",
            "line_range": [
               58,
               66
            ],
            "source_code": "font_manager_t* font_manager_init(font_manager_t* fm, font_loader_t* loader) {\n  return_value_if_fail(fm != NULL, NULL);\n  darray_init(&(fm->fonts), 2, (tk_destroy_t)font_destroy, (tk_compare_t)font_cmp);\n\n  fm->loader = loader;\n  fm->assets_manager = NULL;\n\n  return fm;\n}",
            "key_variables": [
               [
                  74,
                  "evt->asset_info"
               ]
            ]
         },
         {
            "type": "func",
            "name": "font_manager_fix_bitmap_font_name",
            "line_range": [
               108,
               113
            ],
            "source_code": "static const char* font_manager_fix_bitmap_font_name(char str[MAX_PATH], const char* name,\n                                                     font_size_t size) {\n  memset(str, 0, MAX_PATH);\n  tk_snprintf(str, MAX_PATH, \"%s_%d\", name, size);\n  return str;\n}",
            "key_variables": [
               [
                  120,
                  "font_name[MAX_PATH]"
               ]
            ]
         },
         {
            "type": "func",
            "name": "font_manager_lookup",
            "line_range": [
               116,
               136
            ],
            "source_code": "font_t* font_manager_lookup(font_manager_t* fm, const char* name, font_size_t size) {\n#if WITH_BITMAP_FONT\n  font_t* font = NULL;\n  char font_name[MAX_PATH];\n  font_cmp_info_t info_bitmap;\n#endif\n\n  font_cmp_info_t info = {name, size};\n  return_value_if_fail(fm != NULL, NULL);\n\n#if WITH_BITMAP_FONT\n  info_bitmap.name = font_manager_fix_bitmap_font_name(font_name, name, size);\n  info_bitmap.size = size;\n  font = darray_find(&(fm->fonts), &info_bitmap);\n  if (font != NULL) {\n    return font;\n  }\n#endif\n\n  return darray_find(&(fm->fonts), &info);\n}",
            "key_variables": [
               [
                  145,
                  "font_name[MAX_PATH]"
               ]
            ]
         },
         {
            "type": "func",
            "name": "font_manager_load",
            "line_range": [
               138,
               165
            ],
            "source_code": "font_t* font_manager_load(font_manager_t* fm, const char* name, uint32_t size) {\n  font_t* font = NULL;\n  if (fm->loader != NULL) {\n    const asset_info_t* info = NULL;\n\n#if WITH_BITMAP_FONT\n    char font_name[MAX_PATH];\n    font_manager_fix_bitmap_font_name(font_name, name, size);\n    info = assets_manager_ref(fm->assets_manager, ASSET_TYPE_FONT, font_name);\n    if (info != NULL) {\n      name = font_name;\n    }\n#endif\n\n    if (info == NULL) {\n      info = assets_manager_ref(fm->assets_manager, ASSET_TYPE_FONT, name);\n    }\n\n    if (info != NULL) {\n      if (info->subtype == fm->loader->type) {\n        font = font_loader_load(fm->loader, name, info->data, info->size);\n      }\n      assets_manager_unref(fm->assets_manager, info);\n    }\n  }\n\n  return font;\n}",
            "key_variables": [
               [
                  192,
                  "font_name[MAX_PATH]"
               ]
            ]
         }
      ],
      "src/base/glyph_cache.c": [
         {
            "type": "func",
            "name": "glyph_cache_get_empty",
            "line_range": [
               47,
               76
            ],
            "source_code": "static glyph_cache_item_t* glyph_cache_get_empty(glyph_cache_t* cache) {\n  uint32_t i = 0;\n  uint32_t nr = 0;\n  uint32_t oldest = 0;\n  glyph_cache_item_t* item = NULL;\n  uint32_t oldest_time = 0xffffffff;\n\n  return_value_if_fail(cache != NULL && cache->items != NULL, NULL);\n\n  if (cache->size < cache->capacity) {\n    oldest = cache->size++;\n    return cache->items + oldest;\n  }\n\n  for (i = 0, nr = cache->size; i < nr; i++) {\n    glyph_cache_item_t* item = cache->items + i;\n    if (item->last_access_time < oldest_time) {\n      oldest_time = item->last_access_time;\n      oldest = i;\n      if (oldest_time == 0) {\n        break;\n      }\n    }\n  }\n\n  item = cache->items + oldest;\n  GLYPH_CACHE_FREE_ITEM(cache, item);\n\n  return item;\n}",
            "key_variables": [
               [
                  62,
                  "cache->size"
               ],
               [
                  65,
                  "item->last_access_time"
               ]
            ]
         },
         {
            "type": "func",
            "name": "glyph_cache_lookup",
            "line_range": [
               90,
               106
            ],
            "source_code": "ret_t glyph_cache_lookup(glyph_cache_t* cache, wchar_t code, font_size_t size, glyph_t* g) {\n  uint32_t i = 0;\n  uint32_t nr = 0;\n\n  return_value_if_fail(cache != NULL && g != NULL, RET_BAD_PARAMS);\n  for (i = 0, nr = cache->size; i < nr; i++) {\n    glyph_cache_item_t* item = cache->items + i;\n    if (item->code == code && item->size == size) {\n      *g = *(item->g);\n      item->last_access_time = time_now_ms();\n\n      return RET_OK;\n    }\n  }\n\n  return RET_NOT_FOUND;\n}",
            "key_variables": [
               [
                  96,
                  "cache->size"
               ],
               [
                  116,
                  "cache->size"
               ]
            ]
         },
         {
            "type": "func",
            "name": "glyph_cache_deinit",
            "line_range": [
               108,
               126
            ],
            "source_code": "ret_t glyph_cache_deinit(glyph_cache_t* cache) {\n  uint32_t i = 0;\n  uint32_t nr = 0;\n\n  return_value_if_fail(cache != NULL, RET_BAD_PARAMS);\n\n  if (cache->destroy_glyph != NULL) {\n    for (i = 0, nr = cache->size; i < nr; i++) {\n      glyph_cache_item_t* item = cache->items + i;\n\n      GLYPH_CACHE_FREE_ITEM(cache, item);\n    }\n  }\n\n  TKMEM_FREE(cache->items);\n  memset(cache, 0x00, sizeof(glyph_cache_t));\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  133,
                  "aa->last_access_time"
               ],
               [
                  143,
                  "cache->size"
               ]
            ]
         }
      ],
      "src/base/hscrollable.c": [
         {
            "type": "func",
            "name": "hscrollable_on_pointer_down",
            "line_range": [
               35,
               46
            ],
            "source_code": "static ret_t hscrollable_on_pointer_down(hscrollable_t* hscrollable, pointer_event_t* e) {\n  velocity_t* v = &(hscrollable->velocity);\n\n  velocity_reset(v);\n  hscrollable->down.x = e->x;\n  hscrollable->down.y = e->y;\n  hscrollable->xoffset_save = hscrollable->xoffset;\n\n  velocity_update(v, e->e.time, e->x, e->y);\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  40,
                  "e->x"
               ],
               [
                  41,
                  "e->y"
               ],
               [
                  42,
                  "hscrollable->xoffset"
               ]
            ]
         },
         {
            "type": "func",
            "name": "hscrollable_on_pointer_move",
            "line_range": [
               48,
               67
            ],
            "source_code": "static ret_t hscrollable_on_pointer_move(hscrollable_t* hscrollable, pointer_event_t* e) {\n  velocity_t* v = &(hscrollable->velocity);\n  int32_t dx = e->x - hscrollable->down.x;\n\n  velocity_update(v, e->e.time, e->x, e->y);\n\n  hscrollable->xoffset = hscrollable->xoffset_save - dx;\n\n  if (!(hscrollable->always_scrollable)) {\n    widget_t* widget = hscrollable_get_widget(hscrollable);\n    if ((hscrollable->xoffset + widget->w) > hscrollable->virtual_w) {\n      hscrollable->xoffset = hscrollable->virtual_w - widget->w;\n    }\n    if (hscrollable->xoffset < 0) {\n      hscrollable->xoffset = 0;\n    }\n  }\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  60,
                  "widget->w"
               ]
            ]
         },
         {
            "type": "func",
            "name": "hscrollable_fix_end_offset_default",
            "line_range": [
               81,
               97
            ],
            "source_code": "static ret_t hscrollable_fix_end_offset_default(hscrollable_t* hscrollable) {\n  int32_t xoffset_end = 0;\n  widget_t* widget = hscrollable_get_widget(hscrollable);\n  return_value_if_fail(hscrollable != NULL && widget != NULL, RET_BAD_PARAMS);\n\n  xoffset_end = hscrollable->xoffset_end;\n  xoffset_end = tk_max(xoffset_end, 0);\n  xoffset_end = tk_min(xoffset_end, (hscrollable->virtual_w - widget->w));\n\n  if (hscrollable->virtual_w <= widget->w) {\n    xoffset_end = 0;\n  }\n\n  hscrollable->xoffset_end = xoffset_end;\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  87,
                  "hscrollable->xoffset_end"
               ],
               [
                  106,
                  "hscrollable->xoffset_end"
               ],
               [
                  107,
                  "hscrollable->xoffset"
               ],
               [
                  114,
                  "hscrollable->xoffset_end"
               ]
            ]
         },
         {
            "type": "func",
            "name": "hscrollable_scroll_to",
            "line_range": [
               99,
               126
            ],
            "source_code": "ret_t hscrollable_scroll_to(hscrollable_t* hscrollable, int32_t xoffset_end, int32_t duration) {\n  int32_t xoffset = 0;\n  widget_t* widget = hscrollable_get_widget(hscrollable);\n  return_value_if_fail(hscrollable != NULL && widget != NULL, RET_FAIL);\n\n  hscrollable_fix_end_offset_default(hscrollable);\n  xoffset_end = hscrollable->xoffset_end;\n  xoffset = hscrollable->xoffset;\n  if (xoffset == xoffset_end) {\n    return RET_OK;\n  }\n\n#ifndef WITHOUT_WIDGET_ANIMATORS\n  hscrollable->xoffset_end = xoffset_end;\n  xoffset_end = hscrollable->xoffset_end;\n\n  hscrollable->wa = widget_animator_scroll_create(widget, TK_ANIMATING_TIME, 0, EASING_SIN_INOUT);\n  return_value_if_fail(hscrollable->wa != NULL, RET_OOM);\n\n  widget_animator_scroll_set_params(hscrollable->wa, xoffset, 0, xoffset_end, 0);\n  widget_animator_on(hscrollable->wa, EVT_ANIM_END, hscrollable_on_scroll_done, hscrollable);\n  widget_animator_start(hscrollable->wa);\n#else\n  hscrollable->xoffset = xoffset_end;\n#endif /*WITHOUT_WIDGET_ANIMATORS*/\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  149,
                  "e->type"
               ]
            ]
         },
         {
            "type": "func",
            "name": "hscrollable_on_paint_children",
            "line_range": [
               206,
               237
            ],
            "source_code": "ret_t hscrollable_on_paint_children(hscrollable_t* hscrollable, canvas_t* c) {\n  rect_t r_save;\n  widget_t* widget = hscrollable_get_widget(hscrollable);\n  vgcanvas_t* vg = canvas_get_vgcanvas(c);\n  return_value_if_fail(hscrollable != NULL && c != NULL && widget != NULL, RET_BAD_PARAMS);\n\n  rect_t r = rect_init(c->ox, c->oy, widget->w, widget->h);\n\n  int32_t xoffset = -hscrollable->xoffset;\n\n  canvas_translate(c, xoffset, 0);\n  canvas_get_clip_rect(c, &r_save);\n\n  r = rect_intersect(&r, &r_save);\n\n  if (vg != NULL) {\n    vgcanvas_save(vg);\n    vgcanvas_clip_rect(vg, (float_t)r.x, (float_t)r.y, (float_t)r.w, (float_t)r.h);\n  }\n\n  canvas_set_clip_rect(c, &r);\n  widget_on_paint_children_default(widget, c);\n  canvas_set_clip_rect(c, &r_save);\n  canvas_untranslate(c, xoffset, 0);\n\n  if (vg != NULL) {\n    vgcanvas_clip_rect(vg, (float_t)r_save.x, (float_t)r_save.y, (float_t)r_save.w,\n                       (float_t)r_save.h);\n    vgcanvas_restore(vg);\n  }\n  return RET_OK;\n}",
            "key_variables": [
               [
                  215,
                  "hscrollable->xoffset"
               ]
            ]
         }
      ],
      "src/base/image_base.c": [
         {
            "type": "func",
            "name": "image_base_on_event",
            "line_range": [
               25,
               78
            ],
            "source_code": "ret_t image_base_on_event(widget_t* widget, event_t* e) {\n  uint16_t type = e->type;\n  image_base_t* image = IMAGE_BASE(widget);\n  return_value_if_fail(image != NULL, RET_BAD_PARAMS);\n\n  switch (type) {\n    case EVT_POINTER_DOWN:\n      image->pressed = TRUE;\n      widget_grab(widget->parent, widget);\n\n      if (image->clickable) {\n        widget_set_state(widget, WIDGET_STATE_PRESSED);\n        widget_invalidate(widget, NULL);\n      }\n      break;\n    case EVT_POINTER_UP: {\n      if (image->pressed) {\n        if (image->clickable || image->selectable) {\n          pointer_event_t evt;\n          widget_dispatch(widget, pointer_event_init(&evt, EVT_CLICK, widget, 0, 0));\n        }\n\n        if (!image->selectable) {\n          widget_set_state(widget, WIDGET_STATE_NORMAL);\n        }\n        widget_ungrab(widget->parent, widget);\n      }\n      break;\n    }\n    case EVT_CLICK: {\n      if (image->selectable) {\n        image->selected = !image->selected;\n        widget_set_state(widget, image->selected ? WIDGET_STATE_SELECTED : WIDGET_STATE_NORMAL);\n      }\n      widget_invalidate(widget, NULL);\n      break;\n    }\n    case EVT_POINTER_DOWN_ABORT: {\n      image->pressed = FALSE;\n      widget_ungrab(widget->parent, widget);\n\n      if (image->selectable) {\n        widget_set_state(widget, image->selected ? WIDGET_STATE_SELECTED : WIDGET_STATE_NORMAL);\n      } else {\n        widget_set_state(widget, WIDGET_STATE_NORMAL);\n      }\n      break;\n    }\n    default:\n      break;\n  }\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  27,
                  "e->type"
               ],
               [
                  57,
                  "image->selected"
               ]
            ]
         },
         {
            "type": "func",
            "name": "image_base_cast",
            "line_range": [
               245,
               249
            ],
            "source_code": "widget_t* image_base_cast(widget_t* widget) {\n  return_value_if_fail(WIDGET_IS_INSTANCE_OF(widget, image_base), NULL);\n\n  return widget;\n}",
            "key_variables": [
               [
                  268,
                  "widget->w"
               ],
               [
                  269,
                  "widget->h"
               ],
               [
                  285,
                  "image_other->anchor_x"
               ],
               [
                  286,
                  "image_other->anchor_y"
               ],
               [
                  287,
                  "image_other->scale_x"
               ],
               [
                  288,
                  "image_other->scale_y"
               ],
               [
                  289,
                  "image_other->rotation"
               ],
               [
                  290,
                  "image_other->clickable"
               ],
               [
                  291,
                  "image_other->selectable"
               ],
               [
                  292,
                  "image_other->selected"
               ]
            ]
         }
      ],
      "src/base/image_loader.c": [
         {
            "type": "block",
            "name": "block",
            "line_range": "",
            "source_code": "",
            "key_variables": [
               32,
               "s_image_loaders[MAX_IMAGE_LOADERS]"
            ]
         },
         {
            "type": "func",
            "name": "image_loader_unregister",
            "line_range": [
               47,
               59
            ],
            "source_code": "ret_t image_loader_unregister(image_loader_t* loader) {\n  uint32_t i = 0;\n  return_value_if_fail(loader != NULL, RET_BAD_PARAMS);\n  for (i = 0; i < ARRAY_SIZE(s_image_loaders); i++) {\n    if (s_image_loaders[i] == loader) {\n      s_image_loaders[i] = NULL;\n\n      return RET_OK;\n    }\n  }\n\n  return RET_NOT_FOUND;\n}",
            "key_variables": [
               [
                  67,
                  "s_image_loaders[i]"
               ]
            ]
         }
      ],
      "src/base/image_manager.c": [
         {
            "type": "func",
            "name": "bitmap_cache_cmp_access_time_dec",
            "line_range": [
               47,
               49
            ],
            "source_code": "static int bitmap_cache_cmp_access_time_dec(bitmap_cache_t* a, bitmap_cache_t* b) {\n  return (b->last_access_time) - (a->last_access_time);\n}",
            "key_variables": [
               [
                  55,
                  "image->image_manager"
               ]
            ]
         },
         {
            "type": "func",
            "name": "image_manager_create",
            "line_range": [
               78,
               83
            ],
            "source_code": "image_manager_t* image_manager_create(void) {\n  image_manager_t* imm = TKMEM_ZALLOC(image_manager_t);\n  return_value_if_fail(imm != NULL, NULL);\n\n  return image_manager_init(imm);\n}",
            "key_variables": [
               [
                  91,
                  "assets_manager->locale_info"
               ]
            ]
         },
         {
            "type": "func",
            "name": "image_manager_init",
            "line_range": [
               96,
               103
            ],
            "source_code": "image_manager_t* image_manager_init(image_manager_t* imm) {\n  return_value_if_fail(imm != NULL, NULL);\n\n  darray_init(&(imm->images), 0, (tk_destroy_t)bitmap_cache_destroy, NULL);\n  imm->assets_manager = assets_manager();\n\n  return imm;\n}",
            "key_variables": [
               [
                  138,
                  "cache->name"
               ],
               [
                  139,
                  "cache->created_time"
               ]
            ]
         },
         {
            "type": "func",
            "name": "image_manager_clear_cache",
            "line_range": [
               105,
               123
            ],
            "source_code": "static ret_t image_manager_clear_cache(image_manager_t* imm) {\n  bitmap_cache_t* iter = NULL;\n  return_value_if_fail(imm != NULL, RET_BAD_PARAMS);\n  if (imm->images.size == 0 || imm->max_mem_size_of_cached_images == 0 ||\n      imm->mem_size_of_cached_images < imm->max_mem_size_of_cached_images) {\n    return RET_OK;\n  }\n\n  darray_sort(&(imm->images), (tk_compare_t)bitmap_cache_cmp_access_time_dec);\n  do {\n    iter = (bitmap_cache_t*)darray_pop(&(imm->images));\n    bitmap_cache_destroy(iter);\n    log_debug(\"clear cache: mem_size_of_cached_images=%u nr=%u\", imm->mem_size_of_cached_images,\n              imm->images.size);\n  } while (imm->images.size > 0 &&\n           imm->mem_size_of_cached_images > imm->max_mem_size_of_cached_images);\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  162,
                  "iter->image"
               ]
            ]
         },
         {
            "type": "func",
            "name": "image_manager_update_specific",
            "line_range": [
               176,
               204
            ],
            "source_code": "ret_t image_manager_update_specific(image_manager_t* imm, bitmap_t* image) {\n  bitmap_cache_t info;\n  bitmap_cache_t* iter = NULL;\n  return_value_if_fail(image != NULL, RET_BAD_PARAMS);\n\n  if (imm == NULL) {\n    return RET_FAIL;\n  }\n\n  if (image->image_manager != NULL) {\n    imm = image->image_manager;\n  }\n\n  info.image.buffer = image->buffer;\n  imm->images.compare = (tk_compare_t)bitmap_cache_cmp_data;\n  iter = darray_find(&(imm->images), &info);\n\n  if (iter != NULL) {\n    iter->image.flags = image->flags;\n    iter->image.specific = image->specific;\n    iter->image.specific_ctx = image->specific_ctx;\n    iter->image.specific_destroy = image->specific_destroy;\n\n    image->specific_destroy = NULL;\n    return RET_OK;\n  }\n\n  return RET_NOT_FOUND;\n}",
            "key_variables": [
               [
                  187,
                  "image->image_manager"
               ],
               [
                  190,
                  "image->buffer"
               ],
               [
                  195,
                  "image->flags"
               ],
               [
                  196,
                  "image->specific"
               ],
               [
                  197,
                  "image->specific_ctx"
               ],
               [
                  198,
                  "image->specific_destroy"
               ],
               [
                  224,
                  "res->data"
               ],
               [
                  226,
                  "header->w"
               ],
               [
                  227,
                  "header->h"
               ],
               [
                  228,
                  "header->flags"
               ],
               [
                  229,
                  "header->format"
               ],
               [
                  230,
                  "res->name"
               ]
            ]
         },
         {
            "type": "func",
            "name": "image_manager_get_bitmap_exprs",
            "line_range": [
               264,
               268
            ],
            "source_code": "ret_t image_manager_get_bitmap_exprs(image_manager_t* imm, const char* exprs, bitmap_t* image) {\n  imm_expr_info_t ctx = {imm, image};\n\n  return system_info_eval_exprs(system_info(), exprs, image_manager_on_expr_result, &ctx);\n}",
            "key_variables": [
               [
                  276,
                  "locale[TK_NAME_LEN + 1]"
               ],
               [
                  277,
                  "real_name[TK_NAME_LEN + 1]"
               ],
               [
                  278,
                  "locale_info->language"
               ],
               [
                  279,
                  "locale_info->country"
               ]
            ]
         },
         {
            "type": "func",
            "name": "image_manager_unload_unused",
            "line_range": [
               321,
               328
            ],
            "source_code": "ret_t image_manager_unload_unused(image_manager_t* imm, uint32_t time_delta_s) {\n  bitmap_cache_t b;\n  b.last_access_time = time_now_s() - time_delta_s;\n  return_value_if_fail(imm != NULL, RET_BAD_PARAMS);\n\n  imm->images.compare = (tk_compare_t)bitmap_cache_cmp_time;\n  return darray_remove_all(&(imm->images), NULL, &b);\n}",
            "key_variables": [
               [
                  341,
                  "image->buffer"
               ]
            ]
         }
      ],
      "src/base/input_device_status.c": [
         {
            "type": "func",
            "name": "input_device_status_find_press_info",
            "line_range": [
               74,
               96
            ],
            "source_code": "static key_pressed_info_t* input_device_status_find_press_info(input_device_status_t* ids,\n\n                                                               uint32_t key) {\n\n  uint32_t i = 0;\n\n  for (i = 0; i < MAX_PRESSED_KEYS_NR; i++) {\n\n    key_pressed_info_t* iter = ids->pressed_info + i;\n\n    if (iter->key == key) {\n\n      return iter;\n\n    }\n\n  }\n\n\n\n  return NULL;\n\n}",
            "key_variables": [
               [
                  81,
                  "ids->widget"
               ],
               [
                  86,
                  "iter->time"
               ]
            ]
         },
         {
            "type": "func",
            "name": "input_device_status_dispatch_long_press",
            "line_range": [
               152,
               206
            ],
            "source_code": "static ret_t input_device_status_dispatch_long_press(input_device_status_t* ids) {\n\n  uint32_t i = 0;\n\n  key_event_t evt;\n\n  uint64_t now = time_now_ms();\n\n  widget_t* widget = ids->widget;\n\n\n\n  for (i = 0; i < MAX_PRESSED_KEYS_NR; i++) {\n\n    key_pressed_info_t* iter = ids->pressed_info + i;\n\n    if (iter->key && !iter->emitted && !iter->should_abort) {\n\n      uint64_t t = now - iter->time;\n\n      if (t >= TK_KEY_LONG_PRESS_TIME) {\n\n        window_manager_t* wm = WINDOW_MANAGER(window_manager());\n\n        event_t* e = key_event_init(&evt, EVT_KEY_LONG_PRESS, wm->global_emitter, iter->key);\n\n\n\n        input_device_status_init_key_event(ids, &evt);\n\n        if (emitter_dispatch(wm->global_emitter, e) != RET_STOP) {\n\n          e->target = widget;\n\n          widget_on_keydown(widget, &evt);\n\n        }\n\n\n\n        log_debug(\"long press:%d\\n\", iter->key);\n\n        iter->emitted = TRUE;\n\n      }\n\n    }\n\n  }\n\n\n\n  return RET_OK;\n\n}",
            "key_variables": [
               [
                  225,
                  "ids->alt"
               ],
               [
                  226,
                  "ids->ctrl"
               ],
               [
                  227,
                  "ids->shift"
               ],
               [
                  228,
                  "ids->cmd"
               ],
               [
                  229,
                  "ids->menu"
               ],
               [
                  236,
                  "ids->alt"
               ],
               [
                  237,
                  "ids->ctrl"
               ],
               [
                  238,
                  "ids->shift"
               ],
               [
                  245,
                  "ids->alt"
               ],
               [
                  246,
                  "ids->ctrl"
               ],
               [
                  247,
                  "ids->shift"
               ],
               [
                  248,
                  "ids->lalt"
               ],
               [
                  249,
                  "ids->lctrl"
               ],
               [
                  250,
                  "ids->lshift"
               ],
               [
                  251,
                  "ids->ralt"
               ],
               [
                  252,
                  "ids->rctrl"
               ],
               [
                  253,
                  "ids->rshift"
               ],
               [
                  254,
                  "ids->capslock"
               ],
               [
                  255,
                  "ids->cmd"
               ],
               [
                  256,
                  "ids->menu"
               ],
               [
                  272,
                  "evt->x"
               ],
               [
                  273,
                  "evt->y"
               ]
            ]
         },
         {
            "type": "func",
            "name": "input_device_status_update_key_status",
            "line_range": [
               284,
               352
            ],
            "source_code": "static ret_t input_device_status_update_key_status(input_device_status_t* ids, uint32_t key,\n\n                                                   bool_t down) {\n\n  if (key == TK_KEY_LSHIFT) {\n\n    ids->shift = down;\n\n    ids->lshift = down;\n\n  } else if (key == TK_KEY_RSHIFT) {\n\n    ids->shift = down;\n\n    ids->rshift = down;\n\n  } else if (key == TK_KEY_LALT) {\n\n    ids->alt = down;\n\n    ids->lalt = down;\n\n  } else if (key == TK_KEY_RALT) {\n\n    ids->alt = down;\n\n    ids->ralt = down;\n\n  } else if (key == TK_KEY_LCTRL) {\n\n    ids->ctrl = down;\n\n    ids->lctrl = down;\n\n  } else if (key == TK_KEY_RCTRL) {\n\n    ids->ctrl = down;\n\n    ids->rctrl = down;\n\n  } else if (key == TK_KEY_MENU) {\n\n    ids->menu = down;\n\n  } else if (key == TK_KEY_LCOMMAND || key == TK_KEY_RCOMMAND) {\n\n    ids->cmd = down;\n\n  }\n\n\n\n  if (!down) {\n\n    if (key == TK_KEY_CAPSLOCK) {\n\n      ids->capslock = !(ids->capslock);\n\n    }\n\n  }\n\n  input_device_status_update_key_press_info(ids, key, down);\n\n\n\n  return RET_OK;\n\n}",
            "key_variables": [
               [
                  285,
                  "evt->x"
               ],
               [
                  286,
                  "evt->y"
               ],
               [
                  300,
                  "evt->x"
               ],
               [
                  301,
                  "evt->y"
               ]
            ]
         }
      ],
      "src/base/input_method.c": [
         {
            "type": "func",
            "name": "input_method_dispatch_preedit_abort",
            "line_range": [
               44,
               48
            ],
            "source_code": "ret_t input_method_dispatch_preedit_abort(input_method_t* im) {\n  event_t e = event_init(EVT_IM_PREEDIT_ABORT, im);\n\n  return input_method_dispatch_to_widget(im, &e);\n}",
            "key_variables": [
               [
                  54,
                  "im->widget"
               ]
            ]
         },
         {
            "type": "func",
            "name": "input_method_set",
            "line_range": [
               94,
               98
            ],
            "source_code": "ret_t input_method_set(input_method_t* im) {\n  s_input_method = im;\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  122,
                  "text[64]"
               ]
            ]
         },
         {
            "type": "func",
            "name": "input_method_commit_text",
            "line_range": [
               222,
               224
            ],
            "source_code": "ret_t input_method_commit_text(input_method_t* im, const char* text) {\n  return input_method_commit_text_ex(im, FALSE, text);\n}",
            "key_variables": [
               [
                  249,
                  "im->is_native"
               ]
            ]
         }
      ],
      "src/base/layout.c": [
         {
            "type": "func",
            "name": "widget_auto_adjust_size",
            "line_range": [
               27,
               61
            ],
            "source_code": "ret_t widget_auto_adjust_size(widget_t* widget) {\n  int32_t w = 0;\n  int32_t h = 0;\n  int32_t right = 0;\n  int32_t bottom = 0;\n  int32_t margin = 0;\n  int32_t margin_right = 0;\n  int32_t margin_bottom = 0;\n  style_t* style = NULL;\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  style = widget->astyle;\n  if (style != NULL) {\n    margin = style_get_int(style, STYLE_ID_MARGIN, 2);\n    margin_right = style_get_int(style, STYLE_ID_MARGIN_RIGHT, margin);\n    margin_bottom = style_get_int(style, STYLE_ID_MARGIN_BOTTOM, margin);\n  }\n\n  WIDGET_FOR_EACH_CHILD_BEGIN(widget, iter, i)\n  right = iter->x + iter->w + margin_right;\n  bottom = iter->y + iter->h + margin_bottom;\n  if (right > w) {\n    w = right;\n  }\n  if (bottom > h) {\n    h = bottom;\n  }\n  WIDGET_FOR_EACH_CHILD_END();\n\n  if (w != 0 && h != 0) {\n    widget_resize(widget, w, h);\n  }\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  39,
                  "widget->astyle"
               ]
            ]
         },
         {
            "type": "func",
            "name": "widget_layout_self",
            "line_range": [
               74,
               94
            ],
            "source_code": "ret_t widget_layout_self(widget_t* widget) {\n  value_t v;\n  rect_t r = {0, 0, 0, 0};\n  widget_t* parent = NULL;\n  return_value_if_fail(widget != NULL && widget->parent != NULL, RET_BAD_PARAMS);\n\n  parent = widget->parent;\n  if (widget_get_prop(parent, WIDGET_PROP_LAYOUT_W, &v) == RET_OK) {\n    r.w = value_int(&v);\n  } else {\n    r.w = parent->w;\n  }\n\n  if (widget_get_prop(parent, WIDGET_PROP_LAYOUT_H, &v) == RET_OK) {\n    r.h = value_int(&v);\n  } else {\n    r.h = parent->h;\n  }\n\n  return self_layouter_layout(widget->self_layout, widget, &r);\n}",
            "key_variables": [
               [
                  81,
                  "widget->parent"
               ],
               [
                  85,
                  "parent->w"
               ],
               [
                  91,
                  "parent->h"
               ]
            ]
         },
         {
            "type": "func",
            "name": "widget_set_children_layout",
            "line_range": [
               140,
               156
            ],
            "source_code": "ret_t widget_set_children_layout(widget_t* widget, const char* params) {\n  return_value_if_fail(widget != NULL && params != NULL, RET_BAD_PARAMS);\n  if (widget->children_layout != NULL) {\n    if (tk_str_eq(widget->children_layout->params.str, params)) {\n      return RET_OK;\n    }\n    children_layouter_destroy(widget->children_layout);\n  }\n\n  widget->children_layout = children_layouter_create(params);\n\n  if (widget->children_layout != NULL) {\n    str_set(&(widget->children_layout->params), params);\n  }\n\n  return widget_set_need_relayout(widget);\n}",
            "key_variables": [
               [
                  161,
                  "params[128]"
               ]
            ]
         },
         {
            "type": "func",
            "name": "widget_set_self_layout_params",
            "line_range": [
               158,
               164
            ],
            "source_code": "ret_t widget_set_self_layout_params(widget_t* widget, const char* x, const char* y, const char* w,\n                                    const char* h) {\n  char params[128];\n  tk_snprintf(params, sizeof(params) - 1, \"default(x=%s, y=%s, w=%s, h=%s)\", x, y, w, h);\n\n  return widget_set_self_layout(widget, params);\n}",
            "key_variables": [
               [
                  172,
                  "children->size"
               ],
               [
                  176,
                  "children[i]"
               ],
               [
                  193,
                  "children->size"
               ],
               [
                  197,
                  "children[i]"
               ]
            ]
         }
      ],
      "src/base/lcd.c": [
         {
            "type": "func",
            "name": "lcd_begin_frame",
            "line_range": [
               28,
               45
            ],
            "source_code": "ret_t lcd_begin_frame(lcd_t* lcd, const dirty_rects_t* dirty_rects, lcd_draw_mode_t draw_mode) {\n  const rect_t* dirty_rect = dirty_rects != NULL ? &(dirty_rects->max) : NULL;\n  return_value_if_fail(lcd != NULL && lcd->begin_frame != NULL, RET_BAD_PARAMS);\n\n  lcd->draw_mode = draw_mode;\n  if (dirty_rect == NULL) {\n    lcd->dirty_rect.x = 0;\n    lcd->dirty_rect.y = 0;\n    lcd->dirty_rect.w = lcd->w;\n    lcd->dirty_rect.h = lcd->h;\n  } else {\n    lcd->dirty_rect = *dirty_rect;\n    rect_fix(&(lcd->dirty_rect), lcd->w, lcd->h);\n  }\n  lcd->dirty_rects = dirty_rects;\n\n  return lcd->begin_frame(lcd, dirty_rects);\n}",
            "key_variables": [
               [
                  37,
                  "lcd->w"
               ],
               [
                  38,
                  "lcd->h"
               ]
            ]
         },
         {
            "type": "func",
            "name": "lcd_get_dirty_rects",
            "line_range": [
               55,
               61
            ],
            "source_code": "const dirty_rects_t* lcd_get_dirty_rects(lcd_t* lcd) {\n  return_value_if_fail(lcd != NULL, NULL);\n  if (lcd->get_dirty_rects != NULL) {\n    return lcd->get_dirty_rects(lcd);\n  }\n  return lcd->dirty_rects;\n}",
            "key_variables": [
               [
                  61,
                  "lcd->dirty_rects"
               ]
            ]
         },
         {
            "type": "func",
            "name": "lcd_stroke_rect",
            "line_range": [
               192,
               200
            ],
            "source_code": "ret_t lcd_stroke_rect(lcd_t* lcd, xy_t x, xy_t y, wh_t w, wh_t h) {\n  return_value_if_fail(lcd != NULL && lcd->stroke_rect != NULL, RET_BAD_PARAMS);\n\n  if (w == 0 || h == 0) {\n    return RET_BAD_PARAMS;\n  }\n\n  return lcd->stroke_rect(lcd, x, y, w, h);\n}",
            "key_variables": [
               [
                  216,
                  "lcd->fill_color"
               ]
            ]
         },
         {
            "type": "func",
            "name": "lcd_resize",
            "line_range": [
               328,
               339
            ],
            "source_code": "ret_t lcd_resize(lcd_t* lcd, wh_t w, wh_t h, uint32_t line_length) {\n  return_value_if_fail(lcd != NULL, RET_BAD_PARAMS);\n  if (lcd->resize != NULL) {\n    if (lcd->resize(lcd, w, h, line_length) == RET_OK) {\n      lcd->w = w;\n      lcd->h = h;\n      return RET_OK;\n    }\n  }\n\n  return RET_FAIL;\n}",
            "key_variables": [
               [
                  357,
                  "lcd->w"
               ],
               [
                  367,
                  "lcd->h"
               ]
            ]
         },
         {
            "type": "func",
            "name": "lcd_get_width",
            "line_range": [
               350,
               358
            ],
            "source_code": "wh_t lcd_get_width(lcd_t* lcd) {\n  return_value_if_fail(lcd != NULL, 0);\n\n  if (lcd->get_width != NULL) {\n    return lcd->get_width(lcd);\n  } else {\n    return lcd->w;\n  }\n}",
            "key_variables": [
               [
                  382,
                  "lcd->type"
               ]
            ]
         },
         {
            "type": "func",
            "name": "lcd_get_text_metrics",
            "line_range": [
               370,
               374
            ],
            "source_code": "ret_t lcd_get_text_metrics(lcd_t* lcd, float_t* ascent, float_t* descent, float_t* line_hight) {\n  return_value_if_fail(lcd != NULL && lcd->get_text_metrics != NULL, RET_BAD_PARAMS);\n\n  return lcd->get_text_metrics(lcd, ascent, descent, line_hight);\n}",
            "key_variables": [
               [
                  406,
                  "lcd->support_dirty_rect"
               ]
            ]
         }
      ],
      "src/base/lcd_profile.c": [
         {
            "type": "func",
            "name": "lcd_profile_measure_text",
            "line_range": [
               212,
               216
            ],
            "source_code": "static float_t lcd_profile_measure_text(lcd_t* lcd, const wchar_t* str, uint32_t nr) {\n  lcd_profile_t* profile = LCD_PROFILE(lcd);\n\n  return lcd_measure_text(profile->impl, str, nr);\n}",
            "key_variables": [
               [
                  246,
                  "dst->h"
               ]
            ]
         },
         {
            "type": "func",
            "name": "lcd_profile_swap",
            "line_range": [
               277,
               289
            ],
            "source_code": "static ret_t lcd_profile_swap(lcd_t* lcd) {\n  ret_t ret = RET_OK;\n\n  uint32_t cost = 0;\n  uint64_t start = time_now_ms();\n  lcd_profile_t* profile = LCD_PROFILE(lcd);\n  ret = lcd_swap(profile->impl);\n  cost = time_now_ms() - start;\n\n  profile->swap_cost = cost;\n\n  return ret;\n}",
            "key_variables": [
               [
                  317,
                  "profile->begin_frame_time"
               ],
               [
                  352,
                  "impl->type"
               ],
               [
                  353,
                  "impl->ratio"
               ],
               [
                  357,
                  "impl->support_dirty_rect"
               ]
            ]
         }
      ],
      "src/base/line_break.c": [
         {
            "type": "func",
            "name": "word_break_check",
            "line_range": [
               58,
               77
            ],
            "source_code": "break_type_t word_break_check(wchar_t c1, wchar_t c2) {\n  utf32_t s[2];\n  char brks[2];\n  static bool_t inited = FALSE;\n\n  if (!inited) {\n    inited = TRUE;\n    init_wordbreak();\n  }\n\n  s[0] = c1;\n  s[1] = c2;\n  set_wordbreaks_utf32(s, 2, \"\", brks);\n\n  if (brks[0] == WORDBREAK_BREAK) {\n    return LINE_BREAK_ALLOW;\n  } else {\n    return LINE_BREAK_NO;\n  }\n}",
            "key_variables": [
               [
                  60,
                  "s[2]"
               ],
               [
                  61,
                  "brks[2]"
               ]
            ]
         }
      ],
      "src/base/locale_info.c": [
         {
            "type": "func",
            "name": "locale_info_tr",
            "line_range": [
               57,
               68
            ],
            "source_code": "const char* locale_info_tr(locale_info_t* locale_info, const char* text) {\n  str_table_t* table = NULL;\n  const char* tr_text = NULL;\n  return_value_if_fail(locale_info != NULL && text != NULL, text);\n  return_value_if_fail(locale_info->strs != NULL, text);\n\n  table = (str_table_t*)(locale_info->strs->data);\n\n  tr_text = str_table_lookup(table, text);\n\n  return tr_text != NULL ? tr_text : text;\n}",
            "key_variables": [
               [
                  81,
                  "name[16]"
               ]
            ]
         }
      ],
      "src/base/main_loop.c": [
         {
            "type": "block",
            "name": "block",
            "line_range": "",
            "source_code": "",
            "key_variables": [
               29,
               "l->running"
            ]
         },
         {
            "type": "block",
            "name": "block",
            "line_range": "",
            "source_code": "",
            "key_variables": [
               36,
               "l->quit_num"
            ]
         },
         {
            "type": "func",
            "name": "main_loop_wakeup",
            "line_range": [
               88,
               104
            ],
            "source_code": "ret_t main_loop_wakeup(main_loop_t* l) {\n\n  return_value_if_fail(l != NULL, RET_BAD_PARAMS);\n\n\n\n  if (l->wakeup != NULL) {\n\n    l->wakeup(l);\n\n  }\n\n\n\n  return RET_OK;\n\n}",
            "key_variables": [
               [
                  92,
                  "l->last_loop_time"
               ]
            ]
         }
      ],
      "src/base/self_layouter_factory.c": [
         {
            "type": "block",
            "name": "block",
            "line_range": "",
            "source_code": "",
            "key_variables": [
               36,
               "type[TK_NAME_LEN + 1]"
            ]
         }
      ],
      "src/base/shortcut.c": [
         {
            "type": "func",
            "name": "shortcut_init_with_str",
            "line_range": [
               37,
               87
            ],
            "source_code": "shortcut_t* shortcut_init_with_str(shortcut_t* shortcut, const char* str) {\n  tokenizer_t t;\n  const char* k = NULL;\n  return_value_if_fail(shortcut != NULL && str != NULL, NULL);\n  return_value_if_fail(tokenizer_init_ex(&t, str, strlen(str), \" _+\", NULL) != NULL, NULL);\n\n  memset(shortcut, 0, sizeof(shortcut_t));\n  while (tokenizer_has_more(&t)) {\n    k = tokenizer_next(&t);\n    if (tk_str_ieq(k, \"ctrl\")) {\n      shortcut->ctrl = TRUE;\n      shortcut->lctrl = TRUE;\n      shortcut->rctrl = TRUE;\n    } else if (tk_str_ieq(k, \"alt\")) {\n      shortcut->alt = TRUE;\n      shortcut->lalt = TRUE;\n      shortcut->ralt = TRUE;\n    } else if (tk_str_ieq(k, \"shift\")) {\n      shortcut->shift = TRUE;\n      shortcut->lshift = TRUE;\n      shortcut->rshift = TRUE;\n    } else if (tk_str_ieq(k, \"lctrl\")) {\n      shortcut->lctrl = TRUE;\n    } else if (tk_str_ieq(k, \"lalt\")) {\n      shortcut->lalt = TRUE;\n    } else if (tk_str_ieq(k, \"lshift\")) {\n      shortcut->lshift = TRUE;\n    } else if (tk_str_ieq(k, \"rctrl\")) {\n      shortcut->rctrl = TRUE;\n    } else if (tk_str_ieq(k, \"ralt\")) {\n      shortcut->ralt = TRUE;\n    } else if (tk_str_ieq(k, \"rshift\")) {\n      shortcut->rshift = TRUE;\n    } else if (tk_str_ieq(k, \"cmd\")) {\n      shortcut->cmd = TRUE;\n    } else if (tk_str_ieq(k, \"menu\")) {\n      shortcut->menu = TRUE;\n    } else {\n      const key_type_value_t* kv = keys_type_find(k);\n      if (kv != NULL) {\n        shortcut->key = kv->value;\n      } else {\n        log_warn(\"%s not supported\\n\", k);\n      }\n    }\n    shortcut->is_valid = TRUE;\n  }\n  tokenizer_deinit(&t);\n\n  return shortcut;\n}",
            "key_variables": [
               [
                  78,
                  "kv->value"
               ]
            ]
         }
      ],
      "src/base/style.c": [
         {
            "type": "func",
            "name": "style_set_style_data",
            "line_range": [
               107,
               111
            ],
            "source_code": "ret_t style_set_style_data(style_t* s, const uint8_t* data, const char* state) {\n  return_value_if_fail(s != NULL && s->vt != NULL && s->vt->set_style_data != NULL && data != NULL,\n                       RET_BAD_PARAMS);\n  return s->vt->set_style_data(s, data, state);\n}",
            "key_variables": [
               [
                  125,
                  "vt->is_mutable"
               ]
            ]
         }
      ],
      "src/base/style_const.c": [
         {
            "type": "func",
            "name": "style_const_apply_props",
            "line_range": [
               78,
               105
            ],
            "source_code": "static ret_t style_const_apply_props(style_t* s, widget_t* widget) {\n  const char* self_layout = style_get_str(s, STYLE_ID_SELF_LAYOUT, NULL);\n  const char* children_layout = style_get_str(s, STYLE_ID_CHILDREN_LAYOUT, NULL);\n  const char* focusable = style_get_str(s, STYLE_ID_FOCUSABLE, NULL);\n  const char* feedback = style_get_str(s, STYLE_ID_FEEDBACK, NULL);\n\n  if (self_layout != NULL || children_layout != NULL) {\n    if (self_layout != NULL) {\n      widget_set_self_layout(widget, self_layout);\n      widget_set_need_relayout(widget);\n    }\n\n    if (children_layout != NULL) {\n      widget_set_children_layout(widget, children_layout);\n      widget_set_need_relayout_children(widget);\n    }\n  }\n\n  if (focusable != NULL) {\n    widget->focusable = *focusable == 'T' || *focusable == 't';\n  }\n\n  if (feedback != NULL) {\n    widget->feedback = *feedback == 'T' || *feedback == 't';\n  }\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  113,
                  "style->data"
               ]
            ]
         },
         {
            "type": "func",
            "name": "style_const_set_style_data",
            "line_range": [
               170,
               180
            ],
            "source_code": "static ret_t style_const_set_style_data(style_t* s, const uint8_t* data, const char* state) {\n  style_const_t* style = (style_const_t*)s;\n  return_value_if_fail(style != NULL, RET_BAD_PARAMS);\n  style->data = data;\n  if (state != NULL) {\n    style->state = tk_str_copy(style->state, state);\n  } else {\n    style->state = tk_str_copy(style->state, WIDGET_STATE_NORMAL);\n  }\n  return RET_OK;\n}",
            "key_variables": [
               [
                  186,
                  "style->state"
               ]
            ]
         }
      ],
      "src/base/style_mutable.c": [
         {
            "type": "block",
            "name": "block",
            "line_range": "",
            "source_code": "",
            "key_variables": [
               30,
               "name[TK_NAME_LEN + 1]"
            ]
         },
         {
            "type": "func",
            "name": "style_item_set_value",
            "line_range": [
               37,
               48
            ],
            "source_code": "static ret_t style_item_set_value(style_item_t* item, const value_t* value) {\n  const char* name = item->name;\n  value_t* v = &(item->value);\n\n  value_reset(v);\n  if (value->type == VALUE_TYPE_STRING) {\n    return style_normalize_value(name, value_str(value), v);\n  } else {\n    value_set_int(v, value_int(value));\n    return RET_OK;\n  }\n}",
            "key_variables": [
               [
                  39,
                  "item->name"
               ]
            ]
         },
         {
            "type": "func",
            "name": "style_item_add",
            "line_range": [
               56,
               73
            ],
            "source_code": "static style_item_t* style_item_add(style_item_t* first, const char* name, const value_t* value) {\n  style_item_t* iter = first;\n  style_item_t* item = TKMEM_ZALLOC(style_item_t);\n  return_value_if_fail(item != NULL, NULL);\n\n  style_item_init(item, name, value);\n\n  if (first != NULL) {\n    while (iter->next) {\n      iter = iter->next;\n    }\n    iter->next = item;\n  } else {\n    first = item;\n  }\n\n  return first;\n}",
            "key_variables": [
               [
                  66,
                  "iter->next"
               ],
               [
                  85,
                  "iter->next"
               ]
            ]
         },
         {
            "type": "func",
            "name": "style_item_get",
            "line_range": [
               91,
               106
            ],
            "source_code": "static ret_t style_item_get(style_item_t* first, const char* name, value_t* value) {\n  style_item_t* iter = first;\n  return_value_if_fail(iter != NULL, RET_BAD_PARAMS);\n\n  if (first != NULL) {\n    while (iter) {\n      if (tk_str_eq(iter->name, name)) {\n        *value = iter->value;\n        return RET_OK;\n      }\n      iter = iter->next;\n    }\n  }\n\n  return RET_FAIL;\n}",
            "key_variables": [
               [
                  99,
                  "iter->value"
               ],
               [
                  102,
                  "iter->next"
               ]
            ]
         },
         {
            "type": "func",
            "name": "style_item_set",
            "line_range": [
               75,
               89
            ],
            "source_code": "static ret_t style_item_set(style_item_t* first, const char* name, const value_t* value) {\n  style_item_t* iter = first;\n\n  if (first != NULL) {\n    while (iter) {\n      if (tk_str_eq(iter->name, name)) {\n        style_item_set_value(iter, value);\n        return RET_OK;\n      }\n      iter = iter->next;\n    }\n  }\n\n  return RET_FAIL;\n}",
            "key_variables": [
               [
                  110,
                  "state[TK_NAME_LEN + 1]"
               ]
            ]
         },
         {
            "type": "func",
            "name": "style_item_get",
            "line_range": [
               91,
               106
            ],
            "source_code": "static ret_t style_item_get(style_item_t* first, const char* name, value_t* value) {\n  style_item_t* iter = first;\n  return_value_if_fail(iter != NULL, RET_BAD_PARAMS);\n\n  if (first != NULL) {\n    while (iter) {\n      if (tk_str_eq(iter->name, name)) {\n        *value = iter->value;\n        return RET_OK;\n      }\n      iter = iter->next;\n    }\n  }\n\n  return RET_FAIL;\n}",
            "key_variables": [
               [
                  124,
                  "iter->next"
               ]
            ]
         },
         {
            "type": "func",
            "name": "widget_state_style_add",
            "line_range": [
               115,
               132
            ],
            "source_code": "widget_state_style_t* widget_state_style_add(widget_state_style_t* first, const char* state) {\n  widget_state_style_t* iter = first;\n  widget_state_style_t* item = TKMEM_ZALLOC(widget_state_style_t);\n  return_value_if_fail(item != NULL, NULL);\n\n  tk_strncpy(item->state, state, TK_NAME_LEN);\n  if (first != NULL) {\n    while (iter->next) {\n      iter = iter->next;\n    }\n\n    iter->next = item;\n  } else {\n    first = item;\n  }\n\n  return first;\n}",
            "key_variables": [
               [
                  144,
                  "iter->next"
               ]
            ]
         },
         {
            "type": "func",
            "name": "style_mutable_remove_value",
            "line_range": [
               260,
               318
            ],
            "source_code": "ret_t style_mutable_remove_value(style_t* s, const char* state, const char* name) {\n  style_mutable_t* style = STYLE_MUTABLE(s);\n  return_value_if_fail(style != NULL, RET_BAD_PARAMS);\n  if (state == NULL && name == NULL) {\n    return style_mutable_reset(s);\n  }\n\n  if (name != NULL) {\n    style_item_t* iter = NULL;\n    style_item_t* prev = NULL;\n    style_item_t* remove_iter = NULL;\n    widget_state_style_t* current = widget_state_style_find(style->styles, state);\n    if (current == NULL || current->items == NULL) {\n      return RET_NOT_FOUND;\n    }\n    iter = current->items;\n    while (iter) {\n      if (tk_str_eq(iter->name, name)) {\n        if (iter == current->items) {\n          current->items = iter->next;\n        } else {\n          prev->next = iter->next;\n        }\n        remove_iter = iter;\n        break;\n      }\n      prev = iter;\n      iter = iter->next;\n    }\n    if (remove_iter == NULL) {\n      return RET_NOT_FOUND;\n    }\n    value_reset(&(remove_iter->value));\n    TKMEM_FREE(remove_iter);\n  } else {\n    widget_state_style_t* prev = NULL;\n    widget_state_style_t* remove_iter = NULL;\n    widget_state_style_t* iter = style->styles;\n    while (iter != NULL) {\n      if (tk_str_eq(iter->state, state)) {\n        remove_iter = iter;\n        if (iter == style->styles) {\n          style->styles = iter->next;\n        } else {\n          prev->next = iter->next;\n        }\n        break;\n      }\n      prev = iter;\n      iter = iter->next;\n    }\n    if (remove_iter == NULL) {\n      return RET_NOT_FOUND;\n    }\n    style_mutable_state_style_free(remove_iter);\n  }\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  276,
                  "current->items"
               ],
               [
                  280,
                  "iter->next"
               ],
               [
                  282,
                  "iter->next"
               ],
               [
                  288,
                  "iter->next"
               ],
               [
                  298,
                  "style->styles"
               ],
               [
                  303,
                  "iter->next"
               ],
               [
                  305,
                  "iter->next"
               ],
               [
                  310,
                  "iter->next"
               ]
            ]
         },
         {
            "type": "func",
            "name": "style_mutable_set_color",
            "line_range": [
               357,
               361
            ],
            "source_code": "ret_t style_mutable_set_color(style_t* s, const char* state, const char* name, color_t val) {\n  value_t v;\n\n  return style_mutable_set_value(s, state, name, value_set_uint32(&v, val.color));\n}",
            "key_variables": [
               [
                  377,
                  "style->styles"
               ],
               [
                  379,
                  "witer->items"
               ],
               [
                  382,
                  "iter->next"
               ],
               [
                  384,
                  "witer->next"
               ]
            ]
         },
         {
            "type": "func",
            "name": "style_mutable_set_str",
            "line_range": [
               363,
               368
            ],
            "source_code": "ret_t style_mutable_set_str(style_t* s, const char* state, const char* name, const char* val) {\n  value_t v;\n  return_value_if_fail(s != NULL && val != NULL, RET_BAD_PARAMS);\n\n  return style_mutable_set_value(s, state, name, value_set_str(&v, val));\n}",
            "key_variables": [
               [
                  393,
                  "witer->items"
               ],
               [
                  395,
                  "iter->next"
               ],
               [
                  412,
                  "style->styles"
               ],
               [
                  414,
                  "witer->next"
               ]
            ]
         }
      ],
      "src/base/suggest_words.c": [
         {
            "type": "func",
            "name": "get_str",
            "line_range": [
               65,
               79
            ],
            "source_code": "static const uint16_t* get_str(const uint16_t* p16, wchar_t* str, uint32_t max_chars) {\n  uint32_t i = 0;\n  wchar_t* pc = str;\n\n  while (*p16) {\n    if (i < max_chars) {\n      *pc++ = *p16++;\n    } else {\n      p16++;\n    }\n    i++;\n  }\n\n  return p16 + 1;\n}",
            "key_variables": [
               [
                  86,
                  "sword[64]"
               ],
               [
                  87,
                  "word[16]"
               ]
            ]
         }
      ],
      "src/base/system_info.c": [
         {
            "type": "func",
            "name": "app_root_is_valid",
            "line_range": [
               40,
               47
            ],
            "source_code": "static bool_t app_root_is_valid(const char* app_root) {\n  char res_root[MAX_PATH + 1];\n  return_value_if_fail(app_root != NULL, FALSE);\n\n  path_build(res_root, MAX_PATH, app_root, \"assets\", NULL);\n\n  return path_exist(res_root);\n}",
            "key_variables": [
               [
                  42,
                  "res_root[MAX_PATH + 1]"
               ]
            ]
         },
         {
            "type": "func",
            "name": "system_info_init",
            "line_range": [
               181,
               199
            ],
            "source_code": "ret_t system_info_init(app_type_t app_type, const char* app_name, const char* app_root) {\n  if (s_system_info == NULL) {\n    s_system_info = system_info_create(app_type, app_name, app_root);\n    system_info_set_default_font(s_system_info, \"default\");\n    return_value_if_fail(s_system_info != NULL, RET_BAD_PARAMS);\n  } else {\n    system_info_set_app_info(s_system_info, app_type, app_name, app_root);\n  }\n\n#ifdef AWTK_WEB\n  {\n    float_t font_scale = EM_ASM_DOUBLE({ return (TBrowser.config.fontScale || 1); }, 0);\n    system_info_set_font_scale(s_system_info, font_scale);\n    log_debug(\"system_info_init: font_scale=%lf\\n\", font_scale);\n  }\n#endif /*AWTK_WEB*/\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  223,
                  "info->lcd_w"
               ],
               [
                  224,
                  "info->lcd_h"
               ],
               [
                  225,
                  "info->lcd_orientation"
               ],
               [
                  227,
                  "info->lcd_h"
               ],
               [
                  228,
                  "info->lcd_w"
               ]
            ]
         }
      ],
      "src/base/text_edit.c": [
         {
            "type": "block",
            "name": "block",
            "line_range": "",
            "source_code": "",
            "key_variables": [
               84,
               "row[1]"
            ]
         },
         {
            "type": "func",
            "name": "widget_get_text_layout_info",
            "line_range": [
               135,
               153
            ],
            "source_code": "static ret_t widget_get_text_layout_info(widget_t* widget, text_layout_info_t* info) {\n  style_t* style = widget->astyle;\n  return_value_if_fail(widget != NULL && info != NULL && style != NULL, RET_BAD_PARAMS);\n\n  info->widget_w = widget->w;\n  info->widget_h = widget->h;\n  info->virtual_w = widget->w;\n  info->virtual_h = widget->h;\n\n  TEXT_EDIT_GET_WIDGET_MARGIN(widget, style, info->margin_l, LEFT);\n  TEXT_EDIT_GET_WIDGET_MARGIN(widget, style, info->margin_r, RIGHT);\n  TEXT_EDIT_GET_WIDGET_MARGIN(widget, style, info->margin_t, TOP);\n  TEXT_EDIT_GET_WIDGET_MARGIN(widget, style, info->margin_b, BOTTOM);\n\n  info->w = info->widget_w - info->margin_l - info->margin_r;\n  info->h = info->widget_h - info->margin_t - info->margin_b;\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  137,
                  "widget->astyle"
               ],
               [
                  140,
                  "widget->w"
               ],
               [
                  141,
                  "widget->h"
               ],
               [
                  142,
                  "widget->w"
               ],
               [
                  143,
                  "widget->h"
               ],
               [
                  150,
                  "info->margin_r"
               ],
               [
                  151,
                  "info->margin_b"
               ]
            ]
         },
         {
            "type": "func",
            "name": "rows_create",
            "line_range": [
               155,
               172
            ],
            "source_code": "static rows_t* rows_create(uint32_t capacity) {\n  uint32_t msize = sizeof(rows_t) + capacity * sizeof(row_info_t);\n  rows_t* rows = (rows_t*)TKMEM_ALLOC(msize);\n  uint32_t i = 0;\n  return_value_if_fail(rows != NULL, NULL);\n\n  memset(rows, 0x00, msize);\n  for (i = 0; i < capacity; i++) {\n    darray_init(&rows->row[i].info, 4, default_destroy, NULL);\n    darray_push(&rows->row[i].info, TKMEM_ZALLOC(line_info_t));\n    rows->row[i].line_num = 1;\n  }\n\n  rows->row_line = TKMEM_ZALLOCN(uint32_t, capacity);\n  rows->capacity = capacity;\n\n  return rows;\n}",
            "key_variables": [
               [
                  179,
                  "rows->size"
               ],
               [
                  182,
                  "row->line_num"
               ]
            ]
         },
         {
            "type": "func",
            "name": "rows_destroy",
            "line_range": [
               192,
               203
            ],
            "source_code": "static ret_t rows_destroy(rows_t* rows) {\n  uint32_t i = 0;\n  return_value_if_fail(rows != NULL, RET_BAD_PARAMS);\n\n  for (i = 0; i < rows->capacity; i++) {\n    darray_deinit(&rows->row[i].info);\n  }\n  TKMEM_FREE(rows->row_line);\n  TKMEM_FREE(rows);\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  197,
                  "rows->capacity"
               ],
               [
                  214,
                  "layout_info->margin_t"
               ],
               [
                  215,
                  "layout_info->h"
               ],
               [
                  216,
                  "layout_info->margin_l"
               ],
               [
                  217,
                  "layout_info->w"
               ],
               [
                  223,
                  "layout_info->margin_t"
               ],
               [
                  227,
                  "layout_info->h"
               ],
               [
                  231,
                  "layout_info->margin_l"
               ],
               [
                  235,
                  "layout_info->margin_l"
               ]
            ]
         },
         {
            "type": "func",
            "name": "text_edit_set_caret_pos",
            "line_range": [
               205,
               250
            ],
            "source_code": "static ret_t text_edit_set_caret_pos(text_edit_impl_t* impl, uint32_t x, uint32_t y,\n                                     uint32_t font_size) {\n  text_layout_info_t* layout_info = &(impl->layout_info);\n  uint32_t caret_top = layout_info->margin_t + y;\n  uint32_t caret_bottom = layout_info->margin_t + y + font_size;\n  uint32_t caret_left = layout_info->margin_l + x;\n  uint32_t caret_right = layout_info->margin_l + x + 1;\n\n  uint32_t view_top = layout_info->oy + layout_info->margin_t;\n  uint32_t view_bottom = layout_info->oy + layout_info->margin_t + layout_info->h;\n  uint32_t view_left = layout_info->ox + layout_info->margin_l;\n  uint32_t view_right = layout_info->ox + layout_info->margin_l + layout_info->w;\n\n  impl->caret.x = x;\n  impl->caret.y = y;\n\n  if (view_top > caret_top) {\n    layout_info->oy = caret_top - layout_info->margin_t;\n  }\n\n  if (view_bottom < caret_bottom) {\n    layout_info->oy = caret_bottom - layout_info->h;\n  }\n\n  if (view_left > caret_left) {\n    layout_info->ox = caret_left - layout_info->margin_l;\n  }\n\n  if (view_right < caret_right || (view_left > caret_left + layout_info->w)) {\n    layout_info->ox = caret_right - layout_info->w - layout_info->margin_l;\n  }\n\n  if (layout_info->ox < 0) {\n    layout_info->ox = 0;\n  }\n\n  if (impl->wrap_word) {\n    layout_info->ox = 0;\n  }\n\n  if (impl->single_line) {\n    layout_info->oy = 0;\n  }\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  259,
                  "str[i]"
               ],
               [
                  292,
                  "text->size"
               ],
               [
                  293,
                  "line->length"
               ],
               [
                  299,
                  "layout_info->margin_l"
               ]
            ]
         },
         {
            "type": "func",
            "name": "text_edit_multi_line_layout_line",
            "line_range": [
               313,
               425
            ],
            "source_code": "static row_info_t* text_edit_multi_line_layout_line(text_edit_t* text_edit, uint32_t row_num,\n                                                    uint32_t line_index, uint32_t offset) {\n  uint32_t i = 0;\n  uint32_t x = 0;\n  DECL_IMPL(text_edit);\n  wchar_t last_char = 0;\n  canvas_t* c = GET_CANVAS(text_edit);\n  wstr_t* text = &(text_edit->widget->text);\n  STB_TexteditState* state = &(impl->state);\n  row_info_t* row = impl->rows->row + row_num;\n  uint32_t line_height = impl->line_height;\n  uint32_t y = line_index * line_height;\n  uint32_t y0 = y;\n  uint32_t offset0 = offset;\n  uint32_t last_breakable_i = 0;\n  uint32_t last_breakable_x = 0;\n  line_info_t* last_line = NULL;\n  text_layout_info_t* layout_info = &(impl->layout_info);\n\n  memset(row, 0x00, sizeof(row_info_t) - sizeof(darray_t));\n  row->line_num = 1;\n\n  for (i = offset; i < text->size; i++) {\n    wchar_t* p = text->str + i;\n    break_type_t word_break = LINE_BREAK_NO;\n    break_type_t line_break = LINE_BREAK_NO;\n    uint32_t char_w = canvas_measure_text(c, p, 1) + CHAR_SPACING;\n\n    if (i == state->cursor) {\n      text_edit_set_caret_pos(impl, x, y, c->font_size);\n    }\n\n    last_char = *p;\n    line_break = line_break_check(*p, p[1]);\n    if (line_break == LINE_BREAK_MUST) {\n      i++;\n      break;\n    }\n\n    if (impl->wrap_word) {\n      if ((x + char_w) > layout_info->w) {\n        if (last_breakable_x > 0) {\n          i = last_breakable_i + 1;\n          x = last_breakable_x;\n          last_breakable_x = 0;\n        }\n        if (i == offset) {\n          i++;\n        }\n\n        last_line = (line_info_t*)darray_get(&row->info, row->line_num - 1);\n        memset(last_line, 0x00, sizeof(line_info_t));\n        last_line->text_w = x;\n        last_line->offset = offset;\n        last_line->length = i - offset;\n\n        row->line_num++;\n        if (row->info.size < row->line_num) {\n          darray_push(&row->info, TKMEM_ZALLOC(line_info_t));\n        }\n\n        p = text->str + i;\n        char_w = canvas_measure_text(c, p, 1) + CHAR_SPACING;\n\n        x = char_w;\n        y += line_height;\n        offset = i;\n        line_index++;\n        continue;\n      }\n\n      x += char_w;\n      word_break = word_break_check(*p, p[1]);\n      if (word_break == LINE_BREAK_ALLOW && line_break == LINE_BREAK_ALLOW) {\n        last_breakable_x = x;\n        last_breakable_i = i;\n      }\n    } else {\n      x += char_w;\n    }\n  }\n\n  while (row->info.size > row->line_num) {\n    row->info.destroy(darray_pop(&row->info));\n  }\n\n  if (i == state->cursor && state->cursor == text->size) {\n    if (last_char == STB_TEXTEDIT_NEWLINE) {\n      text_edit_set_caret_pos(impl, 0, y + line_height, c->font_size);\n    } else {\n      text_edit_set_caret_pos(impl, x, y, c->font_size);\n    }\n  }\n\n  if (last_char == STB_TEXTEDIT_NEWLINE) {\n    impl->last_row_number = row_num + 1;\n    impl->last_line_number = line_index + 1;\n  } else {\n    impl->last_row_number = row_num;\n    impl->last_line_number = line_index;\n  }\n\n  last_line = (line_info_t*)darray_get(&row->info, row->line_num - 1);\n  memset(last_line, 0x00, sizeof(line_info_t));\n  last_line->text_w = x;\n  last_line->offset = offset;\n  last_line->length = i - offset;\n\n  row->length = i - offset0;\n  layout_info->virtual_h = tk_max(y0, layout_info->widget_h);\n\n  return row;\n}",
            "key_variables": [
               [
                  324,
                  "impl->line_height"
               ],
               [
                  336,
                  "text->size"
               ]
            ]
         },
         {
            "type": "func",
            "name": "text_edit_layout_line",
            "line_range": [
               435,
               443
            ],
            "source_code": "static row_info_t* text_edit_layout_line(text_edit_t* text_edit, uint32_t row_num,\n                                         uint32_t line_index, uint32_t offset) {\n  DECL_IMPL(text_edit);\n  if (impl->single_line) {\n    return text_edit_single_line_layout_line(text_edit, row_num, line_index, offset);\n  } else {\n    return text_edit_multi_line_layout_line(text_edit, row_num, line_index, offset);\n  }\n}",
            "key_variables": [
               [
                  452,
                  "rows->capacity"
               ],
               [
                  478,
                  "iter->line_num"
               ],
               [
                  479,
                  "iter->length"
               ]
            ]
         },
         {
            "type": "func",
            "name": "text_edit_layout",
            "line_range": [
               496,
               503
            ],
            "source_code": "ret_t text_edit_layout(text_edit_t* text_edit) {\n  if (text_edit == NULL || GET_CANVAS(text_edit) == NULL || text_edit->widget == NULL ||\n      text_edit->widget->initializing || text_edit->widget->loading) {\n    return RET_BAD_PARAMS;\n  }\n\n  return text_edit_layout_impl(text_edit);\n}",
            "key_variables": [
               [
                  510,
                  "c->font_size"
               ],
               [
                  514,
                  "info->x"
               ],
               [
                  515,
                  "info->text_w"
               ],
               [
                  516,
                  "info->length"
               ],
               [
                  525,
                  "impl->line_height"
               ],
               [
                  532,
                  "text_edit->widget"
               ],
               [
                  533,
                  "widget->astyle"
               ],
               [
                  537,
                  "layout_info->ox"
               ],
               [
                  538,
                  "layout_info->oy"
               ]
            ]
         },
         {
            "type": "func",
            "name": "text_edit_layout_for_stb",
            "line_range": [
               505,
               527
            ],
            "source_code": "static void text_edit_layout_for_stb(StbTexteditRow* row, STB_TEXTEDIT_STRING* str, int offset) {\n  DECL_IMPL(str);\n  canvas_t* c = GET_CANVAS(str);\n  if (c == NULL) return;\n  uint32_t font_size = c->font_size;\n  line_info_t* info = line_find_by_offset(impl->rows, offset);\n\n  if (info != NULL) {\n    row->x0 = info->x;\n    row->x1 = info->x + info->text_w;\n    row->num_chars = info->length;\n  } else {\n    row->x0 = 0;\n    row->x1 = 0;\n    row->num_chars = 1;\n  }\n\n  row->ymin = 0;\n  row->ymax = font_size;\n  row->baseline_y_delta = impl->line_height;\n\n  return;\n}",
            "key_variables": [
               [
                  560,
                  "c->font_size"
               ],
               [
                  564,
                  "layout_info->w"
               ],
               [
                  565,
                  "layout_info->margin_t"
               ],
               [
                  574,
                  "p->line_size"
               ],
               [
                  599,
                  "c->text_align_h"
               ],
               [
                  600,
                  "c->text_align_v"
               ]
            ]
         },
         {
            "type": "func",
            "name": "text_edit_calc_x",
            "line_range": [
               616,
               641
            ],
            "source_code": "static int32_t text_edit_calc_x(text_edit_t* text_edit, line_info_t* iter) {\n  DECL_IMPL(text_edit);\n  canvas_t* c = GET_CANVAS(text_edit);\n  widget_t* widget = text_edit->widget;\n  wstr_t* text = &(widget->text);\n  wchar_t chr = impl->mask ? impl->mask_char : 0;\n  text_layout_info_t* layout_info = &(impl->layout_info);\n  align_h_t align_h = widget_get_text_align_h(text_edit->widget);\n\n  uint32_t row_width = text_edit_measure_text(c, text->str + iter->offset, chr, iter->length);\n  if (row_width < layout_info->w) {\n    switch (align_h) {\n      case ALIGN_H_CENTER: {\n        return (layout_info->w - row_width) / 2;\n      }\n      case ALIGN_H_RIGHT: {\n        return (layout_info->w - row_width);\n      }\n      default: {\n        break;\n      }\n    }\n  }\n\n  return 0;\n}",
            "key_variables": [
               [
                  620,
                  "text_edit->widget"
               ],
               [
                  649,
                  "text_edit->widget"
               ],
               [
                  653,
                  "widget->astyle"
               ],
               [
                  656,
                  "layout_info->margin_l"
               ],
               [
                  657,
                  "layout_info->w"
               ],
               [
                  668,
                  "layout_info->margin_l"
               ],
               [
                  674,
                  "iter->length"
               ],
               [
                  676,
                  "vis_str[k]"
               ],
               [
                  689,
                  "layout_info->ox"
               ],
               [
                  690,
                  "layout_info->oy"
               ],
               [
                  691,
                  "state->cursor"
               ]
            ]
         },
         {
            "type": "func",
            "name": "text_edit_paint_line",
            "line_range": [
               643,
               723
            ],
            "source_code": "static ret_t text_edit_paint_line(text_edit_t* text_edit, canvas_t* c, line_info_t* iter,\n                                  uint32_t y) {\n  bidi_t b;\n  uint32_t x = 0;\n  uint32_t k = 0;\n  widget_t* widget = text_edit->widget;\n  const char* bidi_type = widget_get_prop_str(widget, WIDGET_PROP_BIDI, NULL);\n  DECL_IMPL(text_edit);\n  wstr_t* text = &(widget->text);\n  style_t* style = widget->astyle;\n  STB_TexteditState* state = &(impl->state);\n  text_layout_info_t* layout_info = &(impl->layout_info);\n  uint32_t view_left = layout_info->ox + layout_info->margin_l;\n  uint32_t view_right = layout_info->ox + layout_info->margin_l + layout_info->w;\n\n  color_t black = color_init(0, 0, 0, 0xff);\n  color_t white = color_init(0xf0, 0xf0, 0xf0, 0xff);\n\n  uint32_t select_start = tk_min(state->select_start, state->select_end);\n  uint32_t select_end = tk_max(state->select_start, state->select_end);\n\n  if (impl->single_line) {\n    x = layout_info->margin_l + text_edit_calc_x(text_edit, iter);\n  } else {\n    x = layout_info->margin_l;\n  }\n\n  bidi_init(&b, FALSE, FALSE, bidi_type_from_name(bidi_type));\n  ENSURE(bidi_log2vis(&b, text->str + iter->offset, iter->length) == RET_OK);\n\n  for (k = 0; k < iter->length; k++) {\n    uint32_t offset = iter->offset + k;\n    wchar_t chr = impl->mask ? impl->mask_char : b.vis_str[k];\n    uint32_t char_w = canvas_measure_text(c, &chr, 1);\n\n    if ((x + char_w) < view_left) {\n      x += char_w + CHAR_SPACING;\n      continue;\n    }\n\n    if (x > view_right) {\n      break;\n    }\n\n    if (chr != STB_TEXTEDIT_NEWLINE) {\n      uint32_t rx = x - layout_info->ox;\n      uint32_t ry = y - layout_info->oy;\n      uint32_t cursor = state->cursor;\n\n      bool_t selected = offset >= select_start && offset < select_end;\n      bool_t preedit =\n          impl->preedit && offset < cursor && offset >= (cursor - impl->preedit_chars_nr);\n\n      if (selected || preedit) {\n        color_t select_bg_color = style_get_color(style, STYLE_ID_SELECTED_BG_COLOR, white);\n        color_t select_text_color = style_get_color(style, STYLE_ID_SELECTED_TEXT_COLOR, black);\n\n        canvas_set_fill_color(c, select_bg_color);\n        canvas_fill_rect(c, rx, ry, char_w + CHAR_SPACING, c->font_size);\n\n        canvas_set_text_color(c, select_text_color);\n      } else {\n        color_t text_color = style_get_color(style, STYLE_ID_TEXT_COLOR, black);\n        canvas_set_text_color(c, text_color);\n      }\n\n      /*FIXME: 密码编辑时，*字符本身偏高，看起来不像居中。但是无法拿到字模信息，只好手工修正一下。*/\n      if (impl->mask && impl->mask_char == '*') {\n        int32_t oy = c->font_size / 6;\n        canvas_draw_text(c, &chr, 1, rx, ry + oy);\n      } else {\n        canvas_draw_text(c, &chr, 1, rx, ry);\n      }\n\n      x += char_w + CHAR_SPACING;\n    }\n  }\n  bidi_deinit(&b);\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  728,
                  "impl->rows"
               ],
               [
                  729,
                  "impl->line_height"
               ],
               [
                  731,
                  "layout_info->margin_t"
               ],
               [
                  732,
                  "layout_info->h"
               ],
               [
                  736,
                  "rows->size"
               ],
               [
                  740,
                  "row->line_num"
               ],
               [
                  745,
                  "layout_info->margin_t"
               ],
               [
                  748,
                  "layout_info->margin_t"
               ]
            ]
         },
         {
            "type": "func",
            "name": "text_edit_paint_real_text",
            "line_range": [
               725,
               763
            ],
            "source_code": "static ret_t text_edit_paint_real_text(text_edit_t* text_edit, canvas_t* c) {\n  DECL_IMPL(text_edit);\n  rows_t* rows = impl->rows;\n  uint32_t line_height = impl->line_height;\n  text_layout_info_t* layout_info = &(impl->layout_info);\n  uint32_t view_top = layout_info->oy + layout_info->margin_t;\n  uint32_t view_bottom = layout_info->oy + layout_info->margin_t + layout_info->h;\n\n  uint32_t i = 0;\n  uint32_t k = 0;\n  for (i = 0; i < rows->size; i++) {\n    uint32_t j = 0;\n    row_info_t* row = rows->row + i;\n\n    for (j = 0; j < row->line_num; j++, k++) {\n      line_info_t* line = (line_info_t*)darray_get(&row->info, j);\n      uint32_t y = 0;\n\n      if (impl->single_line) {\n        y = (layout_info->h - c->font_size) / 2 + layout_info->margin_t;\n\n      } else {\n        y = k * line_height + layout_info->margin_t;\n      }\n\n      if ((y + c->font_size) < view_top) {\n        continue;\n      }\n\n      if (y > view_bottom) {\n        break;\n      }\n\n      text_edit_paint_line(text_edit, c, line, y);\n    }\n  }\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  767,
                  "text_edit->widget"
               ]
            ]
         },
         {
            "type": "func",
            "name": "text_edit_paint",
            "line_range": [
               814,
               840
            ],
            "source_code": "ret_t text_edit_paint(text_edit_t* text_edit, canvas_t* c) {\n  rect_t save_r;\n  rect_t clip_r;\n  rect_t edit_r;\n  DECL_IMPL(text_edit);\n  text_layout_info_t* layout_info = &(impl->layout_info);\n\n  if (impl->is_first_time_layout) {\n    text_edit_layout(text_edit);\n    impl->is_first_time_layout = FALSE;\n  }\n\n  canvas_get_clip_rect(c, &save_r);\n\n  edit_r = rect_init(c->ox + layout_info->margin_l, c->oy + layout_info->margin_t, layout_info->w,\n                     layout_info->h);\n  clip_r = rect_intersect(&save_r, &edit_r);\n\n  canvas_save(c);\n  canvas_set_clip_rect(c, &clip_r);\n  text_edit_do_paint(text_edit, c);\n  canvas_restore(c);\n\n  canvas_set_clip_rect(c, &save_r);\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  852,
                  "str[pos + offset]"
               ]
            ]
         },
         {
            "type": "func",
            "name": "text_edit_create",
            "line_range": [
               930,
               951
            ],
            "source_code": "text_edit_t* text_edit_create(widget_t* widget, bool_t single_line) {\n  text_edit_impl_t* impl = NULL;\n  return_value_if_fail(widget != NULL, NULL);\n\n  impl = TKMEM_ZALLOC(text_edit_impl_t);\n  return_value_if_fail(impl != NULL, NULL);\n\n  impl->is_first_time_layout = TRUE;\n  impl->wrap_word = !single_line;\n  impl->text_edit.widget = widget;\n  impl->single_line = single_line;\n\n  wstr_init(&(impl->tips), 0);\n  stb_textedit_initialize_state(&(impl->state), single_line);\n  if (!single_line) {\n    text_edit_set_max_rows((text_edit_t*)impl, 100);\n  } else {\n    text_edit_set_max_rows((text_edit_t*)impl, 1);\n  }\n\n  return (text_edit_t*)impl;\n}",
            "key_variables": [
               [
                  967,
                  "impl->caret_visible"
               ]
            ]
         },
         {
            "type": "func",
            "name": "text_edit_invert_caret_visible",
            "line_range": [
               962,
               969
            ],
            "source_code": "ret_t text_edit_invert_caret_visible(text_edit_t* text_edit) {\n  DECL_IMPL(text_edit);\n  return_value_if_fail(text_edit, RET_BAD_PARAMS);\n\n  impl->caret_visible = !impl->caret_visible;\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  1003,
                  "rows->size"
               ],
               [
                  1006,
                  "row->line_num"
               ]
            ]
         },
         {
            "type": "func",
            "name": "text_edit_set_max_rows",
            "line_range": [
               971,
               985
            ],
            "source_code": "ret_t text_edit_set_max_rows(text_edit_t* text_edit, uint32_t max_rows) {\n  DECL_IMPL(text_edit);\n  return_value_if_fail(text_edit != NULL && max_rows >= 1, RET_BAD_PARAMS);\n\n  if (impl->rows != NULL) {\n    rows_destroy(impl->rows);\n    impl->rows = NULL;\n  }\n\n  if (impl->rows == NULL) {\n    impl->rows = rows_create(max_rows);\n  }\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  1023,
                  "rows->capacity"
               ],
               [
                  1027,
                  "rows->row_line"
               ],
               [
                  1030,
                  "rows->size"
               ],
               [
                  1050,
                  "widget->text"
               ]
            ]
         },
         {
            "type": "func",
            "name": "text_edit_set_canvas",
            "line_range": [
               1066,
               1072
            ],
            "source_code": "ret_t text_edit_set_canvas(text_edit_t* text_edit, canvas_t* canvas) {\n  return_value_if_fail(text_edit != NULL && canvas != NULL, RET_BAD_PARAMS);\n\n  text_edit_layout(text_edit);\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  1082,
                  "layout_info->ox"
               ],
               [
                  1083,
                  "layout_info->oy"
               ]
            ]
         },
         {
            "type": "func",
            "name": "text_edit_normalize_point",
            "line_range": [
               1074,
               1085
            ],
            "source_code": "static point_t text_edit_normalize_point(text_edit_t* text_edit, xy_t x, xy_t y) {\n  DECL_IMPL(text_edit);\n  point_t point = {x, y};\n  text_layout_info_t* layout_info = &(impl->layout_info);\n\n  widget_to_local(text_edit->widget, &point);\n\n  point.x = point.x - layout_info->margin_l + layout_info->ox;\n  point.y = point.y - layout_info->margin_t + layout_info->oy;\n\n  return point;\n}",
            "key_variables": [
               [
                  1121,
                  "evt->key"
               ],
               [
                  1133,
                  "text->size"
               ]
            ]
         },
         {
            "type": "func",
            "name": "text_edit_click",
            "line_range": [
               1087,
               1098
            ],
            "source_code": "ret_t text_edit_click(text_edit_t* text_edit, xy_t x, xy_t y) {\n  point_t point;\n  DECL_IMPL(text_edit);\n  return_value_if_fail(impl != NULL, RET_BAD_PARAMS);\n\n  widget_prepare_text_style(text_edit->widget, GET_CANVAS(text_edit));\n  point = text_edit_normalize_point(text_edit, x, y);\n  stb_textedit_click(text_edit, &(impl->state), point.x, point.y);\n  text_edit_layout(text_edit);\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  1166,
                  "evt->key"
               ],
               [
                  1167,
                  "text_edit->widget"
               ]
            ]
         },
         {
            "type": "func",
            "name": "text_edit_key_up",
            "line_range": [
               1157,
               1183
            ],
            "source_code": "ret_t text_edit_key_up(text_edit_t* text_edit, key_event_t* evt) {\n  uint32_t key = 0;\n  ret_t ret = RET_OK;\n  widget_t* widget = NULL;\n  input_method_t* im = input_method();\n  return_value_if_fail(im != NULL, RET_FAIL);\n  return_value_if_fail(text_edit != NULL && text_edit->widget != NULL && evt != NULL, RET_FAIL);\n\n  key = evt->key;\n  widget = text_edit->widget;\n  if (key == TK_KEY_OPEN_INPUT_METHOD) {\n    input_method_request(im, widget);\n    ret = RET_STOP;\n  } else if (key == TK_KEY_CLOSE_INPUT_METHOD) {\n    input_method_request(im, NULL);\n    ret = RET_STOP;\n  } else if (key == TK_KEY_TOGGLE_INPUT_METHOD) {\n    if (im->widget == widget) {\n      input_method_request(im, NULL);\n    } else {\n      input_method_request(im, widget);\n    }\n    ret = RET_STOP;\n  }\n\n  return ret;\n}",
            "key_variables": [
               [
                  1194,
                  "evt->key"
               ],
               [
                  1265,
                  "impl->line_height"
               ],
               [
                  1282,
                  "impl->line_height"
               ]
            ]
         },
         {
            "type": "func",
            "name": "text_edit_cut",
            "line_range": [
               1396,
               1405
            ],
            "source_code": "ret_t text_edit_cut(text_edit_t* text_edit) {\n  DECL_IMPL(text_edit);\n  return_value_if_fail(text_edit != NULL, RET_BAD_PARAMS);\n\n  if (text_edit_copy(text_edit) == RET_OK) {\n    stb_textedit_cut(text_edit, &(impl->state));\n  }\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  1429,
                  "text->size"
               ]
            ]
         },
         {
            "type": "func",
            "name": "text_edit_select_all",
            "line_range": [
               1517,
               1521
            ],
            "source_code": "ret_t text_edit_select_all(text_edit_t* text_edit) {\n  return_value_if_fail(text_edit != NULL, RET_BAD_PARAMS);\n\n  return text_edit_set_select(text_edit, 0, text_edit->widget->text.size);\n}",
            "key_variables": [
               [
                  1545,
                  "rows->size"
               ],
               [
                  1546,
                  "impl->max_chars"
               ],
               [
                  1547,
                  "impl->caret"
               ],
               [
                  1548,
                  "impl->preedit"
               ],
               [
                  1549,
                  "impl->line_height"
               ],
               [
                  1552,
                  "rows->capacity"
               ],
               [
                  1553,
                  "impl->last_row_number"
               ],
               [
                  1554,
                  "impl->last_line_number"
               ],
               [
                  1559,
                  "impl->mask"
               ],
               [
                  1560,
                  "impl->overwrite"
               ],
               [
                  1561,
                  "impl->wrap_word"
               ],
               [
                  1562,
                  "impl->mask_char"
               ],
               [
                  1563,
                  "impl->caret_visible"
               ],
               [
                  1564,
                  "impl->single_line"
               ]
            ]
         },
         {
            "type": "func",
            "name": "text_edit_preedit",
            "line_range": [
               1612,
               1620
            ],
            "source_code": "ret_t text_edit_preedit(text_edit_t* text_edit) {\n  DECL_IMPL(text_edit);\n  return_value_if_fail(text_edit != NULL, RET_BAD_PARAMS);\n\n  impl->preedit = TRUE;\n  impl->preedit_chars_nr = 0;\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  1640,
                  "impl->preedit_chars_nr"
               ]
            ]
         },
         {
            "type": "func",
            "name": "text_edit_preedit_abort",
            "line_range": [
               1646,
               1654
            ],
            "source_code": "ret_t text_edit_preedit_abort(text_edit_t* text_edit) {\n  DECL_IMPL(text_edit);\n  return_value_if_fail(text_edit != NULL, RET_BAD_PARAMS);\n\n  impl->preedit = FALSE;\n  text_edit_preedit_clear(text_edit);\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  1702,
                  "widget->text"
               ]
            ]
         },
         {
            "type": "func",
            "name": "text_edit_insert_wtext_with_len",
            "line_range": [
               1656,
               1678
            ],
            "source_code": "static ret_t text_edit_insert_wtext_with_len(text_edit_t* text_edit, uint32_t offset,\n                                             const wchar_t* wtext, uint32_t len) {\n  ret_t ret = RET_FAIL;\n  uint32_t size = 0;\n  return_value_if_fail(text_edit != NULL && text_edit->widget != NULL && wtext != NULL,\n                       RET_BAD_PARAMS);\n\n  size = wcslen(wtext);\n  len = tk_min(len, size);\n  offset = tk_min(offset, text_edit->widget->text.size);\n\n  ret = !!text_edit_insert(text_edit, offset, (wchar_t*)wtext, len) ? RET_OK : RET_SKIP;\n\n  if (ret == RET_OK) {\n    if (offset + len != text_edit_get_cursor(text_edit)) {\n      text_edit_set_cursor(text_edit, offset + len);\n    } else {\n      text_edit_layout(text_edit);\n    }\n  }\n\n  return ret;\n}",
            "key_variables": [
               [
                  1731,
                  "widget->text"
               ],
               [
                  1769,
                  "widget->text"
               ]
            ]
         }
      ],
      "src/base/theme.c": [
         {
            "type": "func",
            "name": "style_data_get",
            "line_range": [
               32,
               53
            ],
            "source_code": "static const style_name_value_t* style_data_get(const uint8_t* s, const char* name) {\n  uint32_t i = 0;\n  uint32_t nr = 0;\n  const uint8_t* p = s;\n\n  if (s == NULL) {\n    return NULL;\n  }\n\n  load_uint32(p, nr);\n  for (i = 0; i < nr; i++) {\n    const style_name_value_t* iter = (const style_name_value_t*)p;\n\n    if (tk_str_eq(iter->name, name)) {\n      return iter;\n    } else {\n      p += sizeof(style_name_value_header_t) + iter->name_size + iter->value_size;\n    }\n  }\n\n  return NULL;\n}",
            "key_variables": [
               [
                  49,
                  "iter->value_size"
               ],
               [
                  61,
                  "nv->name_size"
               ]
            ]
         },
         {
            "type": "func",
            "name": "style_data_get_uint",
            "line_range": [
               71,
               81
            ],
            "source_code": "uint32_t style_data_get_uint(const uint8_t* s, const char* name, uint32_t defval) {\n  uint32_t value = defval;\n  const style_name_value_t* nv = style_data_get(s, name);\n\n  if (nv != NULL && nv->type == VALUE_TYPE_UINT32) {\n    const uint8_t* p = (const uint8_t*)(nv->name) + nv->name_size;\n    load_uint32(p, value);\n  }\n\n  return value;\n}",
            "key_variables": [
               [
                  77,
                  "nv->name_size"
               ],
               [
                  88,
                  "nv->name_size"
               ]
            ]
         },
         {
            "type": "func",
            "name": "style_data_get_gradient",
            "line_range": [
               83,
               98
            ],
            "source_code": "gradient_t* style_data_get_gradient(const uint8_t* s, const char* name, gradient_t* gradient) {\n  const style_name_value_t* nv = style_data_get(s, name);\n\n  if (nv != NULL) {\n    const uint8_t* p = (const uint8_t*)(nv->name) + nv->name_size;\n    if (nv->type == VALUE_TYPE_GRADIENT) {\n      return gradient_init_from_binary(gradient, p, nv->value_size);\n    } else if (nv->type == VALUE_TYPE_UINT32 || nv->type == VALUE_TYPE_INT32) {\n      uint32_t value = 0;\n      load_uint32(p, value);\n      return gradient_init_simple(gradient, value);\n    }\n  }\n\n  return NULL;\n}",
            "key_variables": [
               [
                  106,
                  "nv->name_size"
               ]
            ]
         },
         {
            "type": "func",
            "name": "theme_find_style",
            "line_range": [
               111,
               138
            ],
            "source_code": "const uint8_t* theme_find_style(theme_t* theme, const char* widget_type, const char* name,\n                                const char* widget_state) {\n  return_value_if_fail(theme != NULL, NULL);\n  if (theme->find_style != NULL) {\n    return theme->find_style(theme, widget_type, name, widget_state);\n  } else {\n    uint32_t i = 0;\n    const theme_item_t* iter = NULL;\n    const theme_header_t* header = NULL;\n    return_value_if_fail(theme->data != NULL, NULL);\n\n    header = (const theme_header_t*)(theme->data);\n    if (name == NULL) {\n      name = TK_DEFAULT_STYLE;\n    }\n\n    iter = (const theme_item_t*)(theme->data + sizeof(theme_header_t));\n    for (i = 0; i < header->nr; i++) {\n      if (tk_str_eq(widget_type, iter->widget_type)) {\n        if (tk_str_eq(iter->state, widget_state) && tk_str_eq(iter->name, name)) {\n          return theme->data + iter->offset;\n        }\n      }\n      iter++;\n    }\n    return NULL;\n  }\n}",
            "key_variables": [
               [
                  129,
                  "header->nr"
               ],
               [
                  132,
                  "iter->offset"
               ]
            ]
         }
      ],
      "src/base/ui_loader.c": [
         {
            "type": "func",
            "name": "ui_loader_load_widget",
            "line_range": [
               35,
               37
            ],
            "source_code": "widget_t* ui_loader_load_widget(const char* name) {\n  return ui_loader_load_widget_with_parent(name, NULL);\n}",
            "key_variables": [
               [
                  41,
                  "rname[128]"
               ],
               [
                  61,
                  "builder->root"
               ]
            ]
         }
      ],
      "src/base/vgcanvas.c": [
         {
            "type": "func",
            "name": "vgcanvas_destroy_fbo",
            "line_range": [
               435,
               439
            ],
            "source_code": "ret_t vgcanvas_destroy_fbo(vgcanvas_t* vg, framebuffer_object_t* fbo) {\n  return_value_if_fail(vg != NULL && vg->vt->destroy_fbo != NULL && fbo != NULL, RET_BAD_PARAMS);\n\n  return vg->vt->destroy_fbo(vg, fbo);\n}",
            "key_variables": [
               [
                  462,
                  "vg->ratio"
               ],
               [
                  463,
                  "vg->ratio"
               ]
            ]
         },
         {
            "type": "func",
            "name": "vgcanvas_reinit",
            "line_range": [
               469,
               482
            ],
            "source_code": "ret_t vgcanvas_reinit(vgcanvas_t* vg, uint32_t w, uint32_t h, uint32_t stride,\n                      bitmap_format_t format, void* data) {\n  return_value_if_fail(vg != NULL && data != NULL, RET_BAD_PARAMS);\n\n  if (vg->w == w && vg->h == h && vg->buff == (uint32_t*)data) {\n    return RET_OK;\n  }\n\n  if (vg->vt->reinit != NULL) {\n    return vg->vt->reinit(vg, w, h, stride, format, data);\n  }\n\n  return RET_NOT_IMPL;\n}",
            "key_variables": [
               [
                  496,
                  "fbo->ratio"
               ],
               [
                  497,
                  "fbo->ratio"
               ]
            ]
         },
         {
            "type": "func",
            "name": "vgcanvas_cast",
            "line_range": [
               484,
               486
            ],
            "source_code": "vgcanvas_t* vgcanvas_cast(vgcanvas_t* vg) {\n  return vg;\n}",
            "key_variables": [
               [
                  520,
                  "vgcanvas->w"
               ],
               [
                  530,
                  "vgcanvas->h"
               ]
            ]
         }
      ],
      "src/base/widget.c": [
         {
            "type": "func",
            "name": "widget_real_create",
            "line_range": [
               173,
               181
            ],
            "source_code": "static widget_t* widget_real_create(const widget_vtable_t* vt) {\n  widget_t* widget = TKMEM_ALLOC(vt->size);\n  return_value_if_fail(widget != NULL, NULL);\n\n  memset(widget, 0x00, vt->size);\n  widget->vt = vt;\n\n  return widget;\n}",
            "key_variables": [
               [
                  185,
                  "vt->scrollable"
               ]
            ]
         },
         {
            "type": "func",
            "name": "widget_with_focus_state",
            "line_range": [
               187,
               194
            ],
            "source_code": "static bool_t widget_with_focus_state(widget_t* widget) {\n  value_t v;\n  return_value_if_fail(widget != NULL && widget->vt != NULL, FALSE);\n  value_set_bool(&v, FALSE);\n  widget_get_prop(widget, WIDGET_PROP_WITH_FOCUS_STATE, &v);\n\n  return value_bool(&v);\n}",
            "key_variables": [
               [
                  204,
                  "vt->focusable"
               ]
            ]
         },
         {
            "type": "func",
            "name": "widget_animate_value_to",
            "line_range": [
               285,
               295
            ],
            "source_code": "ret_t widget_animate_value_to(widget_t* widget, int32_t value, uint32_t duration) {\n  if (duration == 0) {\n    return widget_set_value(widget, value);\n  } else {\n    char params[64];\n    tk_snprintf(params, sizeof(params) - 1, \"value(to=%d, duration=%d)\", value, duration);\n\n    widget_destroy_animator(widget, \"value\");\n    return widget_create_animator(widget, params);\n  }\n}",
            "key_variables": [
               [
                  290,
                  "params[64]"
               ]
            ]
         },
         {
            "type": "func",
            "name": "widget_get_image_manager",
            "line_range": [
               420,
               435
            ],
            "source_code": "image_manager_t* widget_get_image_manager(widget_t* widget) {\n  image_manager_t* ret = image_manager();\n  return_value_if_fail(widget != NULL && widget->vt != NULL, ret);\n\n  if (tk_str_eq(widget->vt->type, WIDGET_TYPE_WINDOW_MANAGER)) {\n    ret = image_manager();\n  } else {\n    value_t v;\n    widget_t* win = widget_get_window(widget);\n    if (widget_get_prop(win, WIDGET_PROP_IMAGE_MANAGER, &v) == RET_OK) {\n      ret = (image_manager_t*)value_pointer(&v);\n    }\n  }\n\n  return ret;\n}",
            "key_variables": [
               [
                  460,
                  "widget->assets_manager"
               ]
            ]
         },
         {
            "type": "func",
            "name": "widget_set_animation",
            "line_range": [
               605,
               611
            ],
            "source_code": "ret_t widget_set_animation(widget_t* widget, const char* animation) {\n  return_value_if_fail(widget != NULL && animation != NULL, RET_BAD_PARAMS);\n\n  widget->animation = tk_str_copy(widget->animation, animation);\n\n  return widget_create_animator(widget, animation);\n}",
            "key_variables": [
               [
                  620,
                  "params[256]"
               ]
            ]
         },
         {
            "type": "func",
            "name": "widget_set_focusable",
            "line_range": [
               777,
               783
            ],
            "source_code": "ret_t widget_set_focusable(widget_t* widget, bool_t focusable) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  widget->focusable = focusable;\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  812,
                  "iter->parent"
               ]
            ]
         },
         {
            "type": "func",
            "name": "widget_add_child",
            "line_range": [
               939,
               973
            ],
            "source_code": "ret_t widget_add_child(widget_t* widget, widget_t* child) {\n  event_t e = event_init(EVT_WIDGET_ADD_CHILD, widget);\n  return_value_if_fail(widget != NULL && child != NULL && child->parent == NULL, RET_BAD_PARAMS);\n\n  child->parent = widget;\n\n  if (widget->children == NULL) {\n    widget->children = darray_create(4, NULL, NULL);\n  }\n\n  if (widget->vt->on_add_child) {\n    if (widget->vt->on_add_child(widget, child) == RET_OK) {\n      return RET_OK;\n    }\n  }\n\n  if (child->vt->on_attach_parent) {\n    child->vt->on_attach_parent(child, widget);\n  }\n\n  ENSURE(darray_push(widget->children, child) == RET_OK);\n\n  if (!widget_is_window_manager(widget)) {\n    widget_set_need_relayout_children(widget);\n  }\n\n  if (!(child->initializing) && widget_get_window(child) != NULL) {\n    widget_set_need_update_style_recursive(child);\n    widget_update_style_object_recursive(child);\n  }\n\n  widget_dispatch(widget, &e);\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  1056,
                  "children[i - 1]"
               ],
               [
                  1060,
                  "children[i + 1]"
               ]
            ]
         },
         {
            "type": "func",
            "name": "widget_remove_child",
            "line_range": [
               1011,
               1024
            ],
            "source_code": "ret_t widget_remove_child(widget_t* widget, widget_t* child) {\n  ret_t ret = RET_OK;\n  event_t e = event_init(EVT_WIDGET_REMOVE_CHILD, widget);\n  return_value_if_fail(widget != NULL && child != NULL, RET_BAD_PARAMS);\n\n  widget_remove_child_prepare(widget, child);\n  ret = darray_remove(widget->children, child);\n\n  if (ret == RET_OK) {\n    widget_dispatch(widget, &e);\n  }\n\n  return ret;\n}",
            "key_variables": [
               [
                  1089,
                  "win->key_target"
               ],
               [
                  1090,
                  "win->key_target"
               ]
            ]
         },
         {
            "type": "func",
            "name": "widget_find_target",
            "line_range": [
               1198,
               1209
            ],
            "source_code": "widget_t* widget_find_target(widget_t* widget, xy_t x, xy_t y) {\n  widget_t* ret = NULL;\n  return_value_if_fail(widget != NULL, NULL);\n\n  if (widget->vt && widget->vt->find_target) {\n    ret = widget->vt->find_target(widget, x, y);\n  } else {\n    ret = widget_find_target_default(widget, x, y);\n  }\n\n  return ret;\n}",
            "key_variables": [
               [
                  1225,
                  "widget->pointer_cursor"
               ],
               [
                  1227,
                  "vt->pointer_cursor"
               ]
            ]
         },
         {
            "type": "func",
            "name": "widget_get_pointer_cursor",
            "line_range": [
               1222,
               1230
            ],
            "source_code": "static const char* widget_get_pointer_cursor(widget_t* widget) {\n  if (widget->pointer_cursor != NULL) {\n    return widget->pointer_cursor;\n  } else if (widget->vt->pointer_cursor != NULL) {\n    return widget->vt->pointer_cursor;\n  }\n\n  return WIDGET_CURSOR_DEFAULT;\n}",
            "key_variables": [
               [
                  1257,
                  "e->target"
               ]
            ]
         },
         {
            "type": "func",
            "name": "widget_off_by_func",
            "line_range": [
               1349,
               1357
            ],
            "source_code": "ret_t widget_off_by_func(widget_t* widget, uint32_t type, event_func_t on_event, void* ctx) {\n  return_value_if_fail(widget != NULL && on_event != NULL, RET_BAD_PARAMS);\n\n  if (widget->emitter == NULL) {\n    return RET_OK;\n  }\n\n  return emitter_off_by_func(widget->emitter, type, on_event, ctx);\n}",
            "key_variables": [
               [
                  1439,
                  "widget->astyle"
               ],
               [
                  1466,
                  "c->font_size"
               ]
            ]
         },
         {
            "type": "func",
            "name": "widget_calc_icon_text_rect",
            "line_range": [
               1359,
               1411
            ],
            "source_code": "ret_t widget_calc_icon_text_rect(const rect_t* ir, int32_t font_size, float_t text_size,\n                                 int32_t icon_at, uint32_t img_w, uint32_t img_h, int32_t spacer,\n                                 rect_t* r_text, rect_t* r_icon) {\n  return_value_if_fail(ir != NULL && (r_text != NULL || r_icon != NULL), RET_BAD_PARAMS);\n\n  if (r_icon == NULL) {\n    *r_text = *ir;\n\n    return RET_OK;\n  }\n\n  if (r_text == NULL) {\n    *r_icon = *ir;\n\n    return RET_OK;\n  }\n\n  return_value_if_fail(spacer < ir->h && spacer < ir->w, RET_BAD_PARAMS);\n  switch (icon_at) {\n    case ICON_AT_CENTRE: {\n      int32_t w = ir->w - spacer - text_size - img_w;\n      int32_t icon_h = ir->h - img_h;\n      *r_text = rect_init(ir->x + img_w + spacer + w / 2, ir->y, text_size, ir->h);\n      *r_icon = rect_init(ir->x + w / 2, ir->y + icon_h / 2, img_w, img_h);\n      break;\n    }\n    case ICON_AT_RIGHT: {\n      *r_icon = rect_init(ir->x + ir->w - ir->h, ir->y, ir->h, ir->h);\n      *r_text = rect_init(ir->x, ir->y, ir->w - ir->h - spacer, ir->h);\n      break;\n    }\n    case ICON_AT_TOP: {\n      int32_t icon_h = ir->h - font_size - spacer;\n      *r_icon = rect_init(ir->x, ir->y, ir->w, icon_h);\n      *r_text = rect_init(ir->x, icon_h + spacer, ir->w, font_size);\n      break;\n    }\n    case ICON_AT_BOTTOM: {\n      int32_t icon_h = ir->h - font_size - spacer;\n      *r_icon = rect_init(ir->x, ir->y + ir->h - icon_h, ir->w, icon_h);\n      *r_text = rect_init(ir->x, ir->y, ir->w, font_size);\n      break;\n    }\n    case ICON_AT_LEFT:\n    default: {\n      *r_icon = rect_init(ir->x, ir->y, ir->h, ir->h);\n      *r_text = rect_init(ir->x + ir->h + spacer, ir->y, ir->w - ir->h - spacer, ir->h);\n      break;\n    }\n  }\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  1513,
                  "widget->astyle"
               ],
               [
                  1551,
                  "name[MAX_PATH + 1]"
               ],
               [
                  1587,
                  "r->w"
               ],
               [
                  1588,
                  "r->h"
               ]
            ]
         },
         {
            "type": "func",
            "name": "widget_fill_rect",
            "line_range": [
               1507,
               1582
            ],
            "source_code": "ret_t widget_fill_rect(widget_t* widget, canvas_t* c, const rect_t* r, bool_t bg,\n                       image_draw_type_t draw_type) {\n  bitmap_t img;\n  ret_t ret = RET_OK;\n  gradient_t agradient;\n  style_t* style = widget->astyle;\n  uint32_t radius = style_get_int(style, STYLE_ID_ROUND_RADIUS, 0);\n  const char* color_key = bg ? STYLE_ID_BG_COLOR : STYLE_ID_FG_COLOR;\n  const char* image_key = bg ? STYLE_ID_BG_IMAGE : STYLE_ID_FG_IMAGE;\n  rect_t bg_r = rect_init(widget->x, widget->y, widget->w, widget->h);\n  uint32_t radius_tl = style_get_int(style, STYLE_ID_ROUND_RADIUS_TOP_LETF, radius);\n  uint32_t radius_tr = style_get_int(style, STYLE_ID_ROUND_RADIUS_TOP_RIGHT, radius);\n  uint32_t radius_bl = style_get_int(style, STYLE_ID_ROUND_RADIUS_BOTTOM_LETF, radius);\n  uint32_t radius_br = style_get_int(style, STYLE_ID_ROUND_RADIUS_BOTTOM_RIGHT, radius);\n  const char* draw_type_key = bg ? STYLE_ID_BG_IMAGE_DRAW_TYPE : STYLE_ID_FG_IMAGE_DRAW_TYPE;\n  gradient_t* gradient = style_get_gradient(style, color_key, &agradient);\n  const char* image_name = style_get_str(style, image_key, NULL);\n\n  if (gradient != NULL && r->w > 0 && r->h > 0) {\n    color_t color = gradient_get_first_color(gradient);\n    canvas_set_fill_color(c, color);\n    if (gradient->nr > 1 || color.rgba.a) {\n      if (radius_tl > 3 || radius_tr > 3 || radius_bl > 3 || radius_br > 3) {\n        /*TODO: support gradient*/\n        if (bg) {\n          ret = canvas_fill_rounded_rect_gradient_ex(c, r, NULL, gradient, radius_tl, radius_tr, radius_bl,\n                                            radius_br);\n        } else {\n          ret = canvas_fill_rounded_rect_gradient_ex(c, r, &bg_r, gradient, radius_tl, radius_tr, radius_bl,\n                                            radius_br);\n        }\n        if (ret == RET_FAIL) {\n          canvas_fill_rect(c, r->x, r->y, r->w, r->h);\n        }\n      } else if (gradient->nr > 1) {\n        canvas_fill_rect_gradient(c, r->x, r->y, r->w, r->h, gradient);\n      } else {\n        canvas_fill_rect(c, r->x, r->y, r->w, r->h);\n      }\n    }\n  }\n\n  if (image_name != NULL && *image_name && r->w > 0 && r->h > 0) {\n    char name[MAX_PATH + 1];\n    const char* region = strrchr(image_name, '#');\n    if (region != NULL) {\n      memset(name, 0x00, sizeof(name));\n      tk_strncpy(name, image_name, region - image_name);\n      image_name = name;\n    }\n\n    if (widget_load_image(widget, image_name, &img) == RET_OK) {\n      draw_type = (image_draw_type_t)style_get_int(style, draw_type_key, draw_type);\n\n      if (region == NULL) {\n        canvas_draw_image_ex(c, &img, draw_type, r);\n      } else {\n        rect_t src;\n        rect_t dst = *r;\n        if (tk_str_eq(region, \"#\")) {\n          src = rect_init(widget->x, widget->y, widget->w, widget->h);\n        } else if (tk_str_eq(region, \"#g\")) {\n          point_t p = {widget->x, widget->y};\n          widget_to_global(widget, &p);\n          src = rect_init(p.x, p.y, widget->w, widget->h);\n        } else {\n          image_region_parse(img.w, img.h, region, &src);\n        }\n\n        canvas_draw_image_ex2(c, &img, draw_type, &src, &dst);\n      }\n    }\n  }\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  1622,
                  "widget->astyle"
               ]
            ]
         },
         {
            "type": "func",
            "name": "widget_fill_bg_rect",
            "line_range": [
               1656,
               1659
            ],
            "source_code": "ret_t widget_fill_bg_rect(widget_t* widget, canvas_t* c, const rect_t* r,\n                          image_draw_type_t draw_type) {\n  return widget_fill_rect(widget, c, r, TRUE, draw_type);\n}",
            "key_variables": [
               [
                  1684,
                  "widget->x"
               ],
               [
                  1685,
                  "widget->y"
               ],
               [
                  1686,
                  "c->global_alpha"
               ]
            ]
         },
         {
            "type": "func",
            "name": "widget_on_paint_done",
            "line_range": [
               2249,
               2258
            ],
            "source_code": "static ret_t widget_on_paint_done(widget_t* widget, canvas_t* c) {\n  paint_event_t e;\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && c != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->vt != NULL, RET_BAD_PARAMS);\n\n  widget_dispatch(widget, paint_event_init(&e, EVT_PAINT_DONE, widget, c));\n\n  return ret;\n}",
            "key_variables": [
               [
                  2300,
                  "fixed_name[TK_NAME_LEN + 1]"
               ],
               [
                  2317,
                  "kv->value"
               ]
            ]
         },
         {
            "type": "func",
            "name": "widget_on_keydown_before_children",
            "line_range": [
               2341,
               2351
            ],
            "source_code": "static ret_t widget_on_keydown_before_children(widget_t* widget, key_event_t* e) {\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n\n  if (widget->emitter != NULL) {\n    key_event_t before = *e;\n    before.e.type = EVT_KEY_DOWN_BEFORE_CHILDREN;\n    return_value_if_equal(emitter_dispatch(widget->emitter, (event_t*)&(before)), RET_STOP);\n  }\n\n  return widget_on_event_before_children(widget, (event_t*)e);\n}",
            "key_variables": [
               [
                  2383,
                  "e->key"
               ]
            ]
         },
         {
            "type": "func",
            "name": "widget_is_move_focus_down_key",
            "line_range": [
               2434,
               2436
            ],
            "source_code": "static bool_t widget_is_move_focus_down_key(widget_t* widget, key_event_t* e) {\n  return widget_match_key(widget, WIDGET_PROP_MOVE_FOCUS_DOWN_KEY, e);\n}",
            "key_variables": [
               [
                  2514,
                  "e->key"
               ]
            ]
         },
         {
            "type": "func",
            "name": "widget_on_keyup_after_children",
            "line_range": [
               2559,
               2568
            ],
            "source_code": "static ret_t widget_on_keyup_after_children(widget_t* widget, key_event_t* e) {\n  ret_t ret = RET_OK;\n\n  return_value_if_equal(ret = widget_dispatch(widget, (event_t*)e), RET_STOP);\n  if (widget->vt->on_keyup) {\n    ret = widget->vt->on_keyup(widget, e);\n  }\n\n  return ret;\n}",
            "key_variables": [
               [
                  2625,
                  "e->key"
               ]
            ]
         },
         {
            "type": "func",
            "name": "widget_on_wheel",
            "line_range": [
               2684,
               2693
            ],
            "source_code": "ret_t widget_on_wheel(widget_t* widget, wheel_event_t* e) {\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n\n  widget_ref(widget);\n  ret = widget_on_wheel_impl(widget, e);\n  widget_unref(widget);\n\n  return ret;\n}",
            "key_variables": [
               [
                  2724,
                  "curr->target"
               ]
            ]
         },
         {
            "type": "func",
            "name": "widget_on_multi_gesture",
            "line_range": [
               2695,
               2712
            ],
            "source_code": "ret_t widget_on_multi_gesture(widget_t* widget, multi_gesture_event_t* e) {\n  ret_t ret = RET_OK;\n  widget_t* target = NULL;\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n\n  widget_ref(widget);\n  target = widget_find_target(widget, e->x, e->y);\n  if (target != NULL) {\n    ret = widget_dispatch(target, (event_t*)e);\n  }\n\n  if (ret != RET_STOP) {\n    ret = widget_dispatch(widget, (event_t*)e);\n  }\n  widget_unref(widget);\n\n  return ret;\n}",
            "key_variables": [
               [
                  2748,
                  "target->key_target"
               ]
            ]
         },
         {
            "type": "func",
            "name": "widget_dispatch_leave_event",
            "line_range": [
               2714,
               2728
            ],
            "source_code": "static ret_t widget_dispatch_leave_event(widget_t* widget, pointer_event_t* e) {\n  widget_t* target = widget;\n\n  while (target != NULL) {\n    widget_t* curr = target;\n    pointer_event_t leave = *e;\n    leave.e.type = EVT_POINTER_LEAVE;\n\n    widget_dispatch(target, (event_t*)(&leave));\n    target = curr->target;\n    curr->target = NULL;\n  }\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  2760,
                  "widget->target"
               ],
               [
                  2763,
                  "target->key_target"
               ]
            ]
         },
         {
            "type": "func",
            "name": "widget_on_context_menu",
            "line_range": [
               3031,
               3040
            ],
            "source_code": "ret_t widget_on_context_menu(widget_t* widget, pointer_event_t* e) {\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && e != NULL, RET_BAD_PARAMS);\n\n  widget_ref(widget);\n  ret = widget_on_context_menu_impl(widget, e);\n  widget_unref(widget);\n\n  return ret;\n}",
            "key_variables": [
               [
                  3108,
                  "iter->parent"
               ]
            ]
         },
         {
            "type": "func",
            "name": "widget_grab",
            "line_range": [
               3042,
               3058
            ],
            "source_code": "ret_t widget_grab(widget_t* widget, widget_t* child) {\n  return_value_if_fail(widget != NULL && child != NULL && widget->vt != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->grab_widget == NULL || widget->grab_widget == child, RET_BAD_PARAMS);\n\n  if (widget->grab_widget == NULL) {\n    widget->grab_widget = child;\n    widget->grab_widget_count = 1;\n  } else {\n    widget->grab_widget_count++;\n  }\n\n  if (widget->parent) {\n    widget_grab(widget->parent, widget);\n  }\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  3122,
                  "iter->parent"
               ]
            ]
         },
         {
            "type": "func",
            "name": "widget_ungrab",
            "line_range": [
               3060,
               3078
            ],
            "source_code": "ret_t widget_ungrab(widget_t* widget, widget_t* child) {\n  return_value_if_fail(widget != NULL && widget->vt != NULL, RET_BAD_PARAMS);\n\n  if (widget->grab_widget == child) {\n    if (widget->grab_widget->grab_widget_count < widget->grab_widget_count) {\n      widget->grab_widget_count--;\n      if (widget->grab_widget_count <= 0) {\n        widget->grab_widget = NULL;\n        widget->grab_widget_count = 0;\n      }\n\n      if (widget->parent) {\n        widget_ungrab(widget->parent, widget);\n      }\n    }\n  }\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  3136,
                  "iter->parent"
               ]
            ]
         },
         {
            "type": "func",
            "name": "widget_destroy",
            "line_range": [
               3207,
               3216
            ],
            "source_code": "ret_t widget_destroy(widget_t* widget) {\n  return_value_if_fail(widget != NULL && widget->ref_count > 0 && widget->vt != NULL,\n                       RET_BAD_PARAMS);\n\n  if (widget->parent != NULL) {\n    widget_remove_child(widget->parent, widget);\n  }\n\n  return widget_unref_async(widget);\n}",
            "key_variables": [
               [
                  3235,
                  "widget->parent"
               ],
               [
                  3243,
                  "iter->parent"
               ]
            ]
         },
         {
            "type": "func",
            "name": "widget_invalidate_force",
            "line_range": [
               3271,
               3276
            ],
            "source_code": "ret_t widget_invalidate_force(widget_t* widget, const rect_t* r) {\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  widget->dirty = FALSE;\n  return widget_invalidate(widget, NULL);\n}",
            "key_variables": [
               [
                  3414,
                  "iter->x"
               ],
               [
                  3415,
                  "iter->y"
               ],
               [
                  3417,
                  "iter->parent"
               ]
            ]
         },
         {
            "type": "func",
            "name": "widget_get_prop_default_value",
            "line_range": [
               3334,
               3390
            ],
            "source_code": "ret_t widget_get_prop_default_value(widget_t* widget, const char* name, value_t* v) {\n  ret_t ret = RET_OK;\n  return_value_if_fail(widget != NULL && name != NULL && v != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(widget->vt != NULL, RET_BAD_PARAMS);\n\n  if (tk_str_eq(name, WIDGET_PROP_X)) {\n    value_set_int32(v, 0);\n  } else if (tk_str_eq(name, WIDGET_PROP_Y)) {\n    value_set_int32(v, 0);\n  } else if (tk_str_eq(name, WIDGET_PROP_W)) {\n    value_set_int32(v, 0);\n  } else if (tk_str_eq(name, WIDGET_PROP_H)) {\n    value_set_int32(v, 0);\n  } else if (tk_str_eq(name, WIDGET_PROP_OPACITY)) {\n    value_set_int32(v, 0xff);\n  } else if (tk_str_eq(name, WIDGET_PROP_VISIBLE)) {\n    value_set_bool(v, TRUE);\n  } else if (tk_str_eq(name, WIDGET_PROP_SENSITIVE)) {\n    value_set_bool(v, TRUE);\n  } else if (tk_str_eq(name, WIDGET_PROP_FLOATING)) {\n    value_set_bool(v, FALSE);\n  } else if (tk_str_eq(name, WIDGET_PROP_FOCUSABLE)) {\n    value_set_bool(v, FALSE);\n  } else if (tk_str_eq(name, WIDGET_PROP_WITH_FOCUS_STATE)) {\n    value_set_bool(v, FALSE);\n  } else if (tk_str_eq(name, WIDGET_PROP_DIRTY_RECT_TOLERANCE)) {\n    value_set_int(v, 4);\n  } else if (tk_str_eq(name, WIDGET_PROP_STYLE)) {\n    value_set_str(v, NULL);\n  } else if (tk_str_eq(name, WIDGET_PROP_ENABLE)) {\n    value_set_bool(v, TRUE);\n  } else if (tk_str_eq(name, WIDGET_PROP_NAME)) {\n    value_set_str(v, NULL);\n  } else if (tk_str_eq(name, WIDGET_PROP_TEXT)) {\n    value_set_wstr(v, NULL);\n  } else if (tk_str_eq(name, WIDGET_PROP_ANIMATION)) {\n    value_set_str(v, NULL);\n  } else if (tk_str_eq(name, WIDGET_PROP_SELF_LAYOUT)) {\n    value_set_str(v, NULL);\n  } else if (tk_str_eq(name, WIDGET_PROP_CHILDREN_LAYOUT)) {\n    value_set_str(v, NULL);\n  } else if (tk_str_eq(name, WIDGET_PROP_FOCUSED)) {\n    value_set_bool(v, FALSE);\n  } else if (tk_str_eq(name, WIDGET_PROP_FEEDBACK)) {\n    value_set_bool(v, FALSE);\n  } else if (tk_str_eq(name, WIDGET_PROP_AUTO_ADJUST_SIZE)) {\n    value_set_bool(v, FALSE);\n  } else {\n    if (widget->vt->get_prop_default_value) {\n      ret = widget->vt->get_prop_default_value(widget, name, v);\n    } else {\n      ret = RET_NOT_FOUND;\n    }\n  }\n\n  return ret;\n}",
            "key_variables": [
               [
                  3439,
                  "iter->x"
               ],
               [
                  3440,
                  "iter->y"
               ],
               [
                  3442,
                  "iter->parent"
               ]
            ]
         },
         {
            "type": "func",
            "name": "widget_get_offset",
            "line_range": [
               3392,
               3400
            ],
            "source_code": "static ret_t widget_get_offset(widget_t* widget, xy_t* out_x, xy_t* out_y) {\n  return_value_if_fail(widget != NULL && out_x != NULL && out_y != NULL, RET_BAD_PARAMS);\n  *out_x = 0;\n  *out_y = 0;\n  if (widget->vt != NULL && widget->vt->get_offset != NULL) {\n    return widget->vt->get_offset(widget, out_x, out_y);\n  }\n  return RET_OK;\n}",
            "key_variables": [
               [
                  3453,
                  "iter->x"
               ],
               [
                  3454,
                  "iter->y"
               ],
               [
                  3456,
                  "iter->parent"
               ]
            ]
         },
         {
            "type": "func",
            "name": "widget_count_children",
            "line_range": [
               3461,
               3465
            ],
            "source_code": "int32_t widget_count_children(widget_t* widget) {\n  return_value_if_fail(widget != NULL, 0);\n\n  return widget->children != NULL ? widget->children->size : 0;\n}",
            "key_variables": [
               [
                  3481,
                  "widget->parent"
               ],
               [
                  3492,
                  "widget->astyle"
               ]
            ]
         },
         {
            "type": "func",
            "name": "widget_index_of",
            "line_range": [
               3476,
               3488
            ],
            "source_code": "int32_t widget_index_of(widget_t* widget) {\n  widget_t* parent = NULL;\n  return_value_if_fail(widget != NULL && widget->parent != NULL, -1);\n\n  parent = widget->parent;\n  WIDGET_FOR_EACH_CHILD_BEGIN(parent, iter, i)\n  if (iter == widget) {\n    return i;\n  }\n  WIDGET_FOR_EACH_CHILD_END();\n\n  return -1;\n}",
            "key_variables": [
               [
                  3557,
                  "other->enable"
               ],
               [
                  3558,
                  "other->visible"
               ],
               [
                  3559,
                  "other->floating"
               ],
               [
                  3560,
                  "other->opacity"
               ],
               [
                  3561,
                  "other->feedback"
               ],
               [
                  3562,
                  "other->auto_adjust_size"
               ],
               [
                  3563,
                  "other->focusable"
               ],
               [
                  3564,
                  "other->sensitive"
               ],
               [
                  3565,
                  "other->auto_created"
               ],
               [
                  3566,
                  "other->with_focus_state"
               ],
               [
                  3567,
                  "other->dirty_rect_tolerance"
               ]
            ]
         },
         {
            "type": "func",
            "name": "widget_get_persistent_props",
            "line_range": [
               3539,
               3541
            ],
            "source_code": "const char* const* widget_get_persistent_props(void) {\n  return s_widget_persistent_props;\n}",
            "key_variables": [
               [
                  3652,
                  "vt->clone_properties"
               ],
               [
                  3658,
                  "properties[i]"
               ]
            ]
         },
         {
            "type": "func",
            "name": "widget_load_asset_ex",
            "line_range": [
               3746,
               3752
            ],
            "source_code": "const asset_info_t* widget_load_asset_ex(widget_t* widget, asset_type_t type, uint16_t subtype,\n                                         const char* name) {\n  assets_manager_t* am = widget_get_assets_manager(widget);\n  return_value_if_fail(widget != NULL && name != NULL && am != NULL, NULL);\n\n  return assets_manager_ref_ex(am, type, subtype, name);\n}",
            "key_variables": [
               [
                  3791,
                  "widget->vt"
               ],
               [
                  3797,
                  "iter->parent"
               ]
            ]
         },
         {
            "type": "func",
            "name": "widget_unload_asset",
            "line_range": [
               3754,
               3759
            ],
            "source_code": "ret_t widget_unload_asset(widget_t* widget, const asset_info_t* asset) {\n  assets_manager_t* am = widget_get_assets_manager(widget);\n  return_value_if_fail(widget != NULL && asset != NULL && am != NULL, RET_BAD_PARAMS);\n\n  return assets_manager_unref(am, asset);\n}",
            "key_variables": [
               [
                  3837,
                  "scroll_view->h"
               ],
               [
                  3841,
                  "scroll_view->w"
               ],
               [
                  3859,
                  "widget->parent"
               ],
               [
                  3866,
                  "parent->parent"
               ]
            ]
         },
         {
            "type": "func",
            "name": "widget_ensure_visible_in_viewport",
            "line_range": [
               3854,
               3869
            ],
            "source_code": "ret_t widget_ensure_visible_in_viewport(widget_t* widget) {\n  widget_t* parent = NULL;\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  parent = widget->parent;\n  while (parent != NULL) {\n    if (widget_is_scrollable(parent)) {\n      widget_ensure_visible_in_scroll_view(parent, widget);\n      break;\n    }\n\n    parent = parent->parent;\n  }\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  3878,
                  "widget->parent"
               ]
            ]
         },
         {
            "type": "func",
            "name": "widget_get_all_focusable_widgets_in_window",
            "line_range": [
               3941,
               3948
            ],
            "source_code": "static ret_t widget_get_all_focusable_widgets_in_window(widget_t* widget, darray_t* all_focusable) {\n  widget_t* win = widget_get_window_or_keyboard(widget);\n  return_value_if_fail(win != NULL, RET_BAD_PARAMS);\n\n  widget_foreach(win, widget_on_visit_focusable, all_focusable);\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  3972,
                  "win->key_target"
               ],
               [
                  3978,
                  "iter->key_target"
               ]
            ]
         },
         {
            "type": "func",
            "name": "widget_get_first_focusable_widget_in_window",
            "line_range": [
               3950,
               3964
            ],
            "source_code": "static widget_t* widget_get_first_focusable_widget_in_window(widget_t* widget) {\n  widget_t* first = NULL;\n  darray_t all_focusable;\n  widget_t* win = widget_get_window(widget);\n  return_value_if_fail(win != NULL, first);\n\n  darray_init(&all_focusable, 10, NULL, NULL);\n  widget_foreach(win, widget_on_visit_focusable, &all_focusable);\n  if (all_focusable.size > 0) {\n    first = WIDGET(all_focusable.elms[0]);\n  }\n  darray_deinit(&all_focusable);\n\n  return first;\n}",
            "key_variables": [
               [
                  3996,
                  "all_focusable->size"
               ]
            ]
         },
         {
            "type": "func",
            "name": "widget_has_focused_widget_in_window",
            "line_range": [
               3966,
               3981
            ],
            "source_code": "bool_t widget_has_focused_widget_in_window(widget_t* widget) {\n  widget_t* iter = NULL;\n  widget_t* win = widget_get_window(widget);\n  return_value_if_fail(win != NULL, FALSE);\n\n  iter = win->key_target;\n  while (iter != NULL) {\n    if (widget_is_focusable(iter) && iter->focused) {\n      return TRUE;\n    }\n\n    iter = iter->key_target;\n  }\n\n  return FALSE;\n}",
            "key_variables": [
               [
                  4011,
                  "all_focusable->size"
               ]
            ]
         },
         {
            "type": "func",
            "name": "is_same_col",
            "line_range": [
               4030,
               4035
            ],
            "source_code": "static bool_t is_same_col(const rect_t* r1, const rect_t* r2) {\n  int32_t cx1 = r1->x + r1->w / 2;\n  int32_t cx2 = r2->x + r2->w / 2;\n\n  return (cx2 >= r1->x && cx2 < (r1->x + r1->w)) || (cx1 >= r2->x && cx1 < (r2->x + r2->w));\n}",
            "key_variables": [
               [
                  4080,
                  "last_matched->y"
               ]
            ]
         },
         {
            "type": "func",
            "name": "match_up",
            "line_range": [
               4044,
               4064
            ],
            "source_code": "static bool_t match_up(const rect_t* widget, const rect_t* last_matched, const rect_t* iter) {\n  if ((iter->y + iter->h / 2) > widget->y) {\n    return FALSE;\n  }\n\n  if (last_matched == NULL) {\n    return TRUE;\n  }\n\n  if (is_same_col(widget, iter)) {\n    if (!is_same_col(widget, last_matched)) {\n      return TRUE;\n    } else {\n      return (iter->y + iter->h) > (last_matched->y + last_matched->h);\n    }\n  } else if (is_same_col(widget, last_matched)) {\n    return FALSE;\n  } else {\n    return distance2(widget, iter) < distance2(widget, last_matched);\n  }\n}",
            "key_variables": [
               [
                  4124,
                  "last_matched->x"
               ],
               [
                  4148,
                  "all_focusable->size"
               ]
            ]
         },
         {
            "type": "func",
            "name": "widget_focus_up",
            "line_range": [
               4217,
               4219
            ],
            "source_code": "ret_t widget_focus_up(widget_t* widget) {\n  return widget_move_focus(widget, widget_find_up_focus_widget);\n}",
            "key_variables": [
               [
                  4245,
                  "vt->is_window"
               ],
               [
                  4251,
                  "vt->is_designing_window"
               ]
            ]
         },
         {
            "type": "func",
            "name": "widget_focus_right",
            "line_range": [
               4233,
               4239
            ],
            "source_code": "ret_t widget_focus_right(widget_t* widget) {\n  if (widget_move_focus(widget, widget_find_right_focus_widget) == RET_OK) {\n    return RET_OK;\n  } else {\n    return widget_focus_down(widget);\n  }\n}",
            "key_variables": [
               [
                  4257,
                  "vt->is_window_manager"
               ]
            ]
         },
         {
            "type": "func",
            "name": "widget_is_designing_window",
            "line_range": [
               4247,
               4251
            ],
            "source_code": "bool_t widget_is_designing_window(widget_t* widget) {\n  return_value_if_fail(widget != NULL && widget->vt != NULL, FALSE);\n\n  return widget->vt->is_designing_window;\n}",
            "key_variables": [
               [
                  4291,
                  "str[256]"
               ]
            ]
         },
         {
            "type": "func",
            "name": "widget_close_window",
            "line_range": [
               4466,
               4471
            ],
            "source_code": "ret_t widget_close_window(widget_t* widget) {\n  widget_t* win = widget_get_window(widget);\n  return_value_if_fail(win != NULL, RET_BAD_PARAMS);\n\n  return window_manager_close_window(win->parent, win);\n}",
            "key_variables": [
               [
                  4526,
                  "r->w"
               ],
               [
                  4527,
                  "r->h"
               ]
            ]
         },
         {
            "type": "func",
            "name": "widget_close_window_force",
            "line_range": [
               4473,
               4478
            ],
            "source_code": "ret_t widget_close_window_force(widget_t* widget) {\n  widget_t* win = widget_get_window(widget);\n  return_value_if_fail(win != NULL, RET_BAD_PARAMS);\n\n  return window_manager_close_window_force(win->parent, win);\n}",
            "key_variables": [
               [
                  4562,
                  "widget->w"
               ],
               [
                  4563,
                  "widget->h"
               ]
            ]
         },
         {
            "type": "func",
            "name": "widget_take_snapshot",
            "line_range": [
               4597,
               4599
            ],
            "source_code": "bitmap_t* widget_take_snapshot(widget_t* widget) {\n  return widget_take_snapshot_rect(widget, NULL);\n}",
            "key_variables": [
               [
                  4625,
                  "text[128]"
               ]
            ]
         },
         {
            "type": "func",
            "name": "widget_dispatch_simple_event",
            "line_range": [
               4601,
               4606
            ],
            "source_code": "ret_t widget_dispatch_simple_event(widget_t* widget, uint32_t type) {\n  event_t e = event_init(type, widget);\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  return widget_dispatch(widget, &e);\n}",
            "key_variables": [
               [
                  4637,
                  "text[128]"
               ]
            ]
         },
         {
            "type": "func",
            "name": "widget_set_child_text_with_double",
            "line_range": [
               4622,
               4632
            ],
            "source_code": "ret_t widget_set_child_text_with_double(widget_t* widget, const char* name, const char* format,\n                                        double value) {\n  char text[128];\n  widget_t* child = widget_lookup(widget, name, TRUE);\n  return_value_if_fail(child != NULL && format != NULL, RET_BAD_PARAMS);\n\n  memset(text, 0x00, sizeof(text));\n  tk_snprintf(text, sizeof(text) - 1, format, value);\n\n  return widget_set_text_utf8(child, text);\n}",
            "key_variables": [
               [
                  4671,
                  "child->parent"
               ],
               [
                  4676,
                  "iter->parent"
               ]
            ]
         },
         {
            "type": "func",
            "name": "widget_set_child_text_with_int",
            "line_range": [
               4634,
               4644
            ],
            "source_code": "ret_t widget_set_child_text_with_int(widget_t* widget, const char* name, const char* format,\n                                     int value) {\n  char text[128];\n  widget_t* child = widget_lookup(widget, name, TRUE);\n  return_value_if_fail(child != NULL && format != NULL, RET_BAD_PARAMS);\n\n  memset(text, 0x00, sizeof(text));\n  tk_snprintf(text, sizeof(text) - 1, format, value);\n\n  return widget_set_text_utf8(child, text);\n}",
            "key_variables": [
               [
                  4691,
                  "widget->enable"
               ]
            ]
         },
         {
            "type": "func",
            "name": "widget_draw_text_in_rect",
            "line_range": [
               4658,
               4664
            ],
            "source_code": "ret_t widget_draw_text_in_rect(widget_t* widget, canvas_t* c, const wchar_t* str, uint32_t size,\n                               const rect_t* r, bool_t ellipses) {\n  const char* bidi_type = widget_get_bidi(widget);\n  return_value_if_fail(widget != NULL && c != NULL && str != NULL && r != NULL, RET_BAD_PARAMS);\n\n  return canvas_draw_text_bidi_in_rect(c, str, size, r, bidi_type, ellipses);\n}",
            "key_variables": [
               [
                  4697,
                  "widget->floating"
               ],
               [
                  4703,
                  "widget->auto_adjust_size"
               ]
            ]
         },
         {
            "type": "func",
            "name": "widget_is_parent_of",
            "line_range": [
               4666,
               4679
            ],
            "source_code": "bool_t widget_is_parent_of(widget_t* widget, widget_t* child) {\n  widget_t* iter = NULL;\n  return_value_if_fail(widget != NULL && child != NULL, FALSE);\n\n  iter = child->parent;\n  while (iter != NULL) {\n    if (iter == widget) {\n      return TRUE;\n    }\n    iter = iter->parent;\n  }\n\n  return FALSE;\n}",
            "key_variables": [
               [
                  4709,
                  "widget->with_focus_state"
               ]
            ]
         },
         {
            "type": "func",
            "name": "widget_is_direct_parent_of",
            "line_range": [
               4681,
               4685
            ],
            "source_code": "bool_t widget_is_direct_parent_of(widget_t* widget, widget_t* child) {\n  return_value_if_fail(widget != NULL && child != NULL, FALSE);\n\n  return child->parent == widget;\n}",
            "key_variables": [
               [
                  4715,
                  "widget->focusable"
               ],
               [
                  4721,
                  "widget->sensitive"
               ]
            ]
         },
         {
            "type": "func",
            "name": "widget_get_floating",
            "line_range": [
               4693,
               4697
            ],
            "source_code": "bool_t widget_get_floating(widget_t* widget) {\n  return_value_if_fail(widget != NULL, FALSE);\n\n  return widget->floating;\n}",
            "key_variables": [
               [
                  4727,
                  "widget->visible"
               ],
               [
                  4733,
                  "widget->feedback"
               ]
            ]
         },
         {
            "type": "func",
            "name": "widget_get_auto_adjust_size",
            "line_range": [
               4699,
               4703
            ],
            "source_code": "bool_t widget_get_auto_adjust_size(widget_t* widget) {\n  return_value_if_fail(widget != NULL, FALSE);\n\n  return widget->auto_adjust_size;\n}",
            "key_variables": [
               [
                  4738,
                  "widget->astyle"
               ]
            ]
         },
         {
            "type": "func",
            "name": "widget_get_with_focus_state",
            "line_range": [
               4705,
               4709
            ],
            "source_code": "bool_t widget_get_with_focus_state(widget_t* widget) {\n  return_value_if_fail(widget != NULL, FALSE);\n\n  return widget->with_focus_state;\n}",
            "key_variables": [
               [
                  4774,
                  "info->hscale"
               ],
               [
                  4777,
                  "info->hscale"
               ],
               [
                  4780,
                  "info->vscale"
               ],
               [
                  4783,
                  "info->vscale"
               ]
            ]
         }
      ],
      "src/base/widget_animator.c": [
         {
            "type": "func",
            "name": "widget_animator_time_elapse",
            "line_range": [
               58,
               136
            ],
            "source_code": "ret_t widget_animator_time_elapse(widget_animator_t* animator, uint32_t delta_time) {\n  uint32_t end_time = 0;\n  float_t time_percent = 0;\n  uint32_t elapsed_time = 0;\n  return_value_if_fail(animator != NULL, RET_BAD_PARAMS);\n\n  if (animator->state != ANIMATOR_RUNNING) {\n    return RET_OK;\n  }\n\n  elapsed_time = delta_time * animator->time_scale;\n  if (animator->delay > 0) {\n    int32_t delay = animator->delay - elapsed_time;\n    if (delay > 0) {\n      animator->delay = delay;\n      return RET_OK;\n    } else {\n      elapsed_time = -delay;\n      animator->now = 0;\n      animator->delay = 0;\n      animator->start_time = 0;\n    }\n  }\n\n  animator->now += elapsed_time;\n  end_time = animator->start_time + animator->duration;\n  time_percent = ((float_t)(animator->now - animator->start_time)) / animator->duration;\n\n  if (time_percent > 1) {\n    time_percent = 1;\n  }\n\n  if (animator->reversed) {\n    time_percent = 1 - time_percent;\n  }\n\n  widget_animator_update(animator, animator->easing(time_percent));\n\n  if (animator->now >= end_time) {\n    if (animator->repeat_times > 0) {\n      event_t e = event_init(EVT_ANIM_ONCE, animator);\n      animator->start_time = animator->now;\n      animator->repeat_times--;\n\n      if (animator->repeat_times == 0 && animator->forever) {\n        animator->repeat_times = TK_UINT32_MAX;\n      }\n\n      emitter_dispatch(&(animator->emitter), &e);\n    } else if (animator->yoyo_times > 0) {\n      event_t e = event_init(EVT_ANIM_ONCE, animator);\n      animator->start_time = animator->now;\n      animator->reversed = !animator->reversed;\n\n      if (!animator->reversed) {\n        animator->yoyo_times--;\n      }\n\n      if (animator->yoyo_times == 0 && animator->forever) {\n        animator->yoyo_times = TK_UINT32_MAX;\n      }\n\n      emitter_dispatch(&(animator->emitter), &e);\n    }\n\n    if (animator->repeat_times == 0 && animator->yoyo_times == 0) {\n      event_t e = event_init(EVT_ANIM_END, animator);\n\n      animator->state = ANIMATOR_DONE;\n      emitter_dispatch(&(animator->emitter), &e);\n\n      if (animator->destroy_when_done) {\n        widget_animator_destroy(animator);\n      }\n    }\n  }\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  69,
                  "animator->time_scale"
               ],
               [
                  84,
                  "animator->duration"
               ],
               [
                  85,
                  "animator->duration"
               ],
               [
                  100,
                  "animator->now"
               ],
               [
                  110,
                  "animator->now"
               ],
               [
                  111,
                  "animator->reversed"
               ],
               [
                  151,
                  "animator->total_yoyo_times"
               ],
               [
                  152,
                  "animator->total_repeat_times"
               ]
            ]
         },
         {
            "type": "func",
            "name": "widget_animator_update",
            "line_range": [
               195,
               204
            ],
            "source_code": "static ret_t widget_animator_update(widget_animator_t* animator, float_t percent) {\n  ret_t ret = RET_OK;\n  return_value_if_fail(animator != NULL && animator->update != NULL, RET_BAD_PARAMS);\n\n  widget_invalidate_force(animator->widget, NULL);\n  ret = animator->update(animator, percent);\n  widget_invalidate_force(animator->widget, NULL);\n\n  return ret;\n}",
            "key_variables": [
               [
                  211,
                  "animator->repeat_times"
               ],
               [
                  214,
                  "animator->yoyo_times"
               ]
            ]
         },
         {
            "type": "func",
            "name": "widget_animator_set_repeat",
            "line_range": [
               226,
               236
            ],
            "source_code": "ret_t widget_animator_set_repeat(widget_animator_t* animator, uint32_t repeat_times) {\n  return_value_if_fail(animator != NULL && animator->update != NULL, RET_BAD_PARAMS);\n\n  animator->yoyo_times = 0;\n  animator->total_yoyo_times = animator->yoyo_times;\n  animator->forever = repeat_times == 0;\n  animator->repeat_times = animator->forever ? TK_UINT32_MAX : repeat_times;\n  animator->total_repeat_times = animator->repeat_times;\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  231,
                  "animator->yoyo_times"
               ],
               [
                  234,
                  "animator->repeat_times"
               ]
            ]
         }
      ],
      "src/base/widget_animator_manager.c": [
         {
            "type": "func",
            "name": "widget_animator_manager_set_to_dispatch",
            "line_range": [
               26,
               35
            ],
            "source_code": "static ret_t widget_animator_manager_set_to_dispatch(widget_animator_manager_t* am) {\n  widget_animator_t* iter = am->first;\n\n  while (iter != NULL) {\n    iter->to_dispatch = TRUE;\n    iter = iter->next;\n  }\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  28,
                  "am->first"
               ],
               [
                  32,
                  "iter->next"
               ]
            ]
         },
         {
            "type": "func",
            "name": "widget_animator_manager_get_to_dispatch",
            "line_range": [
               37,
               48
            ],
            "source_code": "static widget_animator_t* widget_animator_manager_get_to_dispatch(widget_animator_manager_t* am) {\n  widget_animator_t* iter = am->first;\n\n  while (iter != NULL) {\n    if (iter->to_dispatch) {\n      return iter;\n    }\n    iter = iter->next;\n  }\n\n  return NULL;\n}",
            "key_variables": [
               [
                  39,
                  "am->first"
               ],
               [
                  45,
                  "iter->next"
               ]
            ]
         },
         {
            "type": "func",
            "name": "widget_animator_manager_time_elapse",
            "line_range": [
               50,
               65
            ],
            "source_code": "ret_t widget_animator_manager_time_elapse(widget_animator_manager_t* am, uint32_t delta_time) {\n  widget_animator_t* iter = NULL;\n  return_value_if_fail(am != NULL, RET_BAD_PARAMS);\n\n  delta_time = delta_time * am->time_scale;\n  widget_animator_manager_set_to_dispatch(am);\n\n  iter = widget_animator_manager_get_to_dispatch(am);\n  while (iter != NULL) {\n    iter->to_dispatch = FALSE;\n    widget_animator_time_elapse(iter, delta_time);\n    iter = widget_animator_manager_get_to_dispatch(am);\n  }\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  55,
                  "am->time_scale"
               ]
            ]
         },
         {
            "type": "func",
            "name": "widget_animator_manager_create",
            "line_range": [
               77,
               81
            ],
            "source_code": "widget_animator_manager_t* widget_animator_manager_create(void) {\n  widget_animator_manager_t* am = TKMEM_ZALLOC(widget_animator_manager_t);\n\n  return widget_animator_manager_init(am);\n}",
            "key_variables": [
               [
                  86,
                  "info->now"
               ],
               [
                  91,
                  "info->now"
               ]
            ]
         },
         {
            "type": "func",
            "name": "widget_animator_manager_init",
            "line_range": [
               95,
               102
            ],
            "source_code": "widget_animator_manager_t* widget_animator_manager_init(widget_animator_manager_t* am) {\n  return_value_if_fail(am != NULL, NULL);\n\n  am->time_scale = 1;\n  am->timer_id = timer_add(widget_animator_manager_on_timer, am, TK_MAX_SLEEP_TIME);\n\n  return am;\n}",
            "key_variables": [
               [
                  109,
                  "am->first"
               ],
               [
                  111,
                  "iter->next"
               ]
            ]
         },
         {
            "type": "func",
            "name": "widget_animator_manager_add",
            "line_range": [
               137,
               154
            ],
            "source_code": "ret_t widget_animator_manager_add(widget_animator_manager_t* am, widget_animator_t* animator) {\n  widget_animator_t* iter = NULL;\n  return_value_if_fail(am != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(animator != NULL, RET_BAD_PARAMS);\n\n  iter = am->first;\n  if (iter == NULL) {\n    am->first = animator;\n  } else {\n    while (iter->next != NULL) {\n      iter = iter->next;\n    }\n    iter->next = animator;\n  }\n  animator->widget_animator_manager = am;\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  143,
                  "am->first"
               ],
               [
                  148,
                  "iter->next"
               ],
               [
                  164,
                  "am->first"
               ],
               [
                  168,
                  "iter->next"
               ],
               [
                  172,
                  "iter->next"
               ],
               [
                  175,
                  "iter->next"
               ],
               [
                  181,
                  "iter->next"
               ]
            ]
         },
         {
            "type": "func",
            "name": "animator_is_equal",
            "line_range": [
               187,
               195
            ],
            "source_code": "static bool_t animator_is_equal(widget_animator_t* iter, widget_t* widget, const char* name) {\n  if (iter->widget == widget || widget == NULL) {\n    if (name == NULL || (iter->name != NULL && tk_str_eq(name, iter->name))) {\n      return TRUE;\n    }\n  }\n\n  return FALSE;\n}",
            "key_variables": [
               [
                  205,
                  "am->first"
               ],
               [
                  206,
                  "am->first"
               ],
               [
                  211,
                  "iter->next"
               ],
               [
                  214,
                  "am->first"
               ],
               [
                  215,
                  "am->first"
               ],
               [
                  217,
                  "iter->next"
               ],
               [
                  219,
                  "prev->next"
               ],
               [
                  225,
                  "prev->next"
               ],
               [
                  240,
                  "am->first"
               ],
               [
                  262,
                  "iter->next"
               ]
            ]
         },
         {
            "type": "func",
            "name": "widget_animator_manager_pause",
            "line_range": [
               272,
               275
            ],
            "source_code": "ret_t widget_animator_manager_pause(widget_animator_manager_t* am, widget_t* widget,\n                                    const char* name) {\n  return widget_animator_manager_exec(am, widget, name, ACTION_PAUSE) > 0 ? RET_OK : RET_NOT_FOUND;\n}",
            "key_variables": [
               [
                  293,
                  "am->first"
               ],
               [
                  299,
                  "iter->next"
               ]
            ]
         },
         {
            "type": "func",
            "name": "widget_animator_manager_start",
            "line_range": [
               277,
               280
            ],
            "source_code": "ret_t widget_animator_manager_start(widget_animator_manager_t* am, widget_t* widget,\n                                    const char* name) {\n  return widget_animator_manager_exec(am, widget, name, ACTION_START) > 0 ? RET_OK : RET_NOT_FOUND;\n}",
            "key_variables": [
               [
                  310,
                  "am->first"
               ],
               [
                  313,
                  "iter->next"
               ],
               [
                  324,
                  "am->first"
               ],
               [
                  329,
                  "iter->next"
               ]
            ]
         }
      ],
      "src/base/widget_vtable.c": [
         {
            "type": "func",
            "name": "widget_invalidate_default",
            "line_range": [
               24,
               84
            ],
            "source_code": "ret_t widget_invalidate_default(widget_t* widget, const rect_t* rect) {\n  rect_t t = *rect;\n  rect_t* r = &t;\n  if (widget->vt->scrollable) {\n    int32_t ox = widget_get_prop_int(widget, WIDGET_PROP_XOFFSET, 0);\n    int32_t oy = widget_get_prop_int(widget, WIDGET_PROP_YOFFSET, 0);\n    rect_t r_self = rect_init(0, 0, widget->w, widget->h);\n\n    if (ox > 0) {\n      r->x -= ox;\n      r->w += ox + 1;\n    }\n    if (oy > 0) {\n      r->y -= oy;\n      r->h += oy + 1;\n    }\n\n    *r = rect_intersect(r, &r_self);\n  }\n\n  if (r->w <= 0 || r->h <= 0) {\n    return RET_OK;\n  }\n\n  r->x += widget->x;\n  r->y += widget->y;\n\n  if (widget->astyle != NULL) {\n    int32_t tolerance = widget->dirty_rect_tolerance;\n\n    if (tolerance > 0) {\n      r->x -= tolerance;\n      r->y -= tolerance;\n      r->w += 2 * tolerance + 1;\n      r->h += 2 * tolerance + 1;\n    }\n  }\n\n  if (r->x < 0) {\n    r->w = r->w + r->x;\n  }\n  if (r->y < 0) {\n    r->h = r->h + r->y;\n  }\n\n  r->x = tk_max(0, r->x);\n  r->y = tk_max(0, r->y);\n  r->w = tk_max(0, r->w);\n  r->h = tk_max(0, r->h);\n\n  if (widget->parent) {\n    widget_t* parent = widget->parent;\n    if (parent->vt && parent->vt->invalidate) {\n      parent->vt->invalidate(parent, r);\n    } else {\n      widget_invalidate_default(parent, r);\n    }\n  }\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  49,
                  "widget->x"
               ],
               [
                  50,
                  "widget->y"
               ],
               [
                  53,
                  "widget->dirty_rect_tolerance"
               ],
               [
                  64,
                  "r->x"
               ],
               [
                  67,
                  "r->y"
               ],
               [
                  76,
                  "widget->parent"
               ]
            ]
         },
         {
            "type": "func",
            "name": "widget_on_paint_self_default",
            "line_range": [
               92,
               97
            ],
            "source_code": "ret_t widget_on_paint_self_default(widget_t* widget, canvas_t* c) {\n  if (style_is_valid(widget->astyle)) {\n    return widget_paint_helper(widget, c, NULL, NULL);\n  }\n  return RET_OK;\n}",
            "key_variables": [
               [
                  111,
                  "widget->dirty_rect_tolerance"
               ]
            ]
         },
         {
            "type": "func",
            "name": "widget_set_prop_default",
            "line_range": [
               165,
               169
            ],
            "source_code": "ret_t widget_set_prop_default(widget_t* widget, const char* name, const value_t* v) {\n  return_value_if_fail(widget != NULL && name != NULL && v != NULL, RET_BAD_PARAMS);\n\n  return RET_NOT_FOUND;\n}",
            "key_variables": [
               [
                  179,
                  "widget->grab_widget"
               ],
               [
                  188,
                  "iter->x"
               ],
               [
                  189,
                  "iter->y"
               ]
            ]
         },
         {
            "type": "func",
            "name": "widget_find_target_default",
            "line_range": [
               171,
               196
            ],
            "source_code": "widget_t* widget_find_target_default(widget_t* widget, xy_t x, xy_t y) {\n  xy_t xx = 0;\n  xy_t yy = 0;\n  point_t p = {x, y};\n  return_value_if_fail(widget != NULL, NULL);\n\n  if (widget->grab_widget != NULL) {\n    return widget->grab_widget;\n  }\n\n  widget_to_local(widget, &p);\n  WIDGET_FOR_EACH_CHILD_BEGIN_R(widget, iter, i)\n  if (!iter->sensitive || !iter->enable) {\n    continue;\n  }\n\n  xx = p.x - iter->x;\n  yy = p.y - iter->y;\n  if (!widget_is_point_in(iter, xx, yy, TRUE)) {\n    continue;\n  }\n  return iter;\n  WIDGET_FOR_EACH_CHILD_END();\n\n  return NULL;\n}",
            "key_variables": [
               [
                  205,
                  "properties[i]"
               ]
            ]
         }
      ],
      "src/base/window_animator_factory.c": [
         {
            "type": "block",
            "name": "block",
            "line_range": "",
            "source_code": "",
            "key_variables": [
               35,
               "type[TK_NAME_LEN + 1]"
            ]
         }
      ],
      "src/base/window_base.c": [
         {
            "type": "func",
            "name": "window_base_on_paint_end",
            "line_range": [
               53,
               55
            ],
            "source_code": "ret_t window_base_on_paint_end(widget_t* widget, canvas_t* c) {\n  return RET_OK;\n}",
            "key_variables": [
               [
                  59,
                  "widget->name"
               ],
               [
                  68,
                  "window_base->theme"
               ]
            ]
         },
         {
            "type": "func",
            "name": "window_base_set_prop",
            "line_range": [
               215,
               295
            ],
            "source_code": "ret_t window_base_set_prop(widget_t* widget, const char* name, const value_t* v) {\n  window_base_t* window_base = WINDOW_BASE(widget);\n  return_value_if_fail(widget != NULL && name != NULL && v != NULL, RET_BAD_PARAMS);\n\n  if (tk_str_eq(name, WIDGET_PROP_ANIM_HINT)) {\n    window_base->open_anim_hint = tk_str_copy(window_base->open_anim_hint, value_str(v));\n    window_base->close_anim_hint = tk_str_copy(window_base->close_anim_hint, value_str(v));\n    return RET_OK;\n  } else if (tk_str_eq(name, WIDGET_PROP_OPEN_ANIM_HINT)) {\n    window_base->open_anim_hint = tk_str_copy(window_base->open_anim_hint, value_str(v));\n    return RET_OK;\n  } else if (tk_str_eq(name, WIDGET_PROP_DISABLE_ANIM)) {\n    window_base->disable_anim = value_bool(v);\n    return RET_OK;\n  } else if (tk_str_eq(name, WIDGET_PROP_NATIVE_WINDOW)) {\n    window_base->native_window = (native_window_t*)value_pointer(v);\n    return RET_OK;\n  } else if (tk_str_eq(name, WIDGET_PROP_CLOSE_ANIM_HINT)) {\n    window_base->close_anim_hint = tk_str_copy(window_base->close_anim_hint, value_str(v));\n    return RET_OK;\n  } else if (tk_str_eq(name, WIDGET_PROP_THEME)) {\n    window_base->theme = tk_str_copy(window_base->theme, value_str(v));\n    window_base_reload_theme_obj(widget);\n    return RET_OK;\n  } else if (tk_str_eq(name, WIDGET_PROP_MOVE_FOCUS_PREV_KEY)) {\n    window_base->move_focus_prev_key = tk_str_copy(window_base->move_focus_prev_key, value_str(v));\n    return RET_OK;\n  } else if (tk_str_eq(name, WIDGET_PROP_MOVE_FOCUS_NEXT_KEY)) {\n    window_base->move_focus_next_key = tk_str_copy(window_base->move_focus_next_key, value_str(v));\n    return RET_OK;\n  } else if (tk_str_eq(name, WIDGET_PROP_MOVE_FOCUS_UP_KEY)) {\n    window_base->move_focus_up_key = tk_str_copy(window_base->move_focus_up_key, value_str(v));\n    return RET_OK;\n  } else if (tk_str_eq(name, WIDGET_PROP_MOVE_FOCUS_DOWN_KEY)) {\n    window_base->move_focus_down_key = tk_str_copy(window_base->move_focus_down_key, value_str(v));\n    return RET_OK;\n  } else if (tk_str_eq(name, WIDGET_PROP_MOVE_FOCUS_LEFT_KEY)) {\n    window_base->move_focus_left_key = tk_str_copy(window_base->move_focus_left_key, value_str(v));\n    return RET_OK;\n  } else if (tk_str_eq(name, WIDGET_PROP_MOVE_FOCUS_RIGHT_KEY)) {\n    window_base->move_focus_right_key =\n        tk_str_copy(window_base->move_focus_right_key, value_str(v));\n    return RET_OK;\n  } else if (tk_str_eq(name, WIDGET_PROP_SINGLE_INSTANCE)) {\n    window_base->single_instance = value_bool(v);\n    return RET_OK;\n  } else if (tk_str_eq(name, WIDGET_PROP_STRONGLY_FOCUS)) {\n    window_base->strongly_focus = value_bool(v);\n    return RET_OK;\n  } else if (tk_str_eq(name, WIDGET_PROP_DESIGN_W)) {\n    window_base->design_w = value_uint32(v);\n    return RET_OK;\n  } else if (tk_str_eq(name, WIDGET_PROP_DESIGN_H)) {\n    window_base->design_h = value_uint32(v);\n    return RET_OK;\n  } else if (tk_str_eq(name, WIDGET_PROP_AUTO_SCALE_CHILDREN_X)) {\n    window_base->auto_scale_children_x = value_bool(v);\n    return RET_OK;\n  } else if (tk_str_eq(name, WIDGET_PROP_AUTO_SCALE_CHILDREN_Y)) {\n    window_base->auto_scale_children_y = value_bool(v);\n    return RET_OK;\n  } else if (tk_str_eq(name, WIDGET_PROP_AUTO_SCALE_CHILDREN_W)) {\n    window_base->auto_scale_children_w = value_bool(v);\n    return RET_OK;\n  } else if (tk_str_eq(name, WIDGET_PROP_AUTO_SCALE_CHILDREN_H)) {\n    window_base->auto_scale_children_h = value_bool(v);\n    return RET_OK;\n  } else if (tk_str_eq(name, WIDGET_PROP_CLOSABLE)) {\n    if (v->type == VALUE_TYPE_STRING) {\n      const key_type_value_t* kv = window_closable_type_find(value_str(v));\n      if (kv != NULL) {\n        window_base->closable = (window_closable_t)(kv->value);\n      }\n    } else {\n      window_base->closable = (window_closable_t)value_int(v);\n    }\n    return RET_OK;\n  }\n\n  return RET_NOT_FOUND;\n}",
            "key_variables": [
               [
                  344,
                  "widget->x"
               ],
               [
                  345,
                  "widget->y"
               ]
            ]
         },
         {
            "type": "func",
            "name": "window_base_get_key_target_leaf",
            "line_range": [
               352,
               360
            ],
            "source_code": "static widget_t* window_base_get_key_target_leaf(widget_t* widget) {\n  widget_t* iter = widget;\n\n  while (iter->key_target != NULL) {\n    iter = iter->key_target;\n  }\n\n  return iter;\n}",
            "key_variables": [
               [
                  357,
                  "iter->key_target"
               ]
            ]
         },
         {
            "type": "func",
            "name": "window_set_auto_scale_children",
            "line_range": [
               371,
               383
            ],
            "source_code": "ret_t window_set_auto_scale_children(widget_t* widget, uint32_t design_w, uint32_t design_h) {\n  window_base_t* base = WINDOW_BASE(widget);\n  return_value_if_fail(base != NULL && design_w > 0 && design_h > 0, RET_BAD_PARAMS);\n\n  base->design_w = design_w;\n  base->design_h = design_h;\n  base->auto_scale_children_x = TRUE;\n  base->auto_scale_children_y = TRUE;\n  base->auto_scale_children_w = TRUE;\n  base->auto_scale_children_h = TRUE;\n\n  return window_base_auto_scale_children(widget);\n}",
            "key_variables": [
               [
                  432,
                  "win->grab_count_when_to_foreground"
               ],
               [
                  449,
                  "widget->grab_widget_count"
               ],
               [
                  479,
                  "base->moving_focus_mode"
               ],
               [
                  488,
                  "base->moving_focus_mode"
               ]
            ]
         }
      ],
      "src/base/window_manager.c": [
         {
            "type": "func",
            "name": "window_manager_back_to_home_on_dialog_destroy",
            "line_range": [
               262,
               274
            ],
            "source_code": "static ret_t window_manager_back_to_home_on_dialog_destroy(void* ctx, event_t* e) {\n\n  back_to_win_info_t* back_to_win_info = (back_to_win_info_t*)(ctx);\n\n  window_manager_back_to_win_sync(back_to_win_info->widget, back_to_win_info->target);\n\n  TKMEM_FREE(back_to_win_info);\n\n\n\n  return RET_REMOVE;\n\n}",
            "key_variables": [
               [
                  289,
                  "e->target"
               ]
            ]
         },
         {
            "type": "func",
            "name": "window_manager_paint",
            "line_range": [
               538,
               550
            ],
            "source_code": "ret_t window_manager_paint(widget_t* widget) {\n\n  window_manager_t* wm = WINDOW_MANAGER(widget);\n\n  return_value_if_fail(wm != NULL && wm->vt != NULL, RET_BAD_PARAMS);\n\n  return_value_if_fail(wm->vt->paint != NULL, RET_BAD_PARAMS);\n\n\n\n  return wm->vt->paint(widget);\n\n}",
            "key_variables": [
               [
                  573,
                  "widget->grab_widget"
               ]
            ]
         },
         {
            "type": "func",
            "name": "window_manager_set_screen_saver_time",
            "line_range": [
               642,
               654
            ],
            "source_code": "ret_t window_manager_set_screen_saver_time(widget_t* widget, uint32_t time) {\n\n  window_manager_t* wm = WINDOW_MANAGER(widget);\n\n  return_value_if_fail(wm != NULL && wm->vt != NULL, RET_BAD_PARAMS);\n\n  return_value_if_fail(wm->vt->set_screen_saver_time != NULL, RET_BAD_PARAMS);\n\n\n\n  return wm->vt->set_screen_saver_time(widget, time);\n\n}",
            "key_variables": [
               [
                  734,
                  "wm->curr_expected_sleep_time"
               ]
            ]
         }
      ],
      "src/blend/soft_g2d.c": [
         {
            "type": "func",
            "name": "soft_copy_image",
            "line_range": [
               74,
               110
            ],
            "source_code": "ret_t soft_copy_image(bitmap_t* dst, bitmap_t* src, const rect_t* src_r, xy_t dx, xy_t dy) {\n  uint8_t* src_p = NULL;\n  uint8_t* dst_p = NULL;\n  uint8_t* src_data = NULL;\n  uint8_t* dst_data = NULL;\n  uint32_t bpp = bitmap_get_bpp(dst);\n  uint32_t dst_line_length = bitmap_get_line_length(dst);\n  uint32_t src_line_length = bitmap_get_line_length(src);\n  return_value_if_fail(dst != NULL && src != NULL && src_r != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(dst->format == src->format, RET_BAD_PARAMS);\n\n  src_data = bitmap_lock_buffer_for_read(src);\n  dst_data = bitmap_lock_buffer_for_write(dst);\n  return_value_if_fail(src_data != NULL && dst_data != NULL, RET_BAD_PARAMS);\n\n  src_p = (uint8_t*)(src_data) + src_r->y * src_line_length + src_r->x * bpp;\n  dst_p = (uint8_t*)(dst_data) + dy * dst_line_length + dx * bpp;\n  if ((dst->w * bpp == dst_line_length) && (src->w * bpp == src_line_length) && dst->w == src->w &&\n      dst->h == src->h && src_r->w == src->w && src_r->x == 0) {\n    uint32_t size = (src_r->w * src_r->h);\n    tk_pixel_copy(dst_p, src_p, size, bpp);\n\n  } else {\n    uint32_t i = 0;\n    uint32_t size = src_r->w;\n\n    for (i = 0; i < src_r->h; i++) {\n      tk_pixel_copy(dst_p, src_p, size, bpp);\n      dst_p += dst_line_length;\n      src_p += src_line_length;\n    }\n  }\n  bitmap_unlock_buffer(src);\n  bitmap_unlock_buffer(dst);\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  99,
                  "src_r->w"
               ],
               [
                  101,
                  "src_r->h"
               ]
            ]
         }
      ],
      "src/blend/stm32_g2d.c": [
         {
            "type": "block",
            "name": "block",
            "line_range": "",
            "source_code": "",
            "key_variables": [
               74,
               "dst->x"
            ]
         },
         {
            "type": "block",
            "name": "block",
            "line_range": "",
            "source_code": "",
            "key_variables": [
               75,
               "dst->y"
            ]
         },
         {
            "type": "block",
            "name": "block",
            "line_range": "",
            "source_code": "",
            "key_variables": [
               76,
               "dst->w"
            ]
         },
         {
            "type": "block",
            "name": "block",
            "line_range": "",
            "source_code": "",
            "key_variables": [
               77,
               "dst->h"
            ]
         },
         {
            "type": "func",
            "name": "g2d_fill_rect",
            "line_range": [
               108,
               218
            ],
            "source_code": "ret_t g2d_fill_rect(bitmap_t* fb, const rect_t* dst, color_t c) {\n\n  uint16_t x = 0;\n\n  uint16_t y = 0;\n\n  uint16_t w = 0;\n\n  uint16_t h = 0;\n\n  uint32_t color = 0;\n\n  uint32_t o_addr = 0;\n\n  uint16_t o_format = 0;\n\n  uint16_t o_offline = 0;\n\n  uint16_t o_pixsize = 0;\n\n  uint8_t* fb_data = NULL;\n\n  if (c.rgba.a < 0xf0) {\n\n    return RET_NOT_IMPL;\n\n  }\n\n\n\n  return_value_if_fail(fb != NULL && fb->buffer != NULL && dst != NULL, RET_BAD_PARAMS);\n\n  return_value_if_fail(fb->format == BITMAP_FMT_BGR565 || fb->format == BITMAP_FMT_BGRA8888,\n\n                       RET_BAD_PARAMS);\n\n\n\n  x = dst->x;\n\n  y = dst->y;\n\n  w = dst->w;\n\n  h = dst->h;\n\n\n\n  if (fb->format == BITMAP_FMT_BGR565) {\n\n    o_pixsize = 2;\n\n    o_format = PIXEL_FORMAT_BGR565;\n\n    color = ((((c.rgba.r) >> 3) << 11) | (((c.rgba.g) >> 2) << 5) | ((c.rgba.b) >> 3));\n\n  } else {\n\n    o_pixsize = 4;\n\n    o_format = PIXEL_FORMAT_BGRA8888;\n\n    color = c.color;\n\n  }\n\n\n\n  fb_data = bitmap_lock_buffer_for_write(fb);\n\n  o_offline = fb->w - w;\n\n  o_addr = ((uint32_t)fb_data + o_pixsize * (fb->w * y + x));\n\n\n\n  __HAL_RCC_DMA2D_CLK_ENABLE();\n\n\n\n  DMA2D->CR &= ~(DMA2D_CR_START);\n\n  DMA2D->CR = DMA2D_R2M;\n\n\n\n  DMA2D->OPFCCR = o_format;\n\n  DMA2D->OOR = o_offline;\n\n  DMA2D->OMAR = o_addr;\n\n  DMA2D->OCOLR = color;\n\n  DMA2D->NLR = h | (w << 16);\n\n\n\n  DMA2D->CR |= DMA2D_CR_START;\n\n\n\n  DMA2D_WAIT\n\n  bitmap_unlock_buffer(fb);\n\n\n\n  return RET_OK;\n\n}",
            "key_variables": [
               [
                  136,
                  "src->x"
               ],
               [
                  137,
                  "src->y"
               ],
               [
                  138,
                  "src->w"
               ],
               [
                  139,
                  "src->h"
               ],
               [
                  140,
                  "img->w"
               ]
            ]
         },
         {
            "type": "func",
            "name": "g2d_copy_image",
            "line_range": [
               222,
               380
            ],
            "source_code": "ret_t g2d_copy_image(bitmap_t* fb, bitmap_t* img, const rect_t* src, xy_t x, xy_t y) {\n\n  uint32_t o_addr = 0;\n\n  uint16_t o_offline = 0;\n\n  uint16_t o_format = 0;\n\n  uint16_t o_pixsize = 0;\n\n  uint32_t fg_addr = 0;\n\n  uint16_t fg_offline = 0;\n\n  uint16_t fg_format = 0;\n\n  uint16_t fg_pixsize = 0;\n\n  uint16_t sx = 0;\n\n  uint16_t sy = 0;\n\n  uint16_t w = 0;\n\n  uint16_t h = 0;\n\n  uint16_t iw = 0;\n\n  uint8_t* fb_data = NULL;\n\n  uint8_t* img_data = NULL;\n\n\n\n  return_value_if_fail(fb != NULL && fb->buffer != NULL, RET_BAD_PARAMS);\n\n  return_value_if_fail(img != NULL && img->buffer != NULL && src != NULL, RET_BAD_PARAMS);\n\n  return_value_if_fail(fb->format == BITMAP_FMT_BGR565 || fb->format == BITMAP_FMT_BGRA8888,\n\n                       RET_BAD_PARAMS);\n\n  return_value_if_fail(img->format == BITMAP_FMT_BGR565 || img->format == BITMAP_FMT_BGRA8888,\n\n                       RET_BAD_PARAMS);\n\n\n\n  sx = src->x;\n\n  sy = src->y;\n\n  w = src->w;\n\n  h = src->h;\n\n  iw = img->w;\n\n\n\n  if (fb->format == BITMAP_FMT_BGR565) {\n\n    o_pixsize = 2;\n\n    o_format = PIXEL_FORMAT_BGR565;\n\n  } else {\n\n    o_pixsize = 4;\n\n    o_format = PIXEL_FORMAT_BGRA8888;\n\n  }\n\n\n\n  if (img->format == BITMAP_FMT_BGR565) {\n\n    fg_pixsize = 2;\n\n    fg_format = PIXEL_FORMAT_BGR565;\n\n  } else {\n\n    fg_pixsize = 4;\n\n    fg_format = PIXEL_FORMAT_BGRA8888;\n\n  }\n\n\n\n  fb_data = bitmap_lock_buffer_for_write(fb);\n\n  img_data = bitmap_lock_buffer_for_write(img);\n\n\n\n  o_offline = fb->w - w;\n\n  o_addr = ((uint32_t)fb_data + o_pixsize * (fb->w * y + x));\n\n  fg_offline = iw - w;\n\n  fg_addr = ((uint32_t)img_data + fg_pixsize * (img->w * sy + sx));\n\n\n\n  __HAL_RCC_DMA2D_CLK_ENABLE();\n\n\n\n  DMA2D->CR &= ~(DMA2D_CR_START);\n\n  if (o_format == fg_format) {\n\n    DMA2D->CR = DMA2D_M2M;\n\n  } else {\n\n    DMA2D->CR = DMA2D_M2M_PFC;\n\n  }\n\n\n\n  DMA2D->OPFCCR = o_format;\n\n  DMA2D->OOR = o_offline;\n\n  DMA2D->OMAR = o_addr;\n\n\n\n  DMA2D->FGPFCCR = fg_format;\n\n  DMA2D->FGOR = fg_offline;\n\n  DMA2D->FGMAR = fg_addr;\n\n\n\n  DMA2D->NLR = h | (w << 16);\n\n\n\n  DMA2D->CR |= DMA2D_CR_START;\n\n  DMA2D_WAIT\n\n  bitmap_unlock_buffer(fb);\n\n  bitmap_unlock_buffer(img);\n\n\n\n  return RET_OK;\n\n}",
            "key_variables": [
               [
                  233,
                  "dst->x"
               ],
               [
                  234,
                  "dst->y"
               ],
               [
                  235,
                  "src->x"
               ],
               [
                  236,
                  "src->y"
               ],
               [
                  237,
                  "src->w"
               ],
               [
                  238,
                  "src->h"
               ],
               [
                  239,
                  "img->w"
               ]
            ]
         }
      ],
      "src/compressors/compressor_miniz.c": [
         {
            "type": "func",
            "name": "compressor_miniz_compress",
            "line_range": [
               25,
               42
            ],
            "source_code": "static ret_t compressor_miniz_compress(compressor_t* compressor, const void* data, uint32_t size,\n                                       wbuffer_t* out) {\n  int level = 0;\n  mz_ulong out_size = 0;\n  return_value_if_fail(wbuffer_extend_capacity(out, 512 + size * 2) == RET_OK, RET_OOM);\n\n  out_size = out->capacity;\n  level = compressor->options == COMPRESSOR_SPEED_FIRST ? 3 : 6;\n\n  if (mz_compress2((uint8_t*)(out->data), &out_size, (const uint8_t*)data, size, level) == MZ_OK) {\n    out->cursor = out_size;\n\n    return RET_OK;\n  }\n  out->cursor = 0;\n\n  return RET_FAIL;\n}",
            "key_variables": [
               [
                  32,
                  "out->capacity"
               ]
            ]
         },
         {
            "type": "func",
            "name": "compressor_miniz_uncompress",
            "line_range": [
               44,
               58
            ],
            "source_code": "static ret_t compressor_miniz_uncompress(compressor_t* compressor, const void* data, uint32_t size,\n                                         wbuffer_t* out) {\n  mz_ulong out_size = 0;\n  return_value_if_fail(wbuffer_extend_capacity(out, size * 5) == RET_OK, RET_OOM);\n\n  out_size = out->capacity;\n\n  if (mz_uncompress((uint8_t*)(out->data), &out_size, (const uint8_t*)data, size) == MZ_OK) {\n    out->cursor = out_size;\n\n    return RET_OK;\n  }\n\n  return RET_FAIL;\n}",
            "key_variables": [
               [
                  50,
                  "out->capacity"
               ]
            ]
         }
      ],
      "src/conf_io/app_conf_init.c": [
         {
            "type": "func",
            "name": "app_conf_get_url",
            "line_range": [
               53,
               76
            ],
            "source_code": "static ret_t app_conf_get_url(char url[MAX_PATH + 1], const char* app_name, const char* extname) {\n  char path[MAX_PATH + 1];\n  char app_dir[MAX_PATH + 1];\n  fs_t* fs = os_fs();\n\n  return_value_if_fail(fs != NULL, RET_NOT_FOUND);\n  return_value_if_fail(app_name != NULL && extname != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(fs_get_user_storage_path(fs, path) == RET_OK, RET_BAD_PARAMS);\n\n  if (!path_exist(path)) {\n    return_value_if_fail(fs_create_dir(fs, path) == RET_OK, RET_FAIL);\n  }\n\n  path_build(app_dir, MAX_PATH, path, app_name, NULL);\n  if (!path_exist(app_dir)) {\n    return_value_if_fail(fs_create_dir(fs, app_dir) == RET_OK, RET_FAIL);\n  }\n\n  tk_snprintf(url, MAX_PATH, \"app_conf.%s\", extname);\n  path_build(path, MAX_PATH, app_dir, url, NULL);\n  tk_snprintf(url, MAX_PATH, \"file://%s\", path);\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  55,
                  "path[MAX_PATH + 1]"
               ],
               [
                  56,
                  "app_dir[MAX_PATH + 1]"
               ],
               [
                  81,
                  "path[MAX_PATH + 1]"
               ],
               [
                  85,
                  "app_conf_name[MAX_PATH + 1]"
               ]
            ]
         }
      ],
      "src/conf_io/conf_ini.c": [
         {
            "type": "func",
            "name": "conf_doc_save_value",
            "line_range": [
               175,
               215
            ],
            "source_code": "static ret_t conf_doc_save_value(const value_t* v, str_t* str) {\n  char buff[32];\n\n  switch (v->type) {\n    case VALUE_TYPE_STRING: {\n      const char* p = value_str(v);\n      while (*p) {\n        if (*p == '#' || *p == '\\\\' || *p == '\\n') {\n          return_value_if_fail(str_append_char(str, '\\\\') == RET_OK, RET_OOM);\n        }\n        return_value_if_fail(str_append_char(str, *p) == RET_OK, RET_OOM);\n        p++;\n      }\n      return RET_OK;\n    }\n\n    case VALUE_TYPE_FLOAT32: {\n      tk_snprintf(buff, sizeof(buff) - 1, \"%f\", value_float32(v));\n      break;\n    }\n    case VALUE_TYPE_FLOAT:\n    case VALUE_TYPE_DOUBLE: {\n      tk_snprintf(buff, sizeof(buff) - 1, \"%lf\", value_double(v));\n      break;\n    }\n    case VALUE_TYPE_INT64: {\n      tk_snprintf(buff, sizeof(buff) - 1, \"%lld\", value_int64(v));\n      break;\n    }\n    case VALUE_TYPE_UINT64: {\n      tk_snprintf(buff, sizeof(buff) - 1, \"%llu\", value_uint64(v));\n      break;\n    }\n    default: {\n      tk_snprintf(buff, sizeof(buff) - 1, \"%d\", value_int(v));\n      break;\n    }\n  }\n\n  return str_append(str, buff);\n}",
            "key_variables": [
               [
                  177,
                  "buff[32]"
               ]
            ]
         },
         {
            "type": "func",
            "name": "conf_doc_save_leaf_node",
            "line_range": [
               217,
               228
            ],
            "source_code": "static ret_t conf_doc_save_leaf_node(conf_node_t* node, str_t* str) {\n  value_t v;\n  const char* key = conf_node_get_name(node);\n\n  conf_node_get_value(node, &v);\n\n  return_value_if_fail(str_append_more(str, \"  \", key, \" = \", NULL) == RET_OK, RET_OOM);\n  return_value_if_fail(conf_doc_save_value(&v, str) == RET_OK, RET_OOM);\n  return_value_if_fail(str_append(str, \"\\n\") == RET_OK, RET_OOM);\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  248,
                  "iter->next"
               ],
               [
                  252,
                  "group->next"
               ]
            ]
         }
      ],
      "src/conf_io/conf_json.c": [
         {
            "type": "func",
            "name": "conf_json_parse_name",
            "line_range": [
               53,
               74
            ],
            "source_code": "static ret_t conf_json_parse_name(json_parser_t* parser) {\n  str_t* s = &(parser->str);\n  conf_node_t* node = NULL;\n  uint32_t i = parser->cursor;\n  const char* p = parser->data;\n\n  return_value_if_fail(conf_json_skip_to_char(parser, '\\\"') == RET_OK, RET_BAD_PARAMS);\n  i = ++(parser->cursor);\n  while (i < parser->size && p[i] != '\\\"') {\n    i++;\n  }\n\n  str_set_with_len(s, parser->data + parser->cursor, i - parser->cursor);\n  parser->cursor = i + 1;\n  node = conf_doc_create_node(parser->doc, s->str);\n  return_value_if_fail(node != NULL, RET_OOM);\n\n  conf_doc_append_child(parser->doc, parser->current, node);\n  parser->current = node;\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  57,
                  "parser->cursor"
               ],
               [
                  58,
                  "parser->data"
               ]
            ]
         },
         {
            "type": "func",
            "name": "conf_json_skip_to_char",
            "line_range": [
               76,
               89
            ],
            "source_code": "static ret_t conf_json_skip_to_char(json_parser_t* parser, char c) {\n  while (parser->cursor < parser->size) {\n    if (parser->data[parser->cursor] == '\\\\') {\n      parser->cursor += 2;\n      continue;\n    }\n    if (parser->data[parser->cursor] == c) {\n      break;\n    }\n    parser->cursor++;\n  }\n\n  return parser->cursor < parser->size ? RET_OK : RET_BAD_PARAMS;\n}",
            "key_variables": [
               [
                  94,
                  "data[parser->cursor]"
               ]
            ]
         },
         {
            "type": "func",
            "name": "conf_json_skip_spaces",
            "line_range": [
               104,
               113
            ],
            "source_code": "static ret_t conf_json_skip_spaces(json_parser_t* parser) {\n  while (parser->cursor < parser->size) {\n    if (!tk_isspace(parser->data[parser->cursor])) {\n      break;\n    }\n    parser->cursor++;\n  }\n\n  return parser->cursor < parser->size ? RET_OK : RET_BAD_PARAMS;\n}",
            "key_variables": [
               [
                  133,
                  "current->parent"
               ],
               [
                  136,
                  "data[parser->cursor]"
               ]
            ]
         },
         {
            "type": "func",
            "name": "conf_json_parse_object",
            "line_range": [
               115,
               145
            ],
            "source_code": "static ret_t conf_json_parse_object(json_parser_t* parser) {\n  char c = '\\0';\n\n  return_value_if_fail(conf_json_skip_spaces(parser) == RET_OK, RET_BAD_PARAMS);\n  parser->cursor++;\n  while (parser->cursor < parser->size) {\n    return_value_if_fail(conf_json_skip_spaces(parser) == RET_OK, RET_BAD_PARAMS);\n\n    if (parser->data[parser->cursor] == '}') {\n      parser->cursor++;\n      break;\n    }\n\n    return_value_if_fail(conf_json_parse_name(parser) == RET_OK, RET_FAIL);\n    return_value_if_fail(conf_json_skip_to_char(parser, ':') == RET_OK, RET_BAD_PARAMS);\n    parser->cursor++;\n    return_value_if_fail(conf_json_parse_value(parser) == RET_OK, RET_FAIL);\n    parser->current = parser->current->parent;\n\n    return_value_if_fail(conf_json_skip_spaces(parser) == RET_OK, RET_BAD_PARAMS);\n    c = parser->data[parser->cursor];\n    if (c == '}') {\n      parser->cursor++;\n      break;\n    } else if (c != ',') {\n      log_debug(\"unexpected char %c at %s\\n\", c, parser->data + parser->cursor);\n    }\n  }\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  151,
                  "name[TK_NAME_LEN + 1]"
               ],
               [
                  156,
                  "data[parser->cursor]"
               ],
               [
                  169,
                  "node->parent"
               ],
               [
                  172,
                  "data[parser->cursor]"
               ]
            ]
         },
         {
            "type": "func",
            "name": "conf_json_parse_bool",
            "line_range": [
               186,
               194
            ],
            "source_code": "static ret_t conf_json_parse_bool(json_parser_t* parser) {\n  value_t v;\n  char c = parser->data[parser->cursor];\n\n  conf_json_skip_to_value_end(parser);\n  value_set_bool(&v, (c == 't' || c == 'T'));\n\n  return conf_node_set_value(parser->current, &v);\n}",
            "key_variables": [
               [
                  189,
                  "data[parser->cursor]"
               ],
               [
                  200,
                  "parser->cursor"
               ]
            ]
         },
         {
            "type": "func",
            "name": "conf_json_parse_number",
            "line_range": [
               196,
               206
            ],
            "source_code": "static ret_t conf_json_parse_number(json_parser_t* parser) {\n  value_t v;\n  str_t* s = &(parser->str);\n  uint32_t start = parser->cursor;\n\n  conf_json_skip_to_value_end(parser);\n  str_set_with_len(s, parser->data + start, parser->cursor - start);\n  value_set_double(&v, tk_atof(s->str));\n\n  return conf_node_set_value(parser->current, &v);\n}",
            "key_variables": [
               [
                  230,
                  "parser->data"
               ],
               [
                  231,
                  "parser->doc"
               ],
               [
                  233,
                  "parser->size"
               ],
               [
                  234,
                  "p[parser->cursor]"
               ]
            ]
         },
         {
            "type": "func",
            "name": "conf_json_save_node",
            "line_range": [
               364,
               370
            ],
            "source_code": "static ret_t conf_json_save_node(conf_node_t* node, str_t* str, uint32_t level) {\n  const char* name = conf_node_get_name(node);\n  return_value_if_fail(conf_json_write_indent(str, level) == RET_OK, RET_OOM);\n  return_value_if_fail(str_append_more(str, \"\\\"\", name, \"\\\" : \", NULL) == RET_OK, RET_OOM);\n\n  return conf_json_save_node_value(node, str, level);\n}",
            "key_variables": [
               [
                  380,
                  "iter->next"
               ],
               [
                  402,
                  "iter->next"
               ]
            ]
         }
      ],
      "src/conf_io/conf_node.c": [
         {
            "type": "func",
            "name": "conf_doc_create",
            "line_range": [
               48,
               66
            ],
            "source_code": "conf_doc_t* conf_doc_create(uint32_t prealloc_nodes_nr) {\n  uint32_t size = prealloc_nodes_nr * sizeof(conf_node_t);\n  conf_doc_t* doc = TKMEM_ZALLOC(conf_doc_t);\n  return_value_if_fail(doc != NULL, NULL);\n\n  if (prealloc_nodes_nr > 0) {\n    doc->prealloc_nodes = TKMEM_ALLOC(size);\n    if (doc->prealloc_nodes == NULL) {\n      TKMEM_FREE(doc);\n    } else {\n      memset(doc->prealloc_nodes, 0x00, size);\n      doc->prealloc_nodes_nr = prealloc_nodes_nr;\n    }\n  }\n  doc->max_deep_level = 0xffff;\n  tokenizer_init(&(doc->tokenizer), \"\", 0, \".\");\n\n  return doc;\n}",
            "key_variables": [
               [
                  76,
                  "doc->prealloc_nodes_index"
               ],
               [
                  85,
                  "doc->prealloc_nodes_index"
               ]
            ]
         },
         {
            "type": "func",
            "name": "conf_doc_destroy_node",
            "line_range": [
               123,
               146
            ],
            "source_code": "ret_t conf_doc_destroy_node(conf_doc_t* doc, conf_node_t* node) {\n  return_value_if_fail(doc != NULL && node != NULL, RET_BAD_PARAMS);\n\n  if (!node->is_small_name) {\n    TKMEM_FREE(node->name.str);\n  }\n\n  if (node->value_type == CONF_NODE_VALUE_STRING) {\n    TKMEM_FREE(node->value.str);\n  }\n\n  memset(node, 0x00, sizeof(*node));\n\n  if (node >= doc->prealloc_nodes && node < (doc->prealloc_nodes + doc->prealloc_nodes_nr)) {\n    node->node_type = CONF_NODE_NONE;\n    doc->prealloc_nodes_used--;\n\n    return RET_OK;\n  }\n\n  TKMEM_FREE(node);\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  153,
                  "node->parent"
               ],
               [
                  154,
                  "iter->next"
               ]
            ]
         },
         {
            "type": "func",
            "name": "conf_doc_append_child",
            "line_range": [
               159,
               169
            ],
            "source_code": "ret_t conf_doc_append_child(conf_doc_t* doc, conf_node_t* node, conf_node_t* child) {\n  conf_node_t* first_child = conf_node_get_first_child(node);\n  return_value_if_fail(doc != NULL && node != NULL && child != NULL, RET_BAD_PARAMS);\n\n  if (first_child == NULL) {\n    conf_node_set_first_child(node, child);\n    return RET_OK;\n  } else {\n    return conf_doc_append_sibling(doc, first_child, child);\n  }\n}",
            "key_variables": [
               [
                  181,
                  "sibling->next"
               ],
               [
                  186,
                  "iter->next"
               ]
            ]
         },
         {
            "type": "func",
            "name": "conf_doc_remove_sibling",
            "line_range": [
               171,
               190
            ],
            "source_code": "ret_t conf_doc_remove_sibling(conf_doc_t* doc, conf_node_t* node, conf_node_t* sibling) {\n  conf_node_t* iter = node;\n  return_value_if_fail(doc != NULL && node != NULL && sibling != NULL, RET_BAD_PARAMS);\n\n  if (node == sibling) {\n    return conf_doc_remove_child(doc, node->parent, node);\n  } else {\n    while (iter->next != NULL) {\n      if (iter->next == sibling) {\n        iter->next = sibling->next;\n        sibling->next = NULL;\n        conf_doc_destroy_node(doc, sibling);\n        return RET_OK;\n      }\n      iter = iter->next;\n    }\n  }\n\n  return RET_NOT_FOUND;\n}",
            "key_variables": [
               [
                  220,
                  "iter->next"
               ],
               [
                  227,
                  "iter->next"
               ]
            ]
         },
         {
            "type": "func",
            "name": "conf_doc_remove_children",
            "line_range": [
               232,
               254
            ],
            "source_code": "ret_t conf_doc_remove_children(conf_doc_t* doc, conf_node_t* node) {\n  conf_node_t* iter = NULL;\n  conf_node_t* first_child = conf_node_get_first_child(node);\n  return_value_if_fail(doc != NULL && node != NULL, RET_BAD_PARAMS);\n\n  if (first_child == NULL) {\n    return RET_OK;\n  }\n\n  iter = first_child;\n  return_value_if_fail(iter != NULL, RET_BAD_PARAMS);\n  conf_node_set_first_child(node, NULL);\n\n  while (iter != NULL) {\n    conf_node_t* next = iter->next;\n\n    conf_doc_remove_children(doc, iter);\n    conf_doc_destroy_node(doc, iter);\n    iter = next;\n  }\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  247,
                  "iter->next"
               ],
               [
                  262,
                  "iter->next"
               ]
            ]
         },
         {
            "type": "func",
            "name": "conf_node_get_name",
            "line_range": [
               270,
               274
            ],
            "source_code": "const char* conf_node_get_name(conf_node_t* node) {\n  return_value_if_fail(node != NULL, NULL);\n\n  return node->is_small_name ? node->name.small_str : node->name.str;\n}",
            "key_variables": [
               [
                  284,
                  "first->next"
               ],
               [
                  301,
                  "iter->next"
               ]
            ]
         },
         {
            "type": "func",
            "name": "conf_node_count_children",
            "line_range": [
               276,
               287
            ],
            "source_code": "uint32_t conf_node_count_children(conf_node_t* node) {\n  uint32_t i = 0;\n  conf_node_t* first = conf_node_get_first_child(node);\n  return_value_if_fail(node != NULL, 0);\n\n  while (first != NULL) {\n    i++;\n    first = first->next;\n  }\n\n  return i;\n}",
            "key_variables": [
               [
                  325,
                  "iter->next"
               ]
            ]
         },
         {
            "type": "func",
            "name": "conf_node_find_sibling",
            "line_range": [
               306,
               328
            ],
            "source_code": "conf_node_t* conf_node_find_sibling(conf_node_t* node, const char* name) {\n  conf_node_t* iter = NULL;\n  if (node == NULL) {\n    return NULL;\n  }\n\n  return_value_if_fail(name != NULL, NULL);\n\n  if (node->parent != NULL) {\n    iter = conf_node_get_first_child(node->parent);\n  } else {\n    iter = node;\n  }\n  while (iter != NULL) {\n    if (tk_str_eq(conf_node_get_name(iter), name)) {\n      return iter;\n    }\n\n    iter = iter->next;\n  }\n\n  return NULL;\n}",
            "key_variables": [
               [
                  343,
                  "iter->next"
               ]
            ]
         },
         {
            "type": "func",
            "name": "conf_doc_get_node",
            "line_range": [
               540,
               545
            ],
            "source_code": "static conf_node_t* conf_doc_get_node(conf_doc_t* doc, const char* path,\n                                      bool_t create_if_not_exist) {\n  return_value_if_fail(doc != NULL && path != NULL, NULL);\n\n  return conf_doc_find_node(doc, doc->root, path, create_if_not_exist);\n}",
            "key_variables": [
               [
                  556,
                  "doc->root"
               ],
               [
                  564,
                  "t->cursor"
               ],
               [
                  565,
                  "t->size"
               ]
            ]
         },
         {
            "type": "func",
            "name": "conf_doc_remove",
            "line_range": [
               661,
               673
            ],
            "source_code": "ret_t conf_doc_remove(conf_doc_t* doc, const char* path) {\n  conf_node_t* node = NULL;\n  return_value_if_fail(doc != NULL && path != NULL, RET_BAD_PARAMS);\n\n  node = conf_doc_get_node(doc, path, FALSE);\n\n  if (node != NULL) {\n    conf_doc_remove_children(doc, node);\n    return conf_doc_remove_child(doc, node->parent, node);\n  } else {\n    return RET_NOT_FOUND;\n  }\n}",
            "key_variables": [
               [
                  702,
                  "iter->next"
               ]
            ]
         },
         {
            "type": "func",
            "name": "conf_node_get_prev",
            "line_range": [
               688,
               705
            ],
            "source_code": "static conf_node_t* conf_node_get_prev(conf_node_t* node) {\n  conf_node_t* iter = NULL;\n  return_value_if_fail(node != NULL && node->parent != NULL, NULL);\n  iter = conf_node_get_first_child(node->parent);\n\n  if (iter == node || iter == NULL) {\n    return NULL;\n  }\n\n  while (iter->next != NULL) {\n    if (iter->next == node) {\n      return iter;\n    }\n    iter = iter->next;\n  }\n\n  return NULL;\n}",
            "key_variables": [
               [
                  743,
                  "node->next"
               ]
            ]
         },
         {
            "type": "func",
            "name": "conf_doc_move_up",
            "line_range": [
               727,
               755
            ],
            "source_code": "ret_t conf_doc_move_up(conf_doc_t* doc, const char* path) {\n  conf_node_t* node = NULL;\n  return_value_if_fail(doc != NULL && path != NULL, RET_BAD_PARAMS);\n\n  node = conf_doc_get_node(doc, path, FALSE);\n  if (node != NULL) {\n    conf_node_t* pprev = NULL;\n    conf_node_t* prev = conf_node_get_prev(node);\n\n    if (prev == NULL) {\n      return RET_FAIL;\n    }\n\n    pprev = conf_node_get_prev(prev);\n\n    prev->next = node->next;\n    node->next = prev;\n\n    if (pprev != NULL) {\n      pprev->next = node;\n    } else {\n      conf_node_set_first_child(node->parent, node);\n    }\n\n    return RET_OK;\n  } else {\n    return RET_NOT_FOUND;\n  }\n}",
            "key_variables": [
               [
                  765,
                  "node->next"
               ],
               [
                  771,
                  "next->next"
               ]
            ]
         },
         {
            "type": "func",
            "name": "conf_doc_move_down",
            "line_range": [
               757,
               785
            ],
            "source_code": "ret_t conf_doc_move_down(conf_doc_t* doc, const char* path) {\n  conf_node_t* node = NULL;\n  return_value_if_fail(doc != NULL && path != NULL, RET_BAD_PARAMS);\n\n  node = conf_doc_get_node(doc, path, FALSE);\n  if (node != NULL) {\n    conf_node_t* prev = conf_node_get_prev(node);\n    conf_node_t* next = node->next;\n\n    if (next == NULL) {\n      return RET_FAIL;\n    }\n\n    node->next = next->next;\n    next->next = node;\n\n    if (prev != NULL) {\n      prev->next = next;\n    }\n\n    if (conf_node_get_first_child(node->parent) == node) {\n      conf_node_set_first_child(node->parent, next);\n    }\n\n    return RET_OK;\n  } else {\n    return RET_NOT_FOUND;\n  }\n}",
            "key_variables": [
               [
                  797,
                  "name[TK_NAME_LEN + 1]"
               ]
            ]
         }
      ],
      "src/conf_io/conf_obj.c": [
         {
            "type": "func",
            "name": "conf_obj_destroy",
            "line_range": [
               274,
               284
            ],
            "source_code": "static ret_t conf_obj_destroy(object_t* obj) {\n  conf_obj_t* o = CONF_OBJ(obj);\n  return_value_if_fail(o != NULL, RET_BAD_PARAMS);\n\n  conf_doc_destroy(o->doc);\n  TKMEM_FREE(o->url);\n  TKMEM_FREE(o->default_url);\n  o->doc = NULL;\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  293,
                  "o->doc"
               ]
            ]
         }
      ],
      "src/conf_io/conf_ubjson.c": [
         {
            "type": "func",
            "name": "conf_ubjson_save_node",
            "line_range": [
               73,
               78
            ],
            "source_code": "static ret_t conf_ubjson_save_node(conf_node_t* node, ubjson_writer_t* writer) {\n  const char* name = conf_node_get_name(node);\n  return_value_if_fail(ubjson_writer_write_key(writer, name) == RET_OK, RET_OOM);\n\n  return conf_ubjson_save_node_value(node, writer);\n}",
            "key_variables": [
               [
                  88,
                  "iter->next"
               ]
            ]
         },
         {
            "type": "func",
            "name": "conf_ubjson_save_node_children_object",
            "line_range": [
               80,
               93
            ],
            "source_code": "static ret_t conf_ubjson_save_node_children_object(conf_node_t* node, ubjson_writer_t* writer) {\n  conf_node_t* iter = conf_node_get_first_child(node);\n  return_value_if_fail(node != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(ubjson_writer_write_object_begin(writer) == RET_OK, RET_OOM);\n\n  while (iter != NULL) {\n    return_value_if_fail(conf_ubjson_save_node(iter, writer) == RET_OK, RET_OOM);\n    iter = iter->next;\n  }\n\n  return_value_if_fail(ubjson_writer_write_object_end(writer) == RET_OK, RET_OOM);\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  103,
                  "iter->next"
               ]
            ]
         },
         {
            "type": "func",
            "name": "conf_doc_save_ubjson",
            "line_range": [
               123,
               127
            ],
            "source_code": "ret_t conf_doc_save_ubjson(conf_doc_t* doc, ubjson_writer_t* writer) {\n  return_value_if_fail(doc != NULL && doc->root != NULL && writer != NULL, RET_BAD_PARAMS);\n\n  return conf_ubjson_save_node_children(doc->root, writer);\n}",
            "key_variables": [
               [
                  138,
                  "parser->node"
               ],
               [
                  145,
                  "current->parent"
               ]
            ]
         }
      ],
      "src/csv/csv_file.c": [
         {
            "type": "func",
            "name": "csv_row_set",
            "line_range": [
               130,
               179
            ],
            "source_code": "ret_t csv_row_set(csv_row_t* row, uint32_t col, const char* value) {\n  char* p = NULL;\n  uint32_t old_len = 0;\n  uint32_t new_len = 0;\n  return_value_if_fail(row != NULL && value != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(row->buff != NULL, RET_BAD_PARAMS);\n  p = (char*)csv_row_get(row, col);\n  return_value_if_fail(p != NULL, RET_BAD_PARAMS);\n\n  old_len = strlen(p);\n  new_len = strlen(value);\n\n  if (old_len == new_len) {\n    strcpy(p, value);\n    return RET_OK;\n  } else if (old_len > new_len) {\n    uint32_t len = row->size - (p + old_len - row->buff);\n    strcpy(p, value);\n    memmove(p + new_len, p + old_len, len);\n    row->size = row->size + new_len - old_len;\n    return RET_OK;\n  } else {\n    uint32_t d = 0;\n    uint32_t s = 0;\n    uint32_t size = 0;\n    uint32_t len = row->size + new_len - old_len;\n    char* buff = TKMEM_ALLOC(len);\n    return_value_if_fail(buff != NULL, RET_OOM);\n\n    memset(buff, 0x00, len);\n    size = p - row->buff;\n    memcpy(buff, row->buff, size);\n\n    d = size;\n    s = size;\n    memcpy(buff + d, value, new_len + 1);\n\n    d += new_len + 1;\n    s += old_len + 1;\n    size = row->size - s;\n    memcpy(buff + d, row->buff + s, size);\n\n    csv_row_reset(row);\n\n    row->buff = buff;\n    row->size = len;\n    row->should_free_buff = TRUE;\n    return RET_OK;\n  }\n}",
            "key_variables": [
               [
                  161,
                  "row->buff"
               ]
            ]
         },
         {
            "type": "func",
            "name": "csv_row_init",
            "line_range": [
               181,
               189
            ],
            "source_code": "ret_t csv_row_init(csv_row_t* row, char* buff, uint32_t size, bool_t should_free_buff) {\n  return_value_if_fail(row != NULL && buff != NULL, RET_BAD_PARAMS);\n\n  row->buff = buff;\n  row->size = size;\n  row->should_free_buff = should_free_buff;\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  193,
                  "row->buff"
               ],
               [
                  194,
                  "row->buff"
               ]
            ]
         },
         {
            "type": "func",
            "name": "csv_row_set_data",
            "line_range": [
               230,
               240
            ],
            "source_code": "ret_t csv_row_set_data(csv_row_t* row, const char* data, char sep) {\n  csv_row_reset(row);\n\n  row->buff = tk_strdup(data);\n  return_value_if_fail(row->buff != NULL, RET_OOM);\n\n  row->should_free_buff = TRUE;\n  row->size = strlen(data) + 1;\n\n  return csv_row_parse(row, sep);\n}",
            "key_variables": [
               [
                  262,
                  "rows->rows"
               ]
            ]
         },
         {
            "type": "func",
            "name": "csv_rows_remove",
            "line_range": [
               272,
               286
            ],
            "source_code": "ret_t csv_rows_remove(csv_rows_t* rows, uint32_t row) {\n  uint32_t i = 0;\n  csv_row_t* r = NULL;\n  return_value_if_fail(rows != NULL && row < rows->size, RET_BAD_PARAMS);\n\n  csv_row_reset(rows->rows + row);\n\n  r = rows->rows;\n  for (i = row; i < rows->size; i++) {\n    r[i] = r[i + 1];\n  }\n  rows->size--;\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  280,
                  "rows->rows"
               ],
               [
                  281,
                  "rows->size"
               ],
               [
                  282,
                  "r[i + 1]"
               ]
            ]
         },
         {
            "type": "func",
            "name": "csv_rows_append",
            "line_range": [
               288,
               296
            ],
            "source_code": "csv_row_t* csv_rows_append(csv_rows_t* rows) {\n  csv_row_t* r = NULL;\n  return_value_if_fail(csv_rows_extend_rows(rows, 1) == RET_OK, NULL);\n\n  r = rows->rows + rows->size++;\n  memset(r, 0x00, sizeof(*r));\n\n  return r;\n}",
            "key_variables": [
               [
                  309,
                  "rows->rows"
               ],
               [
                  310,
                  "rows->size"
               ],
               [
                  311,
                  "r[i - 1]"
               ]
            ]
         },
         {
            "type": "func",
            "name": "csv_rows_init",
            "line_range": [
               334,
               344
            ],
            "source_code": "ret_t csv_rows_init(csv_rows_t* rows, uint32_t init_capacity) {\n  return_value_if_fail(rows != NULL, RET_BAD_PARAMS);\n\n  init_capacity = tk_max(10, init_capacity);\n\n  rows->size = 0;\n  rows->capacity = init_capacity;\n  rows->rows = TKMEM_ZALLOCN(csv_row_t, init_capacity);\n\n  return rows->rows != NULL ? RET_OK : RET_OOM;\n}",
            "key_variables": [
               [
                  364,
                  "csv->sep"
               ]
            ]
         },
         {
            "type": "func",
            "name": "csv_file_get_rows",
            "line_range": [
               512,
               516
            ],
            "source_code": "uint32_t csv_file_get_rows(csv_file_t* csv) {\n  return_value_if_fail(csv != NULL, 0);\n\n  return csv->rows.size;\n}",
            "key_variables": [
               [
                  527,
                  "rows->size"
               ],
               [
                  540,
                  "csv->cols"
               ]
            ]
         },
         {
            "type": "func",
            "name": "csv_file_get_cols",
            "line_range": [
               536,
               540
            ],
            "source_code": "uint32_t csv_file_get_cols(csv_file_t* csv) {\n  return_value_if_fail(csv != NULL, 0);\n\n  return csv->cols;\n}",
            "key_variables": [
               [
                  564,
                  "r->checked"
               ]
            ]
         },
         {
            "type": "func",
            "name": "csv_file_set",
            "line_range": [
               542,
               548
            ],
            "source_code": "ret_t csv_file_set(csv_file_t* csv, uint32_t row, uint32_t col, const char* value) {\n  csv_row_t* r = csv_file_get_row(csv, row);\n  return_value_if_fail(r != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(col < csv_file_get_cols(csv), RET_BAD_PARAMS);\n\n  return csv_row_set(r, col, value);\n}",
            "key_variables": [
               [
                  575,
                  "rows->size"
               ],
               [
                  580,
                  "rows[i]"
               ]
            ]
         },
         {
            "type": "func",
            "name": "csv_file_insert_row",
            "line_range": [
               594,
               602
            ],
            "source_code": "ret_t csv_file_insert_row(csv_file_t* csv, uint32_t row, const char* data) {\n  csv_row_t* r = NULL;\n  return_value_if_fail(csv != NULL && data != NULL, RET_BAD_PARAMS);\n\n  r = csv_rows_insert(&(csv->rows), row);\n  return_value_if_fail(r != NULL, RET_OOM);\n\n  return csv_row_set_data(r, data, csv->sep);\n}",
            "key_variables": [
               [
                  627,
                  "csv->filename"
               ]
            ]
         },
         {
            "type": "func",
            "name": "csv_file_append_row",
            "line_range": [
               604,
               612
            ],
            "source_code": "ret_t csv_file_append_row(csv_file_t* csv, const char* data) {\n  csv_row_t* r = NULL;\n  return_value_if_fail(csv != NULL && data != NULL, RET_BAD_PARAMS);\n\n  r = csv_rows_append(&(csv->rows));\n  return_value_if_fail(r != NULL, RET_OOM);\n\n  return csv_row_set_data(r, data, csv->sep);\n}",
            "key_variables": [
               [
                  659,
                  "r->buff"
               ]
            ]
         }
      ],
      "src/csv/csv_file_object.c": [
         {
            "type": "func",
            "name": "csv_file_object_cast",
            "line_range": [
               224,
               228
            ],
            "source_code": "static csv_file_object_t* csv_file_object_cast(object_t* obj) {\n  return_value_if_fail(obj != NULL && obj->vt == &s_csv_file_object_vtable, NULL);\n\n  return (csv_file_object_t*)obj;\n}",
            "key_variables": [
               [
                  250,
                  "o->csv"
               ]
            ]
         }
      ],
      "src/dialog_highlighters/dialog_highlighter_default.c": [
         {
            "type": "func",
            "name": "dialog_highlighter_default_draw_mask_from_percent",
            "line_range": [
               54,
               66
            ],
            "source_code": "static ret_t dialog_highlighter_default_draw_mask_from_percent(dialog_highlighter_t* h, canvas_t* c,\n                                                               float_t percent) {\n  dialog_highlighter_default_t* dh = (dialog_highlighter_default_t*)h;\n\n  return_value_if_fail(dh != NULL && c != NULL, RET_BAD_PARAMS);\n\n  if (dh->start_alpha != dh->end_alpha) {\n    uint8_t a = ((dh->end_alpha - dh->start_alpha) * percent) + dh->start_alpha;\n    return dialog_highlighter_default_draw_mask(c, a);\n  } else {\n    return dialog_highlighter_default_draw_mask(c, dh->end_alpha);\n  }\n}",
            "key_variables": [
               [
                  62,
                  "dh->start_alpha"
               ]
            ]
         },
         {
            "type": "func",
            "name": "dialog_highlighter_default_get_alpha",
            "line_range": [
               77,
               86
            ],
            "source_code": "uint8_t dialog_highlighter_default_get_alpha(dialog_highlighter_t* h, float_t percent) {\n  dialog_highlighter_default_t* dh = (dialog_highlighter_default_t*)h;\n  return_value_if_fail(dh != NULL, 0x0);\n\n  if (dh->start_alpha == dh->end_alpha) {\n    return dh->start_alpha;\n  } else {\n    return (0xff * (dh->end_alpha - dh->start_alpha) * percent) / 0xff;\n  }\n}",
            "key_variables": [
               [
                  83,
                  "dh->start_alpha"
               ]
            ]
         },
         {
            "type": "func",
            "name": "dialog_highlighter_default_prepare",
            "line_range": [
               88,
               102
            ],
            "source_code": "static ret_t dialog_highlighter_default_prepare(dialog_highlighter_t* h, canvas_t* c) {\n  dialog_highlighter_default_t* dh = (dialog_highlighter_default_t*)h;\n  return_value_if_fail(h != NULL && h->vt != NULL && c != NULL, RET_BAD_PARAMS);\n\n  /*\n   * optimization:\n   * if dh->start_alpha == dh->end_alpha, we draw mask layer only at the first time.\n   */\n  if (dh->start_alpha == dh->end_alpha) {\n    window_manager_paint_system_bar(window_manager(), c);\n    dialog_highlighter_default_draw_mask(c, dh->start_alpha);\n  }\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  108,
                  "h->canvas"
               ],
               [
                  130,
                  "dh->start_alpha"
               ]
            ]
         }
      ],
      "src/ext_widgets/color_picker/color_component.c": [
         {
            "type": "func",
            "name": "color_component_dispatch_change_event",
            "line_range": [
               32,
               47
            ],
            "source_code": "static ret_t color_component_dispatch_change_event(widget_t* widget, uint32_t etype) {\n  uint32_t value = 0;\n  value_change_event_t evt;\n  value_change_event_init(&evt, etype, widget);\n  color_component_t* color_component = COLOR_COMPONENT(widget);\n  return_value_if_fail(color_component != NULL, RET_BAD_PARAMS);\n  value = (color_component->color_x & 0xffff) << 16;\n  value |= color_component->color_y;\n\n  value_set_uint32(&(evt.old_value), value);\n  value_set_uint32(&(evt.new_value), value);\n  widget_dispatch(widget, (event_t*)&evt);\n  widget_invalidate_force(widget, NULL);\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  40,
                  "color_component->color_y"
               ]
            ]
         },
         {
            "type": "func",
            "name": "color_component_on_event",
            "line_range": [
               61,
               94
            ],
            "source_code": "static ret_t color_component_on_event(widget_t* widget, event_t* e) {\n  uint16_t type = e->type;\n  color_component_t* component = COLOR_COMPONENT(widget);\n  return_value_if_fail(component != NULL, RET_BAD_PARAMS);\n\n  switch (type) {\n    case EVT_POINTER_DOWN: {\n      pointer_event_t* evt = (pointer_event_t*)e;\n      color_component_update_pressed(widget, evt);\n      widget_grab(widget->parent, widget);\n      component->pressed = TRUE;\n    } break;\n    case EVT_POINTER_MOVE: {\n      pointer_event_t* evt = (pointer_event_t*)e;\n      if (component->pressed) {\n        color_component_update_pressed(widget, evt);\n        return RET_STOP;\n      }\n      break;\n    }\n    case EVT_POINTER_UP: {\n      widget_ungrab(widget->parent, widget);\n      if (component->pressed) {\n        color_component_dispatch_change_event(widget, EVT_VALUE_CHANGING);\n        component->pressed = FALSE;\n      }\n      break;\n    }\n    default:\n      break;\n  }\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  63,
                  "e->type"
               ],
               [
                  100,
                  "widget->w"
               ],
               [
                  101,
                  "widget->h"
               ]
            ]
         },
         {
            "type": "func",
            "name": "color_component_create_image",
            "line_range": [
               161,
               169
            ],
            "source_code": "static bitmap_t* color_component_create_image(int32_t w, int32_t h) {\n#ifdef WITH_BITMAP_BGRA\n  bitmap_format_t format = BITMAP_FMT_BGRA8888;\n#else\n  bitmap_format_t format = BITMAP_FMT_RGBA8888;\n#endif /*WITH_BITMAP_BGRA*/\n\n  return bitmap_create_ex(w, h, 0, format);\n}",
            "key_variables": [
               [
                  199,
                  "color_component->image"
               ],
               [
                  228,
                  "color_component->image"
               ],
               [
                  229,
                  "image->w"
               ],
               [
                  230,
                  "image->h"
               ],
               [
                  235,
                  "color_component->last_hue"
               ]
            ]
         },
         {
            "type": "func",
            "name": "color_component_update_h",
            "line_range": [
               255,
               291
            ],
            "source_code": "static ret_t color_component_update_h(widget_t* widget) {\n  float H = 0;\n  float S = 1;\n  float V = 1;\n  uint8_t r = 0;\n  uint8_t g = 0;\n  uint8_t b = 0;\n  int32_t x = 0;\n  int32_t y = 0;\n  uint32_t v = 0;\n  int32_t w = 0;\n  int32_t h = 0;\n  uint32_t* dst = NULL;\n  bitmap_t* image = NULL;\n  uint8_t* image_data = NULL;\n  color_component_t* color_component = COLOR_COMPONENT(widget);\n  return_value_if_fail(widget != NULL && color_component != NULL, RET_BAD_PARAMS);\n\n  image = color_component->image;\n  w = image->w;\n  h = image->h;\n  image_data = bitmap_lock_buffer_for_write(image);\n  dst = (uint32_t*)(image_data);\n\n  for (y = 0; y < h; y++) {\n    dst = (uint32_t*)(image_data + y * image->line_length);\n    H = (1 - (float)y / (float)h) * 360;\n    convertHSVtoRGB(H, S, V, &r, &g, &b);\n    v = rgb_to_image8888(r, g, b);\n    for (x = 0; x < w; x++) {\n      *dst++ = v;\n    }\n  }\n  bitmap_unlock_buffer(image);\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  274,
                  "color_component->image"
               ],
               [
                  275,
                  "image->w"
               ],
               [
                  276,
                  "image->h"
               ]
            ]
         },
         {
            "type": "func",
            "name": "color_component_create",
            "line_range": [
               293,
               302
            ],
            "source_code": "widget_t* color_component_create(widget_t* parent, xy_t x, xy_t y, wh_t w, wh_t h) {\n  widget_t* widget = widget_create(parent, TK_REF_VTABLE(color_component), x, y, w, h);\n  color_component_t* color_component = COLOR_COMPONENT(widget);\n  return_value_if_fail(color_component != NULL, NULL);\n\n  color_component->c = color_init(0xff, 0xff, 0xff, 0xff);\n  color_component->last_hue = -1;\n\n  return widget;\n}",
            "key_variables": [
               [
                  320,
                  "widget->w"
               ],
               [
                  321,
                  "widget->h"
               ],
               [
                  323,
                  "widget->h"
               ]
            ]
         },
         {
            "type": "func",
            "name": "color_component_set_color",
            "line_range": [
               304,
               327
            ],
            "source_code": "ret_t color_component_set_color(widget_t* widget, color_t c) {\n  float H = 0;\n  float S = 0;\n  float V = 0;\n  color_component_t* color_component = COLOR_COMPONENT(widget);\n  return_value_if_fail(color_component != NULL, RET_BAD_PARAMS);\n\n  color_component->c = c;\n  convertRGBtoHSV(c.rgba.r, c.rgba.g, c.rgba.b, &H, &S, &V);\n  if (color_component->update == color_component_update_sv) {\n    if ((int32_t)H != color_component->last_hue) {\n      color_component->need_update = TRUE;\n      log_debug(\"hue changed(%d != %d)\\n\", color_component->last_hue, (int32_t)H);\n      color_component->last_hue = -1;\n    }\n    color_component->color_x = V * widget->w;\n    color_component->color_y = (1 - S) * widget->h;\n  } else {\n    color_component->color_y = (1 - H / 360.0f) * widget->h;\n  }\n  widget_invalidate(widget, NULL);\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  344,
                  "widget->w"
               ],
               [
                  345,
                  "widget->h"
               ],
               [
                  347,
                  "widget->h"
               ]
            ]
         },
         {
            "type": "func",
            "name": "color_component_set_type",
            "line_range": [
               353,
               368
            ],
            "source_code": "static ret_t color_component_set_type(widget_t* widget, const char* type) {\n  color_component_t* color_component = COLOR_COMPONENT(widget);\n  return_value_if_fail(color_component != NULL && type != NULL, RET_BAD_PARAMS);\n\n  color_component->image->name = type;\n\n  if (tk_str_eq(type, COLOR_PICKER_CHILD_SV)) {\n    color_component->update = color_component_update_sv;\n  } else if (tk_str_eq(type, COLOR_PICKER_CHILD_H)) {\n    color_component->update = color_component_update_h;\n  } else {\n    log_debug(\"not supported color type\\n\");\n  }\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  375,
                  "widget->h"
               ]
            ]
         }
      ],
      "src/ext_widgets/color_picker/color_picker.c": [
         {
            "type": "func",
            "name": "color_picker_update_child",
            "line_range": [
               63,
               158
            ],
            "source_code": "static ret_t color_picker_update_child(void* ctx, const void* iter) {\n  color_t c;\n  float h = 0;\n  float s = 0;\n  float v = 0;\n  int32_t value = 0;\n  widget_t* child = NULL;\n  const char* name = NULL;\n  const char* type = NULL;\n  color_picker_t* color_picker = COLOR_PICKER(ctx);\n  return_value_if_fail(ctx != NULL && color_picker != NULL && iter != NULL, RET_REMOVE);\n\n  child = WIDGET(iter);\n  return_value_if_fail(child != NULL, RET_REMOVE);\n\n  name = child->name;\n  type = child->vt->type;\n  c = color_picker->c;\n\n  if (color_picker->trigger_child == child) {\n    return RET_OK;\n  }\n\n  if (child->emitter) {\n    emitter_disable(child->emitter);\n  }\n\n  if (tk_str_eq(type, WIDGET_TYPE_EDIT) || tk_str_eq(type, WIDGET_TYPE_SPIN_BOX)) {\n    if (tk_str_eq(name, COLOR_PICKER_CHILD_R)) {\n      value = c.rgba.r;\n      edit_set_int(child, value);\n    } else if (tk_str_eq(name, COLOR_PICKER_CHILD_G)) {\n      value = c.rgba.g;\n      edit_set_int(child, value);\n    } else if (tk_str_eq(name, COLOR_PICKER_CHILD_B)) {\n      value = c.rgba.b;\n      edit_set_int(child, value);\n    } else if (tk_str_eq(name, COLOR_PICKER_CHILD_H)) {\n      value = color_picker->last_hue;\n      edit_set_int(child, value);\n    } else if (tk_str_eq(name, COLOR_PICKER_CHILD_S)) {\n      convertRGBtoHSV(c.rgba.r, c.rgba.g, c.rgba.b, &h, &s, &v);\n      value = s * 100;\n      edit_set_int(child, value);\n    } else if (tk_str_eq(name, COLOR_PICKER_CHILD_V)) {\n      convertRGBtoHSV(c.rgba.r, c.rgba.g, c.rgba.b, &h, &s, &v);\n      value = v * 100;\n      edit_set_int(child, value);\n    } else if (tk_str_eq(name, COLOR_PICKER_CHILD_NEW)) {\n      char hex[TK_COLOR_HEX_LEN + 1];\n      color_hex_str(color_picker->c, hex);\n      widget_set_text_utf8(child, hex + 1);\n    } else if (tk_str_eq(name, COLOR_PICKER_CHILD_OLD)) {\n      char hex[TK_COLOR_HEX_LEN + 1];\n      color_hex_str(color_picker->init_c, hex);\n      widget_set_text_utf8(child, hex + 1);\n    }\n  } else if (tk_str_eq(type, WIDGET_TYPE_SLIDER)) {\n    if (tk_str_eq(name, COLOR_PICKER_CHILD_R)) {\n      value = color_picker->c_r_value * 100 / 255;\n    } else if (tk_str_eq(name, COLOR_PICKER_CHILD_G)) {\n      value = color_picker->c_g_value * 100 / 255;\n    } else if (tk_str_eq(name, COLOR_PICKER_CHILD_B)) {\n      value = color_picker->c_b_value * 100 / 255;\n    } else if (tk_str_eq(name, COLOR_PICKER_CHILD_H)) {\n      value = color_picker->last_hue * 100 / 360;\n    } else if (tk_str_eq(name, COLOR_PICKER_CHILD_S)) {\n      convertRGBtoHSV(c.rgba.r, c.rgba.g, c.rgba.b, &h, &s, &v);\n      value = s * 100;\n    } else if (tk_str_eq(name, COLOR_PICKER_CHILD_V)) {\n      convertRGBtoHSV(c.rgba.r, c.rgba.g, c.rgba.b, &h, &s, &v);\n      value = v * 100;\n    }\n    widget_set_value(child, value);\n  } else if (tk_str_eq(type, WIDGET_TYPE_COLOR_COMPONENT)) {\n    if (tk_str_eq(name, COLOR_PICKER_CHILD_SV)) {\n      convertRGBtoHSV(c.rgba.r, c.rgba.g, c.rgba.b, &h, &s, &v);\n      color_component_set_hsv(child, color_picker->last_hue, s, v);\n    } else if (tk_str_eq(name, COLOR_PICKER_CHILD_H)) {\n      convertRGBtoHSV(c.rgba.r, c.rgba.g, c.rgba.b, &h, &s, &v);\n      color_component_set_hsv(child, color_picker->last_hue, s, v);\n    }\n  } else if (tk_str_eq(type, WIDGET_TYPE_COLOR_TILE)) {\n    if (tk_str_eq(name, COLOR_PICKER_CHILD_NEW)) {\n      color_tile_set_value(child, c);\n    } else if (tk_str_eq(name, COLOR_PICKER_CHILD_OLD)) {\n      color_tile_set_value(child, color_picker->init_c);\n    }\n  }\n\n  if (child->emitter) {\n    emitter_enable(child->emitter);\n  }\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  79,
                  "child->name"
               ],
               [
                  80,
                  "vt->type"
               ],
               [
                  81,
                  "color_picker->c"
               ],
               [
                  102,
                  "color_picker->last_hue"
               ],
               [
                  113,
                  "hex[TK_COLOR_HEX_LEN + 1]"
               ],
               [
                  117,
                  "hex[TK_COLOR_HEX_LEN + 1]"
               ]
            ]
         },
         {
            "type": "func",
            "name": "color_picker_set_color_r",
            "line_range": [
               168,
               178
            ],
            "source_code": "static ret_t color_picker_set_color_r(widget_t* widget, float_t r) {\n  color_t c;\n  color_picker_t* color_picker = COLOR_PICKER(widget);\n  return_value_if_fail(widget != NULL && color_picker != NULL, RET_BAD_PARAMS);\n\n  c = color_picker->c;\n  c.rgba.r = (uint8_t)r;\n  color_picker->c_r_value = r;\n\n  return color_picker_update_color(widget, c);\n}",
            "key_variables": [
               [
                  174,
                  "color_picker->c"
               ],
               [
                  186,
                  "color_picker->c"
               ]
            ]
         },
         {
            "type": "func",
            "name": "color_picker_set_color_g",
            "line_range": [
               180,
               190
            ],
            "source_code": "static ret_t color_picker_set_color_g(widget_t* widget, float_t g) {\n  color_t c;\n  color_picker_t* color_picker = COLOR_PICKER(widget);\n  return_value_if_fail(widget != NULL && color_picker != NULL, RET_BAD_PARAMS);\n\n  c = color_picker->c;\n  c.rgba.g = (uint8_t)g;\n  color_picker->c_g_value = g;\n\n  return color_picker_update_color(widget, c);\n}",
            "key_variables": [
               [
                  198,
                  "color_picker->c"
               ]
            ]
         },
         {
            "type": "func",
            "name": "color_picker_set_color_b",
            "line_range": [
               192,
               202
            ],
            "source_code": "static ret_t color_picker_set_color_b(widget_t* widget, float_t b) {\n  color_t c;\n  color_picker_t* color_picker = COLOR_PICKER(widget);\n  return_value_if_fail(widget != NULL && color_picker != NULL, RET_BAD_PARAMS);\n\n  c = color_picker->c;\n  c.rgba.b = (uint8_t)b;\n  color_picker->c_b_value = b;\n\n  return color_picker_update_color(widget, c);\n}",
            "key_variables": [
               [
                  214,
                  "color_picker->c"
               ],
               [
                  229,
                  "color_picker->c"
               ]
            ]
         },
         {
            "type": "func",
            "name": "color_picker_set_color_v",
            "line_range": [
               235,
               248
            ],
            "source_code": "static ret_t color_picker_set_color_v(widget_t* widget, float vv) {\n  color_t c;\n  float h = 0;\n  float s = 0;\n  float v = 0;\n  color_picker_t* color_picker = COLOR_PICKER(widget);\n  return_value_if_fail(widget != NULL && color_picker != NULL, RET_BAD_PARAMS);\n\n  c = color_picker->c;\n  convertRGBtoHSV(c.rgba.r, c.rgba.g, c.rgba.b, &h, &s, &v);\n  convertHSVtoRGB(h, s, vv, &(c.rgba.r), &(c.rgba.g), &(c.rgba.b));\n\n  return color_picker_update_color(widget, c);\n}",
            "key_variables": [
               [
                  244,
                  "color_picker->c"
               ],
               [
                  259,
                  "color_picker->c"
               ],
               [
                  261,
                  "color_picker->last_hue"
               ]
            ]
         },
         {
            "type": "func",
            "name": "color_picker_set_color_sv",
            "line_range": [
               250,
               264
            ],
            "source_code": "static ret_t color_picker_set_color_sv(widget_t* widget, float ss, float vv) {\n  color_t c;\n  float h = 0;\n  float s = 0;\n  float v = 0;\n  color_picker_t* color_picker = COLOR_PICKER(widget);\n  return_value_if_fail(widget != NULL && color_picker != NULL, RET_BAD_PARAMS);\n\n  c = color_picker->c;\n  convertRGBtoHSV(c.rgba.r, c.rgba.g, c.rgba.b, &h, &s, &v);\n  if (color_picker->last_hue != -1) h = color_picker->last_hue;\n  convertHSVtoRGB(h, ss, vv, &(c.rgba.r), &(c.rgba.g), &(c.rgba.b));\n\n  return color_picker_update_color(widget, c);\n}",
            "key_variables": [
               [
                  278,
                  "child->name"
               ],
               [
                  299,
                  "color[32]"
               ],
               [
                  327,
                  "color_cmp->last_hue"
               ]
            ]
         },
         {
            "type": "func",
            "name": "color_picker_on_child_value_changing",
            "line_range": [
               266,
               336
            ],
            "source_code": "static ret_t color_picker_on_child_value_changing(void* ctx, event_t* e) {\n  widget_t* widget = NULL;\n  widget_t* child = NULL;\n  const char* name = NULL;\n  const char* type = NULL;\n  color_picker_t* color_picker = COLOR_PICKER(ctx);\n  return_value_if_fail(e != NULL && color_picker != NULL, RET_BAD_PARAMS);\n\n  color_picker->last_hue = -1;\n  widget = WIDGET(ctx);\n  child = WIDGET(e->target);\n  name = child->name;\n  return_value_if_fail(child != NULL && child->vt != NULL, RET_BAD_PARAMS);\n\n  type = widget_get_type(child);\n  color_picker->trigger_child = child;\n  if (tk_str_eq(type, WIDGET_TYPE_EDIT) || tk_str_eq(type, WIDGET_TYPE_SPIN_BOX)) {\n    int32_t v = edit_get_int(child);\n\n    if (tk_str_eq(name, COLOR_PICKER_CHILD_R)) {\n      color_picker_set_color_r(widget, v);\n    } else if (tk_str_eq(name, COLOR_PICKER_CHILD_G)) {\n      color_picker_set_color_g(widget, v);\n    } else if (tk_str_eq(name, COLOR_PICKER_CHILD_B)) {\n      color_picker_set_color_b(widget, v);\n    } else if (tk_str_eq(name, COLOR_PICKER_CHILD_H)) {\n      color_picker_set_color_h(widget, v);\n    } else if (tk_str_eq(name, COLOR_PICKER_CHILD_S)) {\n      color_picker_set_color_s(widget, (float)v / 100.0f);\n    } else if (tk_str_eq(name, COLOR_PICKER_CHILD_V)) {\n      color_picker_set_color_v(widget, (float)v / 100.0f);\n    } else if (tk_str_eq(name, COLOR_PICKER_CHILD_NEW)) {\n      char color[32];\n      memset(color, 0x00, sizeof(color));\n      color[0] = '#';\n      wstr_get_utf8(&(child->text), color + 1, sizeof(color) - 2);\n      if (strlen(color) == 7) {\n        color_picker_set_color(widget, color);\n      }\n    }\n  } else if (tk_str_eq(type, WIDGET_TYPE_SLIDER)) {\n    int32_t v = widget_get_value(child);\n    if (tk_str_eq(name, COLOR_PICKER_CHILD_R)) {\n      color_picker_set_color_r(widget, v * 255 / 100.0f);\n    } else if (tk_str_eq(name, COLOR_PICKER_CHILD_G)) {\n      color_picker_set_color_g(widget, v * 255 / 100.0f);\n    } else if (tk_str_eq(name, COLOR_PICKER_CHILD_B)) {\n      color_picker_set_color_b(widget, v * 255 / 100.0f);\n    } else if (tk_str_eq(name, COLOR_PICKER_CHILD_H)) {\n      color_picker_set_color_h(widget, v * 360 / 100);\n    } else if (tk_str_eq(name, COLOR_PICKER_CHILD_S)) {\n      color_picker_set_color_s(widget, (float)v / 100.0f);\n    } else if (tk_str_eq(name, COLOR_PICKER_CHILD_V)) {\n      color_picker_set_color_v(widget, (float)v / 100.0f);\n    }\n  } else if (tk_str_eq(type, WIDGET_TYPE_COLOR_COMPONENT)) {\n    if (tk_str_eq(name, COLOR_PICKER_CHILD_SV)) {\n      color_component_t* color_cmp = COLOR_COMPONENT(child);\n      float s = color_component_get_s(child);\n      float v = color_component_get_v(child);\n      color_picker->last_hue = color_cmp->last_hue;\n      color_picker_set_color_sv(widget, s, v);\n    } else if (tk_str_eq(name, COLOR_PICKER_CHILD_H)) {\n      float h = color_component_get_h(child);\n      color_picker_set_color_h(widget, h);\n    }\n  }\n  color_picker->trigger_child = NULL;\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  345,
                  "child->name"
               ]
            ]
         }
      ],
      "src/ext_widgets/combo_box_ex/combo_box_ex.c": [
         {
            "type": "func",
            "name": "combo_box_ex_create_popup_items",
            "line_range": [
               32,
               51
            ],
            "source_code": "static ret_t combo_box_ex_create_popup_items(combo_box_t* combo_box, widget_t* parent) {\n  combo_box_option_t* iter = NULL;\n  return_value_if_fail(combo_box != NULL, RET_BAD_PARAMS);\n\n  iter = combo_box->option_items;\n  while (iter != NULL) {\n    widget_t* item = combo_box_item_create(parent, 0, 0, 0, 0);\n\n    widget_set_value(item, iter->value);\n    if (combo_box->localize_options) {\n      widget_set_tr_text(item, iter->text);\n    } else {\n      widget_set_text_utf8(item, iter->text);\n    }\n\n    iter = iter->next;\n  }\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  37,
                  "combo_box->option_items"
               ],
               [
                  48,
                  "iter->next"
               ]
            ]
         },
         {
            "type": "func",
            "name": "combo_box_ex_on_layout_children_for_combobox_popup",
            "line_range": [
               53,
               80
            ],
            "source_code": "static ret_t combo_box_ex_on_layout_children_for_combobox_popup(widget_t* widget) {\n  combo_box_t* combo_box = COMBO_BOX(widget);\n  return_value_if_fail(combo_box != NULL, RET_BAD_PARAMS);\n\n  if (combo_box->combobox_popup != NULL) {\n    point_t p = {0, 0};\n    int32_t margin = COMBO_BOX_EX_DEFAULT_MARGIN;\n    int32_t item_height = combo_box->item_height;\n    int32_t nr = combo_box_count_options(widget);\n    int32_t h = nr * item_height + 2 * margin;\n    if (nr <= COMBO_BOX_EX_DEFAULT_MAXNR) {\n      h = nr * item_height + 2 * margin;\n    } else {\n      h = COMBO_BOX_EX_DEFAULT_MAXNR * item_height + 2 * margin;\n    }\n    widget_to_screen(widget, &p);\n    if ((p.y + widget->h + h) < combo_box->combobox_popup->parent->h) {\n      p.y += widget->h;\n    } else if (p.y >= h) {\n      p.y -= widget->h;\n    } else {\n      p.y = 0;\n    }\n\n    widget_move_resize(combo_box->combobox_popup, p.x, p.y, widget->w, h);\n  }\n  return RET_OK;\n}",
            "key_variables": [
               [
                  61,
                  "combo_box->item_height"
               ],
               [
                  71,
                  "widget->h"
               ],
               [
                  73,
                  "widget->h"
               ]
            ]
         },
         {
            "type": "func",
            "name": "combo_box_ex_create_scroll_popup",
            "line_range": [
               82,
               127
            ],
            "source_code": "static widget_t* combo_box_ex_create_scroll_popup(combo_box_t* combo_box) {\n  value_t v;\n  widget_t* win = NULL;\n  widget_t* list_view = NULL;\n  widget_t* scroll_view = NULL;\n  widget_t* scroll_bar = NULL;\n  widget_t* widget = WIDGET(combo_box);\n  int32_t margin = COMBO_BOX_EX_DEFAULT_MARGIN;\n  int32_t item_height = combo_box->item_height;\n  int32_t nr = combo_box_count_options(widget);\n  int32_t w = widget->w;\n  int32_t h = nr * item_height + 2 * margin;\n  if (nr <= COMBO_BOX_EX_DEFAULT_MAXNR) {\n    h = nr * item_height + 2 * margin;\n  } else {\n    h = COMBO_BOX_EX_DEFAULT_MAXNR * item_height + 2 * margin;\n  }\n\n  // create popup\n  win = popup_create(NULL, 0, 0, w, h);\n  value_set_bool(&v, TRUE);\n  widget_set_prop(win, WIDGET_PROP_CLOSE_WHEN_CLICK_OUTSIDE, &v);\n  widget_set_prop_str(win, WIDGET_PROP_THEME, \"combobox_ex_popup\");\n\n  w -= 2 * margin;\n  h -= 2 * margin;\n\n  // create list view\n  list_view = list_view_create(win, margin, margin, w, h);\n  widget_set_prop(list_view, WIDGET_PROP_AUTO_HIDE_SCROLL_BAR, &v);\n  value_set_int32(&v, item_height);\n  widget_set_prop(list_view, WIDGET_PROP_ITEM_HEIGHT, &v);\n  // create scroll view\n  scroll_view = scroll_view_create(list_view, 0, 0, -12, h);\n  scroll_bar = scroll_bar_create(list_view, 0, 0, 0, 0);\n  widget_set_self_layout(scroll_bar, \"default(x=right, y=0,w=12, h=100%)\");\n\n  widget_use_style(win, \"combobox_popup\");\n  combo_box_ex_create_popup_items(combo_box, scroll_view);\n  widget_layout(win);\n\n  combo_box->combobox_popup = win;\n  widget_on(win, EVT_WINDOW_CLOSE, combo_box_combobox_popup_on_close_func, widget);\n\n  return win;\n}",
            "key_variables": [
               [
                  91,
                  "combo_box->item_height"
               ],
               [
                  93,
                  "widget->w"
               ]
            ]
         }
      ],
      "src/ext_widgets/features/draggable.c": [
         {
            "type": "func",
            "name": "draggable_on_paint_self",
            "line_range": [
               156,
               158
            ],
            "source_code": "static ret_t draggable_on_paint_self(widget_t* widget, canvas_t* c) {\n  return RET_OK;\n}",
            "key_variables": [
               [
                  168,
                  "widget->parent"
               ],
               [
                  171,
                  "evt->x"
               ],
               [
                  172,
                  "evt->y"
               ],
               [
                  173,
                  "target->x"
               ],
               [
                  174,
                  "target->y"
               ]
            ]
         },
         {
            "type": "func",
            "name": "draggable_on_parent_pointer_down",
            "line_range": [
               160,
               179
            ],
            "source_code": "static ret_t draggable_on_parent_pointer_down(void* ctx, event_t* e) {\n  widget_t* widget = WIDGET(ctx);\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n  if (widget->enable) {\n    pointer_event_t* evt = (pointer_event_t*)e;\n    draggable_t* draggable = DRAGGABLE(widget);\n    return_value_if_fail(draggable != NULL, RET_BAD_PARAMS);\n    widget_t* target = draggable->drag_window ? widget_get_window(widget) : widget->parent;\n\n    draggable->pressed = TRUE;\n    draggable->down.x = evt->x;\n    draggable->down.y = evt->y;\n    draggable->saved_position.x = target->x;\n    draggable->saved_position.y = target->y;\n\n    widget_grab(widget->parent->parent, widget->parent);\n  }\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  187,
                  "widget->parent"
               ],
               [
                  194,
                  "target->w"
               ],
               [
                  197,
                  "target->h"
               ]
            ]
         },
         {
            "type": "func",
            "name": "draggable_move_target",
            "line_range": [
               181,
               204
            ],
            "source_code": "static ret_t draggable_move_target(widget_t* widget, xy_t x, xy_t y) {\n  widget_t* target = NULL;\n  draggable_t* draggable = DRAGGABLE(widget);\n  return_value_if_fail(draggable != NULL, RET_BAD_PARAMS);\n\n  target = draggable->drag_window ? widget_get_window(widget) : widget->parent;\n  return_value_if_fail(target != NULL, RET_BAD_PARAMS);\n\n  xy_t min_x = draggable->left != DRAGGABLE_UNSPECIFIED_NUM ? draggable->left : 0;\n  xy_t min_y = draggable->top != DRAGGABLE_UNSPECIFIED_NUM ? draggable->top : 0;\n  xy_t max_x =\n      (draggable->right != DRAGGABLE_UNSPECIFIED_NUM ? draggable->right : target->parent->w) -\n      target->w;\n  xy_t max_y =\n      (draggable->bottom != DRAGGABLE_UNSPECIFIED_NUM ? draggable->bottom : target->parent->h) -\n      target->h;\n\n  x = tk_clampi(x, min_x, max_x);\n  y = tk_clampi(y, min_y, max_y);\n\n  widget_move(target, x, y);\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  239,
                  "widget->parent"
               ]
            ]
         }
      ],
      "src/ext_widgets/file_browser/file_browser.c": [
         {
            "type": "func",
            "name": "file_browser_extend_items",
            "line_range": [
               28,
               49
            ],
            "source_code": "static ret_t file_browser_extend_items(file_browser_t* fb, uint32_t capacity) {\n  fb_item_t* items = NULL;\n  return_value_if_fail(fb != NULL, RET_BAD_PARAMS);\n\n  if (fb->items_capacity >= capacity) {\n    return RET_OK;\n  }\n\n  items = TKMEM_REALLOC(fb->items, capacity * sizeof(fb_item_t));\n  if (items != NULL) {\n    uint32_t delta = capacity - fb->items_capacity;\n\n    fb->items = items;\n    fb->items_capacity = capacity;\n\n    memset(items + fb->items_size, 0x00, delta * sizeof(fb_item_t));\n\n    return RET_OK;\n  } else {\n    return RET_OOM;\n  }\n}",
            "key_variables": [
               [
                  39,
                  "fb->items_capacity"
               ]
            ]
         },
         {
            "type": "func",
            "name": "file_browser_add_item",
            "line_range": [
               51,
               68
            ],
            "source_code": "static fb_item_t* file_browser_add_item(file_browser_t* fb) {\n  return_value_if_fail(fb != NULL, NULL);\n\n  if (fb->items_size >= fb->items_capacity) {\n    uint32_t capacity = fb->items_capacity + fb->items_capacity / 2 + 10;\n    if (file_browser_extend_items(fb, capacity) != RET_OK) {\n      return NULL;\n    }\n  }\n\n  if (fb->items_size < fb->items_capacity) {\n    fb_item_t* item = fb->items + fb->items_size;\n    fb->items_size++;\n    return item;\n  }\n\n  return NULL;\n}",
            "key_variables": [
               [
                  63,
                  "fb->items_size"
               ]
            ]
         },
         {
            "type": "func",
            "name": "file_browser_find_item",
            "line_range": [
               70,
               81
            ],
            "source_code": "static fb_item_t* file_browser_find_item(file_browser_t* fb, const char* name) {\n  uint32_t i = 0;\n\n  for (i = 0; i < fb->items_size; i++) {\n    fb_item_t* iter = fb->items + i;\n    if (tk_str_eq(iter->name, name)) {\n      return iter;\n    }\n  }\n\n  return NULL;\n}",
            "key_variables": [
               [
                  74,
                  "fb->items_size"
               ]
            ]
         },
         {
            "type": "func",
            "name": "file_browser_set_cwd",
            "line_range": [
               97,
               114
            ],
            "source_code": "ret_t file_browser_set_cwd(file_browser_t* fb, const char* cwd) {\n  char path[MAX_PATH + 1];\n  return_value_if_fail(fb != NULL && cwd != NULL, RET_BAD_PARAMS);\n  assert(strlen(cwd) <= MAX_PATH);\n\n  if (path_is_abs(cwd)) {\n    path_normalize(cwd, fb->cwd, MAX_PATH);\n  } else {\n    memset(path, 0x00, sizeof(path));\n    return_value_if_fail(path_abs(cwd, path, MAX_PATH) == RET_OK, RET_BAD_PARAMS);\n    path_normalize(path, fb->cwd, MAX_PATH);\n  }\n  path_remove_last_slash(fb->cwd);\n\n  file_browser_refresh(fb);\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  99,
                  "path[MAX_PATH + 1]"
               ],
               [
                  118,
                  "path[MAX_PATH + 1]"
               ],
               [
                  126,
                  "abs_path[MAX_PATH + 1]"
               ]
            ]
         },
         {
            "type": "func",
            "name": "file_browser_set_top_dir",
            "line_range": [
               116,
               135
            ],
            "source_code": "ret_t file_browser_set_top_dir(file_browser_t* fb, const char* top_dir) {\n  char path[MAX_PATH + 1];\n  return_value_if_fail(fb != NULL && top_dir != NULL, RET_BAD_PARAMS);\n  assert(strlen(top_dir) <= MAX_PATH);\n\n  memset(path, 0x00, sizeof(path));\n  if (path_is_abs(top_dir)) {\n    path_normalize(top_dir, path, MAX_PATH);\n  } else {\n    char abs_path[MAX_PATH + 1];\n    memset(abs_path, 0x00, sizeof(path));\n    return_value_if_fail(path_abs(top_dir, abs_path, MAX_PATH) == RET_OK, RET_BAD_PARAMS);\n    path_normalize(abs_path, path, MAX_PATH);\n  }\n\n  fb->top_dir = tk_str_copy(fb->top_dir, path);\n  path_remove_last_slash(fb->top_dir);\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  139,
                  "fullpath[MAX_PATH + 1]"
               ]
            ]
         },
         {
            "type": "func",
            "name": "file_browser_create_dir",
            "line_range": [
               137,
               147
            ],
            "source_code": "ret_t file_browser_create_dir(file_browser_t* fb, const char* name) {\n  char fullpath[MAX_PATH + 1];\n  fb_item_t* item = file_browser_find_item(fb, name);\n  return_value_if_fail(item == NULL, RET_FOUND);\n\n  memset(fullpath, 0x00, sizeof(fullpath));\n  return_value_if_fail(fb != NULL && name != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(path_build(fullpath, MAX_PATH, fb->cwd, name, NULL) == RET_OK, RET_FAIL);\n\n  return fs_create_dir(fb->fs, fullpath);\n}",
            "key_variables": [
               [
                  154,
                  "fullpath[MAX_PATH + 1]"
               ],
               [
                  184,
                  "sub_path[MAX_PATH + 1]"
               ]
            ]
         },
         {
            "type": "func",
            "name": "file_browser_remove",
            "line_range": [
               204,
               212
            ],
            "source_code": "ret_t file_browser_remove(file_browser_t* fb, const char* name) {\n  char fullpath[MAX_PATH + 1];\n\n  memset(fullpath, 0x00, sizeof(fullpath));\n  return_value_if_fail(fb != NULL && name != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(path_build(fullpath, MAX_PATH, fb->cwd, name, NULL) == RET_OK, RET_FAIL);\n\n  return file_browser_remove_item_recursive(fb, fullpath);\n}",
            "key_variables": [
               [
                  206,
                  "fullpath[MAX_PATH + 1]"
               ],
               [
                  219,
                  "fullpath[MAX_PATH + 1]"
               ]
            ]
         },
         {
            "type": "func",
            "name": "file_browser_refresh",
            "line_range": [
               214,
               262
            ],
            "source_code": "ret_t file_browser_refresh(file_browser_t* fb) {\n  fs_item_t info;\n  fs_stat_info_t st;\n  fs_dir_t* dir = NULL;\n  char fullpath[MAX_PATH + 1];\n  return_value_if_fail(fb != NULL && fb->cwd[0] != '\\0', RET_BAD_PARAMS);\n\n  fb->items_size = 0;\n  dir = fs_open_dir(fb->fs, fb->cwd);\n  return_value_if_fail(dir != NULL, RET_BAD_PARAMS);\n\n  memset(fullpath, 0x00, sizeof(fullpath));\n  while (fs_dir_read(dir, &info) == RET_OK) {\n    fb_item_t* iter = NULL;\n    if (tk_str_eq(info.name, \".\") || tk_str_eq(info.name, \"..\")) {\n      continue;\n    }\n\n    if (fb->ignore_hidden_files && info.name[0] == '.') {\n      continue;\n    }\n\n    if (fb->filter != NULL && fb->filter(fb->filter_ctx, &info) == FALSE) {\n      continue;\n    }\n\n    path_build(fullpath, MAX_PATH, fb->cwd, info.name, NULL);\n    if (fs_stat(os_fs(), fullpath, &st) != RET_OK) {\n      log_debug(\"stat file failed:%s\\n\", fullpath);\n      continue;\n    }\n\n    iter = file_browser_add_item(fb);\n    return_value_if_fail(iter != NULL, RET_OOM);\n\n    iter->size = st.size;\n    iter->mtime = st.mtime;\n    iter->ctime = st.ctime;\n    iter->mtime = st.mtime;\n    iter->is_dir = st.is_dir;\n    iter->is_reg_file = st.is_reg_file;\n    iter->name = tk_str_copy(iter->name, info.name);\n  }\n  fs_dir_close(dir);\n\n  file_browser_sort(fb);\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  266,
                  "path[MAX_PATH + 1]"
               ]
            ]
         },
         {
            "type": "func",
            "name": "fb_compare_by_size",
            "line_range": [
               366,
               375
            ],
            "source_code": "int fb_compare_by_size(const void* a, const void* b) {\n  fb_item_t* aa = (fb_item_t*)a;\n  fb_item_t* bb = (fb_item_t*)b;\n\n  if ((aa->is_reg_file && bb->is_reg_file) || (aa->is_dir && bb->is_dir)) {\n    return aa->size - bb->size;\n  }\n\n  return fb_dir_first(aa, bb);\n}",
            "key_variables": [
               [
                  372,
                  "bb->size"
               ],
               [
                  383,
                  "bb->mtime"
               ]
            ]
         },
         {
            "type": "func",
            "name": "fb_compare_by_name_dec",
            "line_range": [
               388,
               397
            ],
            "source_code": "int fb_compare_by_name_dec(const void* a, const void* b) {\n  fb_item_t* aa = (fb_item_t*)a;\n  fb_item_t* bb = (fb_item_t*)b;\n\n  if ((aa->is_reg_file && bb->is_reg_file) || (aa->is_dir && bb->is_dir)) {\n    return -strcmp(aa->name, bb->name);\n  }\n\n  return fb_dir_first(aa, bb);\n}",
            "key_variables": [
               [
                  431,
                  "aa->size"
               ]
            ]
         },
         {
            "type": "func",
            "name": "fb_compare_by_size_dec",
            "line_range": [
               425,
               434
            ],
            "source_code": "int fb_compare_by_size_dec(const void* a, const void* b) {\n  fb_item_t* aa = (fb_item_t*)a;\n  fb_item_t* bb = (fb_item_t*)b;\n\n  if ((aa->is_reg_file && bb->is_reg_file) || (aa->is_dir && bb->is_dir)) {\n    return bb->size - aa->size;\n  }\n\n  return fb_dir_first(aa, bb);\n}",
            "key_variables": [
               [
                  442,
                  "aa->mtime"
               ]
            ]
         },
         {
            "type": "func",
            "name": "file_browser_sort_by_size",
            "line_range": [
               473,
               479
            ],
            "source_code": "ret_t file_browser_sort_by_size(file_browser_t* fb, bool_t ascending) {\n  return_value_if_fail(fb != NULL, RET_BAD_PARAMS);\n\n  fb->compare = ascending ? fb_compare_by_size : fb_compare_by_size_dec;\n\n  return file_browser_sort(fb);\n}",
            "key_variables": [
               [
                  493,
                  "fb->items_size"
               ]
            ]
         },
         {
            "type": "func",
            "name": "file_browser_get_item",
            "line_range": [
               495,
               499
            ],
            "source_code": "fb_item_t* file_browser_get_item(file_browser_t* fb, uint32_t index) {\n  return_value_if_fail(fb != NULL && index < fb->items_size, NULL);\n\n  return fb->items + index;\n}",
            "key_variables": [
               [
                  516,
                  "fb->items_capacity"
               ],
               [
                  532,
                  "item->is_reg_file"
               ]
            ]
         },
         {
            "type": "func",
            "name": "file_browser_set_ignore_hidden_files",
            "line_range": [
               501,
               507
            ],
            "source_code": "ret_t file_browser_set_ignore_hidden_files(file_browser_t* fb, bool_t ignore_hidden_files) {\n  return_value_if_fail(fb != NULL, RET_BAD_PARAMS);\n\n  fb->ignore_hidden_files = ignore_hidden_files;\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  538,
                  "item->is_dir"
               ]
            ]
         }
      ],
      "src/ext_widgets/file_browser/file_browser_view.c": [
         {
            "type": "func",
            "name": "file_browser_view_sync_sort",
            "line_range": [
               77,
               98
            ],
            "source_code": "static ret_t file_browser_view_sync_sort(widget_t* widget) {\n  const char* sort_by = NULL;\n  bool_t sort_ascending = FALSE;\n  file_browser_view_t* file_browser_view = FILE_BROWSER_VIEW(widget);\n  return_value_if_fail(file_browser_view != NULL, RET_BAD_PARAMS);\n  sort_by = file_browser_view->sort_by;\n  sort_ascending = file_browser_view->sort_ascending;\n\n  if (sort_by != NULL) {\n    if (tk_str_eq(sort_by, SORT_BY_NAME)) {\n      file_browser_sort_by_name(file_browser_view->fb, sort_ascending);\n    } else if (tk_str_eq(sort_by, SORT_BY_SIZE)) {\n      file_browser_sort_by_name(file_browser_view->fb, sort_ascending);\n    } else if (tk_str_eq(sort_by, SORT_BY_MTIME)) {\n      file_browser_sort_by_mtime(file_browser_view->fb, sort_ascending);\n    } else if (tk_str_eq(sort_by, SORT_BY_TYPE)) {\n      file_browser_sort_by_type(file_browser_view->fb, sort_ascending);\n    }\n  }\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  83,
                  "file_browser_view->sort_by"
               ],
               [
                  84,
                  "file_browser_view->sort_ascending"
               ]
            ]
         },
         {
            "type": "func",
            "name": "file_browser_view_on_item_clicked",
            "line_range": [
               228,
               261
            ],
            "source_code": "static ret_t file_browser_view_on_item_clicked(void* ctx, event_t* e) {\n  value_change_event_t changed;\n  widget_t* target = WIDGET(e->target);\n  file_browser_view_t* file_browser_view = FILE_BROWSER_VIEW(ctx);\n  return_value_if_fail(target != NULL && file_browser_view != NULL, RET_BAD_PARAMS);\n\n  if (tk_str_eq(target->name, FILE_BROWSER_VIEW_RETURN_UP)) {\n    file_browser_up(file_browser_view->fb);\n    widget_add_idle(WIDGET(file_browser_view), file_browser_view_reload_in_idle);\n  } else if (tk_str_eq(target->name, FILE_BROWSER_VIEW_FOLDER)) {\n    uint32_t index = widget_index_of(target);\n    fb_item_t* info = file_browser_get_item(file_browser_view->fb, index - 1);\n    return_value_if_fail(info != NULL, RET_FAIL);\n\n    file_browser_enter(file_browser_view->fb, info->name);\n    widget_add_idle(WIDGET(file_browser_view), file_browser_view_reload_in_idle);\n  } else {\n    uint32_t index = widget_index_of(target);\n    fb_item_t* info = file_browser_get_item(file_browser_view->fb, index - 1);\n    return_value_if_fail(info != NULL, RET_FAIL);\n\n    if (file_browser_view->selected_file != NULL) {\n      widget_set_text_utf8(file_browser_view->selected_file, info->name);\n    }\n  }\n\n  value_change_event_init(&changed, EVT_VALUE_CHANGED, ctx);\n  value_set_str(&(changed.new_value), file_browser_view->fb->cwd);\n  widget_dispatch(WIDGET(ctx), (event_t*)&changed);\n\n  log_debug(\"cwd: %s\\n\", value_str(&(changed.new_value)));\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  270,
                  "file_browser_view->container"
               ]
            ]
         },
         {
            "type": "func",
            "name": "file_browser_view_recycle_items",
            "line_range": [
               263,
               287
            ],
            "source_code": "static ret_t file_browser_view_recycle_items(widget_t* widget) {\n  widget_t* container = NULL;\n  darray_t* file_items_cache = NULL;\n  darray_t* folder_items_cache = NULL;\n  file_browser_view_t* file_browser_view = FILE_BROWSER_VIEW(widget);\n  return_value_if_fail(file_browser_view != NULL, RET_BAD_PARAMS);\n  container = file_browser_view->container;\n  file_items_cache = &(file_browser_view->file_items_cache);\n  folder_items_cache = &(file_browser_view->folder_items_cache);\n\n  if (container != NULL && container->children != NULL) {\n    WIDGET_FOR_EACH_CHILD_BEGIN(container, iter, i)\n    widget_remove_child_prepare(container, iter);\n    if (tk_str_eq(iter->name, FILE_BROWSER_VIEW_FILE)) {\n      darray_push(file_items_cache, iter);\n    } else if (tk_str_eq(iter->name, FILE_BROWSER_VIEW_FOLDER)) {\n      darray_push(folder_items_cache, iter);\n    }\n    container->children->elms[i] = NULL;\n    WIDGET_FOR_EACH_CHILD_END();\n    container->children->size = 0;\n  }\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  296,
                  "file_browser_view->container"
               ],
               [
                  316,
                  "file_browser_view->container"
               ]
            ]
         },
         {
            "type": "func",
            "name": "file_browser_view_create_folder_item",
            "line_range": [
               309,
               326
            ],
            "source_code": "static widget_t* file_browser_view_create_folder_item(widget_t* widget) {\n  widget_t* item = NULL;\n  darray_t* cache = NULL;\n  widget_t* container = NULL;\n  file_browser_view_t* file_browser_view = FILE_BROWSER_VIEW(widget);\n  return_value_if_fail(file_browser_view != NULL, NULL);\n  container = file_browser_view->container;\n  cache = &(file_browser_view->folder_items_cache);\n\n  if (cache->size > 0) {\n    item = WIDGET(darray_pop(cache));\n    widget_add_child(container, item);\n  } else {\n    item = widget_clone(file_browser_view->folder_template, container);\n    widget_on(item, EVT_CLICK, file_browser_view_on_item_clicked, widget);\n  }\n  return item;\n}",
            "key_variables": [
               [
                  344,
                  "file_browser_view->return_up_template"
               ],
               [
                  354,
                  "prop[TK_NAME_LEN + 1]"
               ]
            ]
         },
         {
            "type": "func",
            "name": "file_browser_view_create",
            "line_range": [
               464,
               478
            ],
            "source_code": "widget_t* file_browser_view_create(widget_t* parent, xy_t x, xy_t y, wh_t w, wh_t h) {\n  widget_t* widget = widget_create(parent, TK_REF_VTABLE(file_browser_view), x, y, w, h);\n  file_browser_view_t* file_browser_view = FILE_BROWSER_VIEW(widget);\n  return_value_if_fail(file_browser_view != NULL, NULL);\n\n  file_browser_view->sort_ascending = TRUE;\n  file_browser_view->show_check_button = FALSE;\n  file_browser_view->ignore_hidden_files = TRUE;\n  file_browser_view->fb = file_browser_create(os_fs());\n  darray_init(&(file_browser_view->selected_items), 10, NULL, NULL);\n  darray_init(&(file_browser_view->file_items_cache), 10, (tk_destroy_t)widget_unref, NULL);\n  darray_init(&(file_browser_view->folder_items_cache), 10, (tk_destroy_t)widget_unref, NULL);\n\n  return widget;\n}",
            "key_variables": [
               [
                  500,
                  "file_browser_view->container"
               ]
            ]
         },
         {
            "type": "func",
            "name": "file_browser_view_register",
            "line_range": [
               488,
               491
            ],
            "source_code": "ret_t file_browser_view_register(void) {\n  return widget_factory_register(widget_factory(), WIDGET_TYPE_FILE_BROWSER_VIEW,\n                                 file_browser_view_create);\n}",
            "key_variables": [
               [
                  525,
                  "fb->cwd"
               ]
            ]
         }
      ],
      "src/ext_widgets/file_browser/file_chooser.c": [
         {
            "type": "func",
            "name": "file_chooser_get_dir",
            "line_range": [
               164,
               168
            ],
            "source_code": "const char* file_chooser_get_dir(file_chooser_t* chooser) {\n  return_value_if_fail(chooser != NULL, NULL);\n\n  return chooser->cwd.str;\n}",
            "key_variables": [
               [
                  180,
                  "chooser->aborted"
               ]
            ]
         }
      ],
      "src/ext_widgets/gauge/gauge_pointer.c": [
         {
            "type": "func",
            "name": "gauge_pointer_calc_dirty_rect",
            "line_range": [
               35,
               83
            ],
            "source_code": "static rect_t gauge_pointer_calc_dirty_rect(widget_t* widget, int32_t img_w, int32_t img_h) {\n  xy_t x = 0;\n  xy_t y = 0;\n  matrix_t m;\n  xy_t min_x = 0;\n  xy_t min_y = 0;\n  xy_t max_x = 0;\n  xy_t max_y = 0;\n  int32_t w = img_w;\n  int32_t h = img_h;\n  int32_t ox = widget->x;\n  int32_t oy = widget->y;\n  gauge_pointer_t* gauge_pointer = GAUGE_POINTER(widget);\n  float_t rotation = TK_D2R(gauge_pointer->angle);\n  float_t anchor_x = gauge_pointer_get_anchor_for_str(widget->w, gauge_pointer->anchor_x);\n  float_t anchor_y = gauge_pointer_get_anchor_for_str(widget->h, gauge_pointer->anchor_y);\n\n  matrix_init(&m);\n  matrix_translate(&m, ox, oy);\n  matrix_translate(&m, anchor_x, anchor_y);\n  matrix_rotate(&m, rotation);\n  matrix_translate(&m, -anchor_x, -anchor_y);\n\n  matrix_transform_point(&m, 0, 0, &(x), &(y));\n  min_x = x;\n  max_x = x;\n  min_y = y;\n  max_y = y;\n\n  matrix_transform_point(&m, w, 0, &(x), &(y));\n  min_x = tk_min(min_x, x);\n  max_x = tk_max(max_x, x);\n  min_y = tk_min(min_y, y);\n  max_y = tk_max(max_y, y);\n\n  matrix_transform_point(&m, 0, h, &(x), &(y));\n  min_x = tk_min(min_x, x);\n  max_x = tk_max(max_x, x);\n  min_y = tk_min(min_y, y);\n  max_y = tk_max(max_y, y);\n\n  matrix_transform_point(&m, w, h, &(x), &(y));\n  min_x = tk_min(min_x, x);\n  max_x = tk_max(max_x, x);\n  min_y = tk_min(min_y, y);\n  max_y = tk_max(max_y, y);\n\n  return rect_init(min_x, min_y, max_x - min_x, max_y - min_y);\n}",
            "key_variables": [
               [
                  46,
                  "widget->x"
               ],
               [
                  47,
                  "widget->y"
               ]
            ]
         },
         {
            "type": "func",
            "name": "gauge_pointer_invalidate",
            "line_range": [
               85,
               117
            ],
            "source_code": "static ret_t gauge_pointer_invalidate(widget_t* widget, const rect_t* rect) {\n  rect_t r;\n  int32_t w = 0;\n  int32_t h = 0;\n  widget_t* parent = widget->parent;\n  gauge_pointer_t* gauge_pointer = GAUGE_POINTER(widget);\n\n  if (gauge_pointer->bsvg_asset != NULL || gauge_pointer->image == NULL) {\n    if (gauge_pointer->bsvg_asset != NULL) {\n      bsvg_t bsvg;\n      const asset_info_t* asset = gauge_pointer->bsvg_asset;\n\n      bsvg_init(&bsvg, (const uint32_t*)asset->data, asset->size);\n      w = bsvg.header->w;\n      h = bsvg.header->h;\n    } else {\n      w = widget->w;\n      h = widget->h * DEFAULT_POINTER_SIZE * 1.2f;\n    }\n  } else {\n    bitmap_t bitmap;\n    if (parent != NULL && !parent->destroying &&\n        widget_load_image(widget, gauge_pointer->image, &bitmap) == RET_OK) {\n      w = bitmap.w;\n      h = bitmap.h;\n    } else {\n      return RET_OK;\n    }\n  }\n\n  r = gauge_pointer_calc_dirty_rect(widget, w, h);\n  return widget_invalidate(parent, &r);\n}",
            "key_variables": [
               [
                  90,
                  "widget->parent"
               ],
               [
                  96,
                  "gauge_pointer->bsvg_asset"
               ],
               [
                  99,
                  "header->w"
               ],
               [
                  100,
                  "header->h"
               ],
               [
                  102,
                  "widget->w"
               ]
            ]
         },
         {
            "type": "func",
            "name": "gauge_pointer_on_destroy",
            "line_range": [
               273,
               285
            ],
            "source_code": "static ret_t gauge_pointer_on_destroy(widget_t* widget) {\n  gauge_pointer_t* gauge_pointer = GAUGE_POINTER(widget);\n  return_value_if_fail(widget != NULL && gauge_pointer != NULL, RET_BAD_PARAMS);\n\n  TKMEM_FREE(gauge_pointer->image);\n  if (gauge_pointer->bsvg_asset != NULL) {\n    widget_unload_asset(widget, gauge_pointer->bsvg_asset);\n  }\n  TKMEM_FREE(gauge_pointer->anchor_x);\n  TKMEM_FREE(gauge_pointer->anchor_y);\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  294,
                  "widget->w"
               ],
               [
                  295,
                  "widget->h"
               ],
               [
                  338,
                  "widget->astyle"
               ],
               [
                  342,
                  "gauge_pointer->bsvg_asset"
               ]
            ]
         }
      ],
      "src/ext_widgets/gif_image/gif_image.c": [
         {
            "type": "func",
            "name": "gif_image_on_paint_self",
            "line_range": [
               55,
               139
            ],
            "source_code": "static ret_t gif_image_on_paint_self(widget_t* widget, canvas_t* c) {\n  wh_t y = 0;\n  wh_t h = 0;\n  rect_t src;\n  rect_t dst;\n  uint32_t frames_nr;\n  bitmap_t bitmap;\n  vgcanvas_t* vg = NULL;\n  gif_image_t* image = GIF_IMAGE(widget);\n  image_base_t* image_base = IMAGE_BASE(widget);\n  return_value_if_fail(image_base != NULL && image != NULL && widget != NULL && c != NULL,\n                       RET_BAD_PARAMS);\n\n  if (image_base->image == NULL || image_base->image[0] == '\\0') {\n    widget_paint_helper(widget, c, NULL, NULL);\n    return RET_OK;\n  }\n\n  vg = canvas_get_vgcanvas(c);\n  return_value_if_fail(widget_load_image(widget, image_base->image, &bitmap) == RET_OK,\n                       RET_BAD_PARAMS);\n#ifdef AWTK_WEB\n  bitmap.gif_frame_h = bitmap.h;\n  frames_nr = 1;\n#else\n  if (!bitmap.is_gif) {\n    if (image->timer_id != TK_INVALID_ID) {\n      image->index = 0;\n      timer_remove(image->timer_id);\n      image->timer_id = TK_INVALID_ID;\n    }\n    return RET_OK;\n  }\n  frames_nr = bitmap.gif_frames_nr;\n#endif /*AWTK_WEB*/\n\n  if (frames_nr > 0) {\n    image->index %= frames_nr;\n  } else {\n    image->index = 0;\n  }\n\n#ifdef AWTK_WEB\n  if (image->timer_id == TK_INVALID_ID) {\n    image->timer_id = timer_add(gif_image_on_timer, image, 16);\n  }\n#else\n  if (frames_nr > 1) {\n    uint32_t delay = bitmap.gif_delays[image->index];\n    if (image->timer_id == TK_INVALID_ID) {\n      image->index = 0;\n      image->delay = delay;\n      image->timer_id = timer_add(gif_image_on_timer, image, image->delay);\n    } else if (image->delay != delay) {\n      image->delay = delay;\n      timer_info_t* timer = (timer_info_t*)timer_find(image->timer_id);\n      if (timer) timer->duration = image->delay;\n    }\n  } else if (image->timer_id != TK_INVALID_ID) {\n    image->index = 0;\n    timer_remove(image->timer_id);\n    image->timer_id = TK_INVALID_ID;\n  }\n#endif /*AWTK_WEB*/\n\n  h = bitmap.gif_frame_h;\n  y = bitmap.gif_frame_h * image->index;\n\n  if (vg != NULL) {\n    if (image_need_transform(widget)) {\n      vgcanvas_save(vg);\n      image_transform(widget, c);\n      vgcanvas_draw_icon(vg, &bitmap, 0, y, bitmap.w, h, 0, 0, widget->w, widget->h);\n      vgcanvas_restore(vg);\n\n      return RET_OK;\n    }\n  }\n\n  src = rect_init(0, y, bitmap.w, h);\n  dst = rect_init(0, 0, widget->w, widget->h);\n  canvas_draw_image_scale_down(c, &bitmap, &src, &dst);\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  104,
                  "gif_delays[image->index]"
               ],
               [
                  112,
                  "image->delay"
               ],
               [
                  122,
                  "image->index"
               ]
            ]
         }
      ],
      "src/ext_widgets/image_animation/image_animation.c": [
         {
            "type": "func",
            "name": "image_animation_get_image_name",
            "line_range": [
               39,
               58
            ],
            "source_code": "ret_t image_animation_get_image_name(image_animation_t* image_animation,\n                                     char name[TK_NAME_LEN + 1]) {\n  uint32_t index = 0;\n  memset(name, 0x00, TK_NAME_LEN + 1);\n  if (image_animation->sequence != NULL) {\n    uint32_t len = strlen(image_animation->sequence);\n    tk_strncpy(name, image_animation->image, TK_NAME_LEN);\n    image_animation->index = image_animation->index >= len ? 0 : image_animation->index;\n    index = image_animation->reverse ? len - image_animation->index - 1 : image_animation->index;\n    name[strlen(name)] = image_animation->sequence[index];\n  } else {\n    index = image_animation->reverse\n                ? image_animation->end_index + image_animation->start_index - image_animation->index\n                : image_animation->index;\n    const char* format = image_animation->format ? image_animation->format : \"%s%d\";\n    tk_snprintf(name, TK_NAME_LEN, format, image_animation->image, index);\n  }\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  47,
                  "image_animation->index"
               ],
               [
                  48,
                  "image_animation->index"
               ],
               [
                  49,
                  "sequence[index]"
               ],
               [
                  53,
                  "image_animation->index"
               ]
            ]
         },
         {
            "type": "func",
            "name": "image_animation_load_image",
            "line_range": [
               81,
               88
            ],
            "source_code": "static ret_t image_animation_load_image(image_animation_t* image_animation, bitmap_t* bitmap) {\n  char name[TK_NAME_LEN + 1];\n  widget_t* widget = WIDGET(image_animation);\n  return_value_if_fail(widget != NULL && image_animation != NULL && bitmap != NULL, RET_BAD_PARAMS);\n\n  image_animation_get_image_name(image_animation, name);\n  return widget_load_image(widget, name, bitmap);\n}",
            "key_variables": [
               [
                  83,
                  "name[TK_NAME_LEN + 1]"
               ]
            ]
         },
         {
            "type": "func",
            "name": "image_animation_on_paint_self",
            "line_range": [
               90,
               113
            ],
            "source_code": "static ret_t image_animation_on_paint_self(widget_t* widget, canvas_t* c) {\n  image_animation_t* image_animation = IMAGE_ANIMATION(widget);\n  return_value_if_fail(widget != NULL && image_animation != NULL && image_animation->image != NULL,\n                       RET_BAD_PARAMS);\n\n  image_animation_start_init_if_not_inited(widget);\n\n  if (image_animation->index >= 0) {\n    bitmap_t bitmap;\n\n    if (image_animation_load_image(image_animation, &bitmap) == RET_OK) {\n      rect_t s = rect_init(0, 0, bitmap.w, bitmap.h);\n      rect_t d = rect_init(0, 0, widget->w, widget->h);\n      canvas_draw_image_scale_down(c, &bitmap, &s, &d);\n\n      if (image_animation->unload_after_paint) {\n        image_animation->image_buffer = (bitmap.buffer);\n        widget_add_idle(widget, on_idle_unload_image);\n      }\n    }\n  }\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  185,
                  "image_animation->start_index"
               ]
            ]
         },
         {
            "type": "func",
            "name": "image_animation_set_range_sequence",
            "line_range": [
               364,
               374
            ],
            "source_code": "ret_t image_animation_set_range_sequence(widget_t* widget, uint32_t start_index,\n                                         uint32_t end_index) {\n  image_animation_t* image_animation = IMAGE_ANIMATION(widget);\n  return_value_if_fail(image_animation != NULL, RET_BAD_PARAMS);\n\n  image_animation->index = start_index;\n  image_animation->end_index = end_index;\n  image_animation->start_index = start_index;\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  381,
                  "image_animation->start_index"
               ]
            ]
         },
         {
            "type": "func",
            "name": "image_animation_on_update",
            "line_range": [
               434,
               447
            ],
            "source_code": "static ret_t image_animation_on_update(const timer_info_t* info) {\n  ret_t ret = RET_OK;\n  widget_t* widget = WIDGET(info->ctx);\n  image_animation_t* image_animation = IMAGE_ANIMATION(widget);\n  return_value_if_fail(info != NULL && image_animation != NULL, RET_BAD_PARAMS);\n\n  image_animation->playing = TRUE;\n  ret = image_animation_update(widget);\n  if (info->duration != image_animation->interval) {\n    timer_modify(info->id, image_animation->interval);\n  }\n\n  return ret;\n}",
            "key_variables": [
               [
                  466,
                  "image_animation->playing"
               ]
            ]
         }
      ],
      "src/ext_widgets/image_value/image_value.c": [
         {
            "type": "func",
            "name": "image_value_draw_images",
            "line_range": [
               25,
               123
            ],
            "source_code": "static ret_t image_value_draw_images(widget_t* widget, canvas_t* c, bitmap_t* bitmap, uint32_t nr) {\n  int32_t x = 0;\n  int32_t y = 0;\n  int32_t i = 0;\n  int32_t w = 0;\n  int32_t h = 0;\n  float scale_w = 1;\n  float scale_h = 1;\n  float_t ratio = c->lcd->ratio;\n  style_t* style = widget->astyle;\n  rect_t content_r = widget_get_content_area(widget);\n  int32_t align_v = style_get_int(style, STYLE_ID_TEXT_ALIGN_V, ALIGN_V_MIDDLE);\n  int32_t align_h = style_get_int(style, STYLE_ID_TEXT_ALIGN_H, ALIGN_H_CENTER);\n  image_draw_type_t draw_type =\n      (image_draw_type_t)style_get_int(style, STYLE_ID_FG_IMAGE_DRAW_TYPE, IMAGE_DRAW_DEFAULT);\n\n  for (i = 0; i < nr; i++) {\n    bitmap_t* b = bitmap + i;\n    w += b->w;\n    if (h < b->h) {\n      h = b->h;\n    }\n  }\n\n  w = w / ratio;\n  h = h / ratio;\n  return_value_if_fail(w > 0 && h > 0 && content_r.w > 0 && content_r.h > 0, RET_BAD_PARAMS);\n\n  scale_h = (float)(content_r.h) / (float)h;\n  scale_w = (float)(content_r.w) / (float)w;\n  switch (draw_type) {\n    case IMAGE_DRAW_SCALE_AUTO: {\n      scale_w = tk_min(scale_w, scale_h);\n      scale_h = scale_w;\n      break;\n    }\n    case IMAGE_DRAW_SCALE_W: {\n      scale_h = scale_w;\n      break;\n    }\n    case IMAGE_DRAW_SCALE_H: {\n      scale_w = scale_h;\n      break;\n    }\n    case IMAGE_DRAW_SCALE: {\n      break;\n    }\n    default: {\n      scale_w = 1;\n      scale_h = 1;\n      break;\n    }\n  }\n\n  w = scale_w * w;\n  h = scale_h * h;\n\n  switch (align_h) {\n    case ALIGN_H_LEFT: {\n      x = content_r.x;\n      break;\n    }\n    case ALIGN_H_RIGHT: {\n      x = content_r.x + content_r.w - w;\n      break;\n    }\n    default: {\n      x = (widget->w - w) / 2;\n      break;\n    }\n  }\n\n  switch (align_v) {\n    case ALIGN_V_TOP: {\n      y = content_r.y;\n      break;\n    }\n    case ALIGN_V_BOTTOM: {\n      y = content_r.y + content_r.h - h;\n      break;\n    }\n    default: {\n      y = (widget->h - h) / 2;\n      break;\n    }\n  }\n\n  for (i = 0; i < nr; i++) {\n    bitmap_t* b = bitmap + i;\n    rect_t s = rect_init(0, 0, b->w, b->h);\n    rect_t d = rect_init(x, y, scale_w * b->w / ratio, scale_h * b->h / ratio);\n\n    canvas_draw_image(c, b, &s, &d);\n\n    x += d.w;\n  }\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  34,
                  "lcd->ratio"
               ],
               [
                  35,
                  "widget->astyle"
               ],
               [
                  44,
                  "b->w"
               ],
               [
                  46,
                  "b->h"
               ]
            ]
         },
         {
            "type": "func",
            "name": "image_value_on_paint_self",
            "line_range": [
               125,
               166
            ],
            "source_code": "static ret_t image_value_on_paint_self(widget_t* widget, canvas_t* c) {\n  uint32_t i = 0;\n  uint32_t nr = 0;\n  char sub_name[8];\n  const char* format = NULL;\n  char name[TK_NAME_LEN + 1];\n  char str[IMAGE_VALUE_MAX_CHAR_NR + 1];\n  bitmap_t bitmap[IMAGE_VALUE_MAX_CHAR_NR];\n  image_value_t* image_value = IMAGE_VALUE(widget);\n  return_value_if_fail(image_value != NULL && widget != NULL, RET_BAD_PARAMS);\n\n  format = image_value->format != NULL ? image_value->format : \"%d\";\n  return_value_if_fail(image_value->image != NULL, RET_BAD_PARAMS);\n\n  memset(bitmap, 0x00, sizeof(bitmap));\n  memset(sub_name, 0x00, sizeof(sub_name));\n  if (strchr(format, 'd') != NULL || strchr(format, 'x') != NULL || strchr(format, 'X') != NULL) {\n    tk_snprintf(str, IMAGE_VALUE_MAX_CHAR_NR, format, tk_roundi(image_value->value));\n  } else {\n    tk_snprintf(str, IMAGE_VALUE_MAX_CHAR_NR, format, image_value->value);\n  }\n\n  nr = strlen(str);\n  return_value_if_fail(nr > 0, RET_BAD_PARAMS);\n\n  name[TK_NAME_LEN] = '\\0';\n  for (i = 0; i < nr; i++) {\n    if (str[i] == '.') {\n      strcpy(sub_name, IMAGE_VALUE_MAP_DOT);\n    } else if (str[i] == '/') {\n      strcpy(sub_name, IMAGE_VALUE_MAP_SLASH);\n    } else {\n      sub_name[0] = str[i];\n      sub_name[1] = '\\0';\n    }\n\n    tk_snprintf(name, TK_NAME_LEN, \"%s%s\", image_value->image, sub_name);\n    return_value_if_fail(widget_load_image(widget, name, bitmap + i) == RET_OK, RET_BAD_PARAMS);\n  }\n\n  return image_value_draw_images(widget, c, bitmap, nr);\n}",
            "key_variables": [
               [
                  129,
                  "sub_name[8]"
               ],
               [
                  131,
                  "name[TK_NAME_LEN + 1]"
               ],
               [
                  132,
                  "str[IMAGE_VALUE_MAX_CHAR_NR + 1]"
               ],
               [
                  133,
                  "bitmap[IMAGE_VALUE_MAX_CHAR_NR]"
               ],
               [
                  158,
                  "str[i]"
               ]
            ]
         },
         {
            "type": "func",
            "name": "image_value_on_destroy",
            "line_range": [
               215,
               223
            ],
            "source_code": "static ret_t image_value_on_destroy(widget_t* widget) {\n  image_value_t* image_value = IMAGE_VALUE(widget);\n  return_value_if_fail(image_value != NULL, RET_BAD_PARAMS);\n\n  TKMEM_FREE(image_value->image);\n  TKMEM_FREE(image_value->format);\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  231,
                  "image_value->value"
               ],
               [
                  236,
                  "image_value->click_add_delta"
               ],
               [
                  250,
                  "e->type"
               ]
            ]
         }
      ],
      "src/ext_widgets/keyboard/candidates.c": [
         {
            "type": "func",
            "name": "candidates_on_button_focused",
            "line_range": [
               32,
               46
            ],
            "source_code": "static ret_t candidates_on_button_focused(void* ctx, event_t* e) {\n  char str[32];\n  widget_t* button = WIDGET(e->target);\n  input_method_t* im = input_method();\n  wstr_t* text = &(button->text);\n  candidates_t* candidates = CANDIDATES(ctx);\n  return_value_if_fail(im != NULL && candidates != NULL && text->size > 0, RET_FAIL);\n  tk_utf8_from_utf16(text->str, str, sizeof(str) - 1);\n\n  if (candidates->pre) {\n    input_method_dispatch_keys(im, str);\n  }\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  34,
                  "str[32]"
               ]
            ]
         },
         {
            "type": "func",
            "name": "candidates_on_button_click",
            "line_range": [
               48,
               76
            ],
            "source_code": "static ret_t candidates_on_button_click(void* ctx, event_t* e) {\n  char str[32];\n  widget_t* button = WIDGET(e->target);\n  input_method_t* im = input_method();\n  wstr_t* text = &(button->text);\n  candidates_t* candidates = CANDIDATES(ctx);\n  return_value_if_fail(im != NULL, RET_FAIL);\n\n  if (text->size > 0) {\n    wchar_t c = text->str[text->size - 1];\n\n    tk_utf8_from_utf16(text->str, str, sizeof(str) - 1);\n    if (input_method_commit_text(im, str) == RET_OK) {\n      if (!candidates->pre) {\n        suggest_words_t* suggest_words = im->suggest_words;\n        if (suggest_words && suggest_words_find(suggest_words, c) == RET_OK) {\n          input_method_dispatch_candidates(im, suggest_words->words, suggest_words->words_nr, -1);\n          if (suggest_words->words_nr > 0) {\n            widget_set_focused(widget_get_child(button->parent, 0), TRUE);\n            candidates->is_suggest = TRUE;\n          }\n          log_debug(\"suggest_words->words:%s\\n\", suggest_words->words);\n        }\n      }\n    }\n  }\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  50,
                  "str[32]"
               ],
               [
                  58,
                  "str[text->size - 1]"
               ],
               [
                  63,
                  "im->suggest_words"
               ]
            ]
         },
         {
            "type": "func",
            "name": "candidates_relayout_children",
            "line_range": [
               125,
               172
            ],
            "source_code": "static ret_t candidates_relayout_children(widget_t* widget) {\n  uint32_t i = 0;\n  xy_t margin = 2;\n  uint32_t nr = 0;\n  wh_t child_w = 0;\n  xy_t child_x = margin;\n  xy_t child_y = margin;\n  widget_t* iter = NULL;\n  widget_t* focused = NULL;\n  wh_t child_h = widget->h - margin * 2;\n  candidates_t* candidates = CANDIDATES(widget);\n  widget_t** children = (widget_t**)(widget->children->elms);\n  style_t* style = children[0]->astyle;\n  canvas_t* c = widget_get_canvas(widget);\n  const char* font = system_info_fix_font_name(NULL);\n  int32_t child_margin = style_get_int(style, STYLE_ID_MARGIN, 0);\n  uint16_t font_size = style_get_int(style, STYLE_ID_FONT_SIZE, TK_DEFAULT_FONT_SIZE);\n\n  nr = candidates->candidates_nr;\n  canvas_set_font(c, font, font_size);\n  for (i = 0; i < nr; i++) {\n    iter = children[i];\n    child_w = candidates_calc_child_width(c, iter) + child_margin * 2;\n    if (iter->text.size) {\n      widget_set_enable(iter, TRUE);\n      widget_set_visible(iter, TRUE, FALSE);\n    } else {\n      child_w = 0;\n      widget_set_enable(iter, FALSE);\n      widget_set_visible(iter, FALSE, FALSE);\n    }\n    widget_move_resize(iter, child_x, child_y, child_w, child_h);\n    child_x += child_w + margin;\n\n    if (iter->focused) {\n      focused = iter;\n    }\n  }\n\n  hscrollable_set_virtual_w(candidates->hscrollable, child_x + 30);\n  if (focused != NULL && focused->x > widget->w / 2) {\n    hscrollable_set_xoffset(candidates->hscrollable, focused->x);\n  } else {\n    hscrollable_set_xoffset(candidates->hscrollable, 0);\n  }\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  144,
                  "candidates->candidates_nr"
               ],
               [
                  147,
                  "children[i]"
               ],
               [
                  188,
                  "children[i]"
               ],
               [
                  200,
                  "children->size"
               ],
               [
                  201,
                  "children[i]"
               ]
            ]
         },
         {
            "type": "func",
            "name": "candidates_set_prop",
            "line_range": [
               285,
               303
            ],
            "source_code": "static ret_t candidates_set_prop(widget_t* widget, const char* name, const value_t* v) {\n  candidates_t* candidates = CANDIDATES(widget);\n  return_value_if_fail(candidates != NULL, RET_BAD_PARAMS);\n\n  if (tk_str_eq(name, CANDIDATES_PROP_PRE)) {\n    return candidates_set_pre(widget, value_bool(v));\n  } else if (tk_str_eq(name, CANDIDATES_PROP_SELECT_BY_NUM)) {\n    return candidates_set_select_by_num(widget, value_bool(v));\n  } else if (tk_str_eq(name, CANDIDATES_PROP_AUTO_HIDE)) {\n    return candidates_set_auto_hide(widget, value_bool(v));\n  } else if (tk_str_eq(name, CANDIDATES_PROP_BUTTON_STYLE)) {\n    return candidates_set_button_style(widget, value_str(v));\n  }\n  if (candidates->hscrollable != NULL) {\n    return hscrollable_set_prop(candidates->hscrollable, name, v);\n  } else {\n    return RET_NOT_FOUND;\n  }\n}",
            "key_variables": [
               [
                  312,
                  "candidates->candidates_nr"
               ]
            ]
         },
         {
            "type": "func",
            "name": "candidates_move_focus",
            "line_range": [
               305,
               330
            ],
            "source_code": "static ret_t candidates_move_focus(widget_t* widget, bool_t next) {\n  uint32_t nr = 0;\n  widget_t* focus = NULL;\n  int32_t next_focus = 0;\n  candidates_t* candidates = CANDIDATES(widget);\n  return_value_if_fail(candidates != NULL, RET_BAD_PARAMS);\n  nr = candidates->candidates_nr;\n\n  WIDGET_FOR_EACH_CHILD_BEGIN(widget, iter, i)\n  if (iter->focused) {\n    if (next) {\n      next_focus = i + 1;\n    } else {\n      if (i > 0) {\n        next_focus = i - 1;\n      }\n    }\n  }\n  WIDGET_FOR_EACH_CHILD_END();\n\n  next_focus = next_focus % nr;\n  focus = widget_get_child(widget, next_focus);\n  widget_set_focused(focus, TRUE);\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  339,
                  "candidates->candidates_nr"
               ]
            ]
         }
      ],
      "src/ext_widgets/keyboard/keyboard.c": [
         {
            "type": "func",
            "name": "keyboard_on_event",
            "line_range": [
               50,
               74
            ],
            "source_code": "static ret_t keyboard_on_event(widget_t* widget, event_t* e) {\n  keyboard_t* keyboard = KEYBOARD(widget);\n  return_value_if_fail(keyboard != NULL, RET_BAD_PARAMS);\n  if (e->type == EVT_KEY_DOWN || e->type == EVT_KEY_UP) {\n    key_event_t* evt = (key_event_t*)e;\n    /*goto here only when grab_keys=true*/\n    if (evt->key == TK_KEY_LEFT || evt->key == TK_KEY_RIGHT || evt->key == TK_KEY_DOWN ||\n        evt->key == TK_KEY_UP) {\n      /*let window move focus*/\n      return RET_OK;\n    }\n\n    if (e->type == EVT_KEY_DOWN) {\n      keyboard->key_down = evt->key;\n    } else {\n      if (keyboard->key_down == evt->key) {\n        input_method_dispatch_key(input_method(), evt->key);\n        keyboard->key_down = 0;\n      }\n    }\n    return RET_STOP;\n  }\n\n  return window_base_on_event(widget, e);\n}",
            "key_variables": [
               [
                  64,
                  "evt->key"
               ]
            ]
         },
         {
            "type": "func",
            "name": "keyboard_focus_first",
            "line_range": [
               118,
               122
            ],
            "source_code": "static ret_t keyboard_focus_first(widget_t* page) {\n  widget_foreach(page, on_visit_widget_to_focus_first, NULL);\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  132,
                  "iter->parent"
               ]
            ]
         },
         {
            "type": "func",
            "name": "keyboard_on_preedit_timeout",
            "line_range": [
               182,
               187
            ],
            "source_code": "static ret_t keyboard_on_preedit_timeout(const timer_info_t* info) {\n  return_value_if_fail(info != NULL, RET_BAD_PARAMS);\n  keyboard_preedit_confirm(WIDGET(info->ctx));\n\n  return RET_REMOVE;\n}",
            "key_variables": [
               [
                  197,
                  "button->name"
               ]
            ]
         },
         {
            "type": "func",
            "name": "keyboard_on_action_info",
            "line_range": [
               309,
               325
            ],
            "source_code": "static ret_t keyboard_on_action_info(void* ctx, event_t* e) {\n  uint32_t i = 0;\n  uint32_t nr = 0;\n  widget_t** buttons = NULL;\n  input_method_t* im = input_method();\n  keyboard_t* keyboard = KEYBOARD(ctx);\n  return_value_if_fail(keyboard != NULL && im != NULL, RET_BAD_PARAMS);\n\n  nr = keyboard->action_buttons.size;\n  buttons = (widget_t**)keyboard->action_buttons.elms;\n\n  for (i = 0; i < nr; i++) {\n    keyboard_update_action_buton_info(buttons[i], im->action_buton_text, im->action_button_enable);\n  }\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  336,
                  "widget->name"
               ]
            ]
         }
      ],
      "src/ext_widgets/keyboard/lang_indicator.c": [
         {
            "type": "func",
            "name": "lang_indicator_on_paint_self",
            "line_range": [
               66,
               82
            ],
            "source_code": "static ret_t lang_indicator_on_paint_self(widget_t* widget, canvas_t* c) {\n  wstr_t* str = &(widget->text);\n  lang_indicator_t* lang_indicator = LANG_INDICATOR(widget);\n  const char* lang = input_method_get_lang(input_method());\n  return_value_if_fail(lang_indicator != NULL, RET_BAD_PARAMS);\n\n  if (lang_indicator->image != NULL) {\n    char icon[128];\n    tk_snprintf(icon, sizeof(icon), \"%s%s\", lang_indicator->image, lang != NULL ? lang : \"none\");\n    widget_paint_helper(widget, c, icon, NULL);\n  } else {\n    wstr_set_utf8(str, lang != NULL ? lang : \"\");\n    widget_paint_helper(widget, c, NULL, NULL);\n  }\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  74,
                  "icon[128]"
               ]
            ]
         }
      ],
      "src/ext_widgets/mledit/line_number.c": [
         {
            "type": "func",
            "name": "line_number_do_paint_self",
            "line_range": [
               39,
               83
            ],
            "source_code": "static ret_t line_number_do_paint_self(widget_t* widget, canvas_t* c) {\n  uint32_t y = 0;\n  uint32_t x = 2;\n  uint32_t line = 0;\n  char str[32] = {0};\n  wstr_t* text = &(widget->text);\n  uint32_t w = widget->w - 2 * x;\n  rect_t r = rect_init(0, 0, 0, 0);\n  line_number_t* line_number = LINE_NUMBER(widget);\n  int32_t yoffset = line_number->yoffset;\n  int32_t line_height = line_number->line_height;\n\n  return_value_if_fail(line_height > 0, RET_BAD_PARAMS);\n\n  if (style_is_valid(widget->astyle)) {\n    uint32_t line_index = 0;\n    widget_prepare_text_style(widget, c);\n\n    while (1) {\n      if (line > 0) {\n        line_index += line_number_get_line_num(line_number, line - 1);\n      }\n\n      y = line_height * line_index + line_number->top_margin;\n      if ((y + line_height) < yoffset) {\n        line++;\n        continue;\n      }\n\n      if (y >= (yoffset + widget->h)) {\n        break;\n      }\n\n      r = rect_init(x, y - yoffset, w, line_height);\n      tk_snprintf(str, sizeof(str), \"%u\", (line + 1));\n\n      wstr_set_utf8(text, str);\n      canvas_draw_text_in_rect(c, text->str, text->size, &r);\n\n      line++;\n    }\n  }\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  49,
                  "line_number->yoffset"
               ],
               [
                  50,
                  "line_number->line_height"
               ],
               [
                  63,
                  "line_number->top_margin"
               ]
            ]
         }
      ],
      "src/ext_widgets/mledit/mledit.c": [
         {
            "type": "func",
            "name": "mledit_set_max_chars",
            "line_range": [
               183,
               192
            ],
            "source_code": "ret_t mledit_set_max_chars(widget_t* widget, uint32_t max_chars) {\n  mledit_t* mledit = MLEDIT(widget);\n  return_value_if_fail(mledit != NULL, RET_BAD_PARAMS);\n\n  mledit->max_chars = max_chars;\n  text_edit_set_max_chars(mledit->model, max_chars);\n  text_edit_layout(mledit->model);\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  225,
                  "mledit->margin"
               ],
               [
                  235,
                  "mledit->margin"
               ],
               [
                  245,
                  "mledit->margin"
               ],
               [
                  254,
                  "mledit->margin"
               ],
               [
                  291,
                  "widget->focused"
               ]
            ]
         },
         {
            "type": "func",
            "name": "mledit_scroll_to_offset",
            "line_range": [
               558,
               576
            ],
            "source_code": "ret_t mledit_scroll_to_offset(widget_t* widget, uint32_t offset) {\n  mledit_t* mledit = MLEDIT(widget);\n  int32_t scroll_y = 0;\n  scroll_bar_t* vscroll_bar =\n      SCROLL_BAR(widget_lookup_by_type(widget, WIDGET_TYPE_SCROLL_BAR_DESKTOP, TRUE));\n\n  return_value_if_fail(mledit != NULL && mledit->model != NULL, RET_BAD_PARAMS);\n\n  scroll_y = text_edit_get_height(mledit->model, offset);\n\n  if (vscroll_bar != NULL) {\n    text_edit_state_t state = {0};\n    text_edit_get_state(mledit->model, &state);\n\n    scroll_y = tk_min(scroll_y, tk_max(vscroll_bar->virtual_size - vscroll_bar->widget.h, 0));\n  }\n\n  return text_edit_set_offset(mledit->model, 0, scroll_y);\n}",
            "key_variables": [
               [
                  589,
                  "e->type"
               ],
               [
                  608,
                  "e->time"
               ],
               [
                  628,
                  "e->time"
               ],
               [
                  635,
                  "e->time"
               ],
               [
                  641,
                  "evt->key"
               ],
               [
                  643,
                  "evt->cmd"
               ],
               [
                  645,
                  "evt->ctrl"
               ],
               [
                  666,
                  "e->time"
               ],
               [
                  688,
                  "e->time"
               ],
               [
                  693,
                  "e->time"
               ],
               [
                  698,
                  "e->time"
               ],
               [
                  703,
                  "e->time"
               ],
               [
                  714,
                  "evt->key"
               ],
               [
                  725,
                  "e->time"
               ],
               [
                  759,
                  "evt->dy"
               ],
               [
                  779,
                  "e->time"
               ],
               [
                  796,
                  "mledit->max_lines"
               ]
            ]
         },
         {
            "type": "func",
            "name": "mledit_on_event",
            "line_range": [
               586,
               829
            ],
            "source_code": "static ret_t mledit_on_event(widget_t* widget, event_t* e) {\n  ret_t ret = RET_OK;\n  uint32_t type = e->type;\n  mledit_t* mledit = MLEDIT(widget);\n  return_value_if_fail(widget != NULL && mledit != NULL && e != NULL, RET_BAD_PARAMS);\n\n  if (!widget->visible) {\n    return RET_OK;\n  }\n\n  switch (type) {\n    case EVT_POINTER_DOWN: {\n      pointer_event_t evt = *(pointer_event_t*)e;\n      if (widget_find_target(widget, evt.x, evt.y) == NULL) {\n        text_edit_click(mledit->model, evt.x, evt.y);\n        widget_grab(widget->parent, widget);\n      }\n\n      if (widget->target == NULL) {\n        mledit_request_input_method(widget);\n      }\n      mledit->last_user_action_time = e->time;\n      mledit_update_status(widget);\n      widget_invalidate(widget, NULL);\n      break;\n    }\n    case EVT_POINTER_DOWN_ABORT: {\n      mledit_pointer_up_cleanup(widget);\n      widget_invalidate(widget, NULL);\n      break;\n    }\n    case EVT_POINTER_MOVE: {\n      pointer_event_t evt = *(pointer_event_t*)e;\n      if (widget->parent && widget->parent->grab_widget == widget) {\n        if (widget->target == NULL) {\n          text_edit_drag(mledit->model, evt.x, evt.y);\n          ret = RET_STOP;\n        }\n      }\n\n      if (evt.pressed) {\n        mledit->last_user_action_time = e->time;\n      }\n      widget_invalidate(widget, NULL);\n      break;\n    }\n    case EVT_POINTER_UP: {\n      widget_ungrab(widget->parent, widget);\n      mledit->last_user_action_time = e->time;\n      widget_invalidate(widget, NULL);\n      break;\n    }\n    case EVT_KEY_DOWN: {\n      key_event_t* evt = (key_event_t*)e;\n      int32_t key = evt->key;\n#ifdef MACOS\n      bool_t is_control = evt->cmd;\n#else\n      bool_t is_control = evt->ctrl;\n#endif\n      if (key == TK_KEY_ESCAPE || (key >= TK_KEY_F1 && key <= TK_KEY_F12)) {\n        break;\n      }\n\n      if (mledit->readonly) {\n        if (is_control && (key == TK_KEY_C || key == TK_KEY_c)) {\n          log_debug(\"copy\\n\");\n        } else {\n          break;\n        }\n      }\n      text_edit_key_down(mledit->model, (key_event_t*)e);\n      if ((key < 128 && tk_isprint(key)) || key == TK_KEY_BACKSPACE || key == TK_KEY_DELETE ||\n          key_code_is_enter(key)) {\n        mledit_dispatch_event(widget, EVT_VALUE_CHANGING);\n      }\n\n      mledit_update_status(widget);\n      ret = RET_STOP;\n      mledit->last_user_action_time = e->time;\n      widget_invalidate(widget, NULL);\n      break;\n    }\n    case EVT_IM_COMMIT: {\n      text_edit_state_t state;\n      text_edit_get_state(mledit->model, &state);\n      im_commit_event_t* evt = (im_commit_event_t*)e;\n\n      if (mledit->readonly) {\n        break;\n      }\n\n      if (state.preedit) {\n        text_edit_preedit_clear(mledit->model);\n      }\n\n      if (evt->replace) {\n        mledit_clear(mledit);\n      }\n      mledit_commit_str(widget, evt->text);\n      mledit_update_status(widget);\n      mledit->last_user_action_time = e->time;\n      widget_invalidate(widget, NULL);\n      break;\n    }\n    case EVT_IM_PREEDIT: {\n      mledit->last_user_action_time = e->time;\n      text_edit_preedit(mledit->model);\n      break;\n    }\n    case EVT_IM_PREEDIT_CONFIRM: {\n      mledit->last_user_action_time = e->time;\n      text_edit_preedit_confirm(mledit->model);\n      break;\n    }\n    case EVT_IM_PREEDIT_ABORT: {\n      mledit->last_user_action_time = e->time;\n      text_edit_preedit_abort(mledit->model);\n      break;\n    }\n    case EVT_IM_ACTION: {\n      mledit_commit_str(widget, \"\\n\");\n      widget_invalidate(widget, NULL);\n      break;\n    }\n    case EVT_KEY_UP: {\n      key_event_t* evt = key_event_cast(e);\n      int32_t key = evt->key;\n\n      if (key == TK_KEY_ESCAPE || (key >= TK_KEY_F1 && key <= TK_KEY_F12)) {\n        break;\n      }\n\n      if (key_code_is_enter(key)) {\n        ret = RET_STOP;\n      } else {\n        ret = text_edit_key_up(mledit->model, evt);\n      }\n      mledit->last_user_action_time = e->time;\n      widget_invalidate(widget, NULL);\n      break;\n    }\n    case EVT_IM_CANCEL: {\n      mledit_rollback_text(widget);\n      break;\n    }\n    case EVT_BLUR: {\n      if (mledit->close_im_when_blured) {\n        input_method_request(input_method(), NULL);\n      }\n      mledit_update_status(widget);\n      mledit_dispatch_event(widget, EVT_VALUE_CHANGED);\n      mledit_commit_text(widget);\n      break;\n    }\n    case EVT_FOCUS: {\n      if (mledit->timer_id == TK_INVALID_ID) {\n        mledit->timer_id = timer_add(mledit_update_caret, widget, 600);\n      }\n\n      if (widget->target == NULL) {\n        if (mledit->open_im_when_focused) {\n          mledit_request_input_method(widget);\n        }\n        widget_add_idle(widget, mledit_focus_set_cursor);\n      }\n      mledit_save_text(widget);\n      break;\n    }\n    case EVT_WHEEL: {\n      key_event_t kevt;\n      wheel_event_t* evt = (wheel_event_t*)e;\n      int32_t delta = evt->dy;\n      widget_t* vscroll_bar = widget_lookup_by_type(widget, WIDGET_TYPE_SCROLL_BAR_DESKTOP, TRUE);\n\n      if (vscroll_bar != NULL) {\n        int32_t font_size = style_get_int(widget->astyle, STYLE_ID_FONT_SIZE, TK_DEFAULT_FONT_SIZE);\n        if (delta > 0) {\n          scroll_bar_add_delta(vscroll_bar, -font_size * mledit->scroll_line);\n        } else if (delta < 0) {\n          scroll_bar_add_delta(vscroll_bar, font_size * mledit->scroll_line);\n        }\n      } else {\n        if (delta > 0) {\n          key_event_init(&kevt, EVT_KEY_DOWN, widget, TK_KEY_UP);\n          text_edit_key_down(mledit->model, (key_event_t*)&kevt);\n        } else if (delta < 0) {\n          key_event_init(&kevt, EVT_KEY_DOWN, widget, TK_KEY_DOWN);\n          text_edit_key_down(mledit->model, (key_event_t*)&kevt);\n        }\n      }\n      ret = RET_STOP;\n      mledit->last_user_action_time = e->time;\n      widget_invalidate(widget, NULL);\n      break;\n    }\n    case EVT_RESIZE:\n    case EVT_MOVE_RESIZE: {\n      mledit_reset_text_edit_layout(mledit->model);\n      widget_invalidate(widget, NULL);\n      break;\n    }\n    case EVT_VALUE_CHANGING: {\n      mledit_update_status(widget);\n      widget_invalidate(widget, NULL);\n      break;\n    }\n    case EVT_WIDGET_LOAD: {\n      uint32_t max_size = widget->text.size;\n      uint32_t line_break_num = mledit->max_lines;\n      uint32_t i = 0;\n\n      for (i = 0; i < max_size; i++) {\n        if (i + 1 < max_size &&\n            TWINS_WCHAR_IS_LINE_BREAK(widget->text.str[i], widget->text.str[i + 1])) {\n          line_break_num--;\n          i++;\n        } else if (WCHAR_IS_LINE_BREAK(widget->text.str[i])) {\n          line_break_num--;\n        }\n        if (line_break_num == 0) {\n          max_size = i;\n          break;\n        }\n      }\n\n      if (mledit->max_chars != 0) {\n        max_size = tk_min(max_size, mledit->max_chars);\n      }\n\n      if (max_size != widget->text.size) {\n        char* text = TKMEM_ZALLOCN(char, widget->text.size);\n        wstr_get_utf8(&widget->text, text, widget->text.size + 1);\n        text[max_size] = '\\0';\n        widget_set_text_utf8(widget, text);\n        TKMEM_FREE(text);\n      }\n    }\n    default:\n      break;\n  }\n\n  return ret;\n}",
            "key_variables": [
               [
                  871,
                  "mledit->bottom_margin"
               ],
               [
                  875,
                  "vscroll_bar->h"
               ]
            ]
         },
         {
            "type": "func",
            "name": "mledit_sync_scrollbar",
            "line_range": [
               863,
               888
            ],
            "source_code": "static ret_t mledit_sync_scrollbar(widget_t* widget, text_edit_state_t* state) {\n  xy_t y = 0;\n  wh_t virtual_h = 0;\n  widget_t* vscroll_bar = NULL;\n  mledit_t* mledit = MLEDIT(widget);\n  return_value_if_fail(mledit != NULL, RET_BAD_PARAMS);\n  virtual_h = (state->last_line_number + 1) * state->line_height + mledit->top_margin +\n              mledit->bottom_margin;\n  vscroll_bar = widget_lookup_by_type(widget, WIDGET_TYPE_SCROLL_BAR_DESKTOP, TRUE);\n\n  if (vscroll_bar != NULL) {\n    virtual_h = virtual_h >= vscroll_bar->h ? virtual_h : vscroll_bar->h;\n\n    if (virtual_h > vscroll_bar->h) {\n      y = state->oy * virtual_h / (virtual_h - vscroll_bar->h);\n    } else {\n      y = 0;\n    }\n\n    scroll_bar_set_params(vscroll_bar, virtual_h, state->line_height);\n    scroll_bar_set_value_only(vscroll_bar, y);\n    widget_invalidate_force(vscroll_bar, NULL);\n  }\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  911,
                  "scroll_bar->virtual_size"
               ]
            ]
         },
         {
            "type": "func",
            "name": "mledit_set_select",
            "line_range": [
               935,
               940
            ],
            "source_code": "ret_t mledit_set_select(widget_t* widget, uint32_t start, uint32_t end) {\n  mledit_t* mledit = MLEDIT(widget);\n  return_value_if_fail(mledit != NULL && mledit->model != NULL, RET_BAD_PARAMS);\n\n  return text_edit_set_select(mledit->model, start, end);\n}",
            "key_variables": [
               [
                  998,
                  "iter->next"
               ]
            ]
         }
      ],
      "src/ext_widgets/mutable_image/mutable_image.c": [
         {
            "type": "func",
            "name": "mutable_image_prepare_image",
            "line_range": [
               42,
               67
            ],
            "source_code": "static bitmap_t* mutable_image_prepare_image(widget_t* widget, canvas_t* c) {\n  mutable_image_t* mutable_image = MUTABLE_IMAGE(widget);\n  bitmap_format_t format = mutable_image_get_disire_format(widget, c);\n  return_value_if_fail(mutable_image != NULL && mutable_image->prepare_image != NULL, NULL);\n\n  if (mutable_image->create_image != NULL) {\n    void* ctx = mutable_image->create_image_ctx;\n    mutable_image->image = mutable_image->create_image(ctx, format, mutable_image->image);\n  } else if (mutable_image->image == NULL) {\n    mutable_image->image = bitmap_create_ex(widget->w, widget->h, 0, format);\n  }\n\n  if (mutable_image->image == NULL) {\n    return NULL;\n  }\n\n  if (mutable_image->prepare_image != NULL) {\n    bitmap_t* image = mutable_image->image;\n    void* ctx = mutable_image->prepare_image_ctx;\n\n    return_value_if_fail(mutable_image->prepare_image(ctx, image) == RET_OK, NULL);\n    image->flags |= BITMAP_FLAG_CHANGED;\n  }\n\n  return mutable_image->image;\n}",
            "key_variables": [
               [
                  49,
                  "mutable_image->create_image_ctx"
               ],
               [
                  60,
                  "mutable_image->image"
               ],
               [
                  61,
                  "mutable_image->prepare_image_ctx"
               ],
               [
                  67,
                  "mutable_image->image"
               ]
            ]
         }
      ],
      "src/ext_widgets/progress_circle/progress_circle.c": [
         {
            "type": "func",
            "name": "progress_circle_on_paint_background",
            "line_range": [
               27,
               57
            ],
            "source_code": "static ret_t progress_circle_on_paint_background(widget_t* widget, canvas_t* c) {\n  bitmap_t img;\n  style_t* style = widget->astyle;\n  color_t trans = color_init(0, 0, 0, 0);\n  vgcanvas_t* vg = canvas_get_vgcanvas(c);\n  progress_circle_t* progress_circle = PROGRESS_CIRCLE(widget);\n  color_t color = style_get_color(style, STYLE_ID_BG_COLOR, trans);\n  const char* image_name = style_get_str(style, STYLE_ID_BG_IMAGE, NULL);\n  bool_t has_image = image_name && widget_load_image(widget, image_name, &img) == RET_OK;\n\n  if (vg != NULL && (has_image || color.rgba.a)) {\n    xy_t cx = widget->w / 2;\n    xy_t cy = widget->h / 2;\n    float_t r = tk_min(cx, cy) - progress_circle->line_width / 2;\n    vgcanvas_save(vg);\n    vgcanvas_translate(vg, c->ox, c->oy);\n    vgcanvas_set_stroke_color(vg, color);\n    vgcanvas_set_line_width(vg, progress_circle->line_width);\n    vgcanvas_begin_path(vg);\n    vgcanvas_arc(vg, cx, cy, r, 0, M_PI * 2, FALSE);\n    if (has_image) {\n      vgcanvas_paint(vg, TRUE, &img);\n    } else {\n      vgcanvas_stroke(vg);\n    }\n\n    vgcanvas_restore(vg);\n  }\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  30,
                  "widget->astyle"
               ]
            ]
         },
         {
            "type": "func",
            "name": "progress_circle_update_text",
            "line_range": [
               59,
               81
            ],
            "source_code": "static ret_t progress_circle_update_text(widget_t* widget) {\n  char format[TK_NUM_MAX_LEN + 1];\n  char str[TK_NUM_MAX_LEN + 1];\n  progress_circle_t* progress_circle = PROGRESS_CIRCLE(widget);\n  return_value_if_fail(progress_circle != NULL, RET_BAD_PARAMS);\n\n  const char* unit = widget_get_prop_str(widget, PROGRESS_CIRCLE_PROP_UNIT, NULL);\n  if (progress_circle->format == NULL) {\n    const char* temp = unit != NULL ? unit : \"\";\n    tk_snprintf(format, TK_NUM_MAX_LEN, \"%u%s\", (uint32_t)progress_circle->value, temp);\n  } else {\n    uint32_t len = tk_strlen(progress_circle->format);\n    tk_strncpy_s(format, TK_NUM_MAX_LEN, progress_circle->format, len);\n  }\n\n  if (strchr(format, 'd') != NULL || strchr(format, 'x') != NULL || strchr(format, 'X') != NULL) {\n    tk_snprintf(str, TK_NUM_MAX_LEN, format, tk_roundi(progress_circle->value));\n  } else {\n    tk_snprintf(str, TK_NUM_MAX_LEN, format, progress_circle->value);\n  }\n\n  return widget_set_text_utf8(widget, str);\n}",
            "key_variables": [
               [
                  61,
                  "format[TK_NUM_MAX_LEN + 1]"
               ],
               [
                  62,
                  "str[TK_NUM_MAX_LEN + 1]"
               ]
            ]
         },
         {
            "type": "func",
            "name": "progress_circle_on_paint_self",
            "line_range": [
               83,
               146
            ],
            "source_code": "static ret_t progress_circle_on_paint_self(widget_t* widget, canvas_t* c) {\n  bitmap_t img;\n  style_t* style = widget->astyle;\n  color_t trans = color_init(0, 0, 0, 0);\n  vgcanvas_t* vg = canvas_get_vgcanvas(c);\n  progress_circle_t* progress_circle = PROGRESS_CIRCLE(widget);\n  color_t color = style_get_color(style, STYLE_ID_FG_COLOR, trans);\n  const char* image_name = style_get_str(style, STYLE_ID_FG_IMAGE, NULL);\n  bool_t has_image = image_name && widget_load_image(widget, image_name, &img) == RET_OK;\n\n  if (progress_circle->value > progress_circle->max) {\n    progress_circle->value = progress_circle->max;\n  }\n\n  if (vg != NULL && (has_image || color.rgba.a)) {\n    xy_t cx = widget->w / 2;\n    xy_t cy = widget->h / 2;\n    float_t end_angle = 0;\n    float_t r = tk_min(cx, cy) - progress_circle->line_width / 2;\n    bool_t ccw = progress_circle->counter_clock_wise;\n    float_t start_angle = TK_D2R(progress_circle->start_angle);\n    float_t angle = (M_PI * 2 * progress_circle->value) / progress_circle->max;\n\n    if (ccw) {\n      end_angle = start_angle - angle + M_PI * 2;\n      if (fabs(end_angle - start_angle) < 0.001f) {\n        end_angle = start_angle + 0.001f;\n      }\n    } else {\n      end_angle = start_angle + angle;\n    }\n\n    vgcanvas_save(vg);\n    vgcanvas_translate(vg, c->ox, c->oy);\n    vgcanvas_set_stroke_color(vg, color);\n    vgcanvas_set_line_width(vg, progress_circle->line_width);\n    if (tk_str_eq(progress_circle->line_cap, VGCANVAS_LINE_CAP_ROUND)) {\n      vgcanvas_set_line_cap(vg, VGCANVAS_LINE_CAP_ROUND);\n    } else if (tk_str_eq(progress_circle->line_cap, VGCANVAS_LINE_CAP_SQUARE)) {\n      vgcanvas_set_line_cap(vg, VGCANVAS_LINE_CAP_SQUARE);\n    } else {\n      vgcanvas_set_line_cap(vg, VGCANVAS_LINE_CAP_BUTT);\n    }\n    vgcanvas_begin_path(vg);\n    if (end_angle > start_angle) {\n      vgcanvas_arc(vg, cx, cy, r, start_angle, end_angle, ccw);\n      if (has_image) {\n        vgcanvas_paint(vg, TRUE, &img);\n      } else {\n        vgcanvas_stroke(vg);\n      }\n    }\n\n    vgcanvas_restore(vg);\n  }\n\n  color = style_get_color(style, STYLE_ID_TEXT_COLOR, trans);\n  if (progress_circle->show_text && color.rgba.a) {\n    progress_circle_update_text(widget);\n    widget_paint_helper(widget, c, NULL, NULL);\n  }\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  86,
                  "widget->astyle"
               ],
               [
                  95,
                  "progress_circle->max"
               ],
               [
                  103,
                  "progress_circle->counter_clock_wise"
               ],
               [
                  105,
                  "progress_circle->max"
               ]
            ]
         }
      ],
      "src/ext_widgets/rich_text/rich_text.c": [
         {
            "type": "func",
            "name": "rich_text_is_scollable",
            "line_range": [
               29,
               33
            ],
            "source_code": "static bool_t rich_text_is_scollable(widget_t* widget) {\n  rich_text_t* rich_text = RICH_TEXT(widget);\n  return_value_if_fail(rich_text != NULL, FALSE);\n  return (rich_text->content_h + rich_text->margin * 2) > widget->h;\n}",
            "key_variables": [
               [
                  33,
                  "widget->h"
               ]
            ]
         },
         {
            "type": "func",
            "name": "rich_text_reset",
            "line_range": [
               35,
               50
            ],
            "source_code": "static ret_t rich_text_reset(widget_t* widget) {\n  rich_text_t* rich_text = RICH_TEXT(widget);\n  return_value_if_fail(rich_text != NULL, RET_BAD_PARAMS);\n\n  if (rich_text->node != NULL) {\n    rich_text_node_destroy(rich_text->node);\n    rich_text->node = NULL;\n  }\n\n  if (rich_text->render_node != NULL) {\n    rich_text_render_node_destroy(rich_text->render_node);\n    rich_text->render_node = NULL;\n  }\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  59,
                  "rich_text->margin"
               ],
               [
                  63,
                  "rich_text->attribute_margin"
               ]
            ]
         },
         {
            "type": "func",
            "name": "rich_text_on_paint_text",
            "line_range": [
               70,
               168
            ],
            "source_code": "static ret_t rich_text_on_paint_text(widget_t* widget, canvas_t* c) {\n  rect_t r;\n  rect_t r_save;\n  int32_t yoffset = 0;\n  int32_t align_h = ALIGN_H_LEFT;\n  rich_text_render_node_t* iter = NULL;\n  rich_text_t* rich_text = RICH_TEXT(widget);\n  return_value_if_fail(widget != NULL && rich_text != NULL && c != NULL, RET_BAD_PARAMS);\n  yoffset = rich_text->yoffset;\n\n  if (widget->w <= rich_text->margin << 1 || widget->h <= rich_text->margin << 1) {\n    return RET_OK;\n  }\n\n  r = rect_init(c->ox, c->oy, widget->w, widget->h);\n  r.x += rich_text->margin;\n  r.y += rich_text->margin;\n  r.w -= rich_text->margin << 1;\n  r.h -= rich_text->margin << 1;\n\n  canvas_get_clip_rect(c, &r_save);\n  r = rect_intersect(&r, &r_save);\n  canvas_set_clip_rect(c, &r);\n\n  if (widget->astyle) {\n    align_h = style_get_int(widget->astyle, STYLE_ID_TEXT_ALIGN_H, ALIGN_H_LEFT);\n  }\n\n  iter = rich_text->render_node;\n  while (iter != NULL) {\n    r = iter->rect;\n    r.y -= yoffset;\n\n    if ((r.y + r.h) <= 0) {\n      iter = iter->next;\n      continue;\n    }\n\n    if (r.y > widget->h) {\n      break;\n    }\n\n    if (align_h == ALIGN_H_CENTER) {\n      r.x += iter->align_h_w >> 1;\n    } else if (align_h == ALIGN_H_RIGHT) {\n      r.x += iter->align_h_w;\n    }\n\n    switch (iter->node->type) {\n      case RICH_TEXT_TEXT: {\n        rect_t cr;\n        int32_t i = 0;\n        float_t x = r.x;\n        wchar_t* text = iter->text;\n        int32_t spacing = iter->spacing;\n        rich_text_font_t* font = &(iter->node->u.text.font);\n\n        canvas_set_text_color(c, font->color);\n        canvas_set_font(c, font->name, font->size);\n        canvas_set_text_align(c, ALIGN_H_LEFT, font->align_v);\n\n        for (i = 0; i < iter->size; i++) {\n          float_t cw = canvas_measure_text(c, text + i, 1);\n          cr.x = x;\n          cr.y = r.y;\n          cr.h = r.h;\n          cr.w = cw + 1;\n\n          canvas_draw_text_in_rect(c, text + i, 1, &cr);\n          x += cw;\n          if (spacing > 0) {\n            if (rich_text_is_flexable_w_char(text[i])) {\n              x += iter->flexible_w_char_delta_w;\n              spacing -= iter->flexible_w_char_delta_w;\n            }\n          }\n        }\n        break;\n      }\n      case RICH_TEXT_IMAGE: {\n        bitmap_t bitmap;\n        const char* name = iter->node->u.image.name;\n        image_draw_type_t draw_type = iter->node->u.image.draw_type;\n\n        if (widget_load_image(widget, name, &bitmap) == RET_OK) {\n          canvas_draw_image_ex(c, &bitmap, draw_type, &r);\n        }\n        break;\n      }\n      default:\n        break;\n    }\n\n    iter = iter->next;\n  }\n  canvas_set_clip_rect(c, &r_save);\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  79,
                  "rich_text->yoffset"
               ],
               [
                  86,
                  "rich_text->margin"
               ],
               [
                  87,
                  "rich_text->margin"
               ],
               [
                  99,
                  "rich_text->render_node"
               ],
               [
                  101,
                  "iter->rect"
               ],
               [
                  105,
                  "iter->next"
               ],
               [
                  116,
                  "iter->align_h_w"
               ],
               [
                  124,
                  "iter->text"
               ],
               [
                  125,
                  "iter->spacing"
               ],
               [
                  132,
                  "iter->size"
               ],
               [
                  143,
                  "iter->flexible_w_char_delta_w"
               ],
               [
                  144,
                  "iter->flexible_w_char_delta_w"
               ],
               [
                  164,
                  "iter->next"
               ]
            ]
         },
         {
            "type": "func",
            "name": "rich_text_is_need_reset_from_style",
            "line_range": [
               170,
               191
            ],
            "source_code": "static bool_t rich_text_is_need_reset_from_style(rich_text_t* rich_text, const char* font_name,\n                                                 uint16_t font_size, color_t color,\n                                                 align_v_t align_v) {\n  return_value_if_fail(rich_text != NULL, FALSE);\n  if (font_name != NULL && tk_str_cmp(rich_text->default_font_name, font_name) != 0) {\n    return TRUE;\n  }\n\n  if (rich_text->default_font_size != font_size) {\n    return TRUE;\n  }\n\n  if (rich_text->default_color.color != color.color) {\n    return TRUE;\n  }\n\n  if (rich_text->default_align_v != align_v) {\n    return TRUE;\n  }\n\n  return FALSE;\n}",
            "key_variables": [
               [
                  234,
                  "widget->w"
               ],
               [
                  235,
                  "widget->h"
               ],
               [
                  236,
                  "rich_text->line_gap"
               ],
               [
                  237,
                  "rich_text->margin"
               ]
            ]
         },
         {
            "type": "func",
            "name": "rich_text_on_scroll_done",
            "line_range": [
               256,
               264
            ],
            "source_code": "static ret_t rich_text_on_scroll_done(void* ctx, event_t* e) {\n  widget_t* widget = WIDGET(ctx);\n  rich_text_t* rich_text = RICH_TEXT(ctx);\n  return_value_if_fail(widget != NULL && rich_text != NULL, RET_BAD_PARAMS);\n\n  rich_text->wa = NULL;\n\n  return RET_REMOVE;\n}",
            "key_variables": [
               [
                  284,
                  "widget->h"
               ],
               [
                  291,
                  "rich_text->yoffset"
               ],
               [
                  293,
                  "rich_text->wa"
               ],
               [
                  299,
                  "rich_text->yoffset"
               ]
            ]
         },
         {
            "type": "func",
            "name": "rich_text_scroll_delta_to",
            "line_range": [
               314,
               321
            ],
            "source_code": "ret_t rich_text_scroll_delta_to(widget_t* widget, int32_t yoffset_delta) {\n  rich_text_t* rich_text = RICH_TEXT(widget);\n  return_value_if_fail(rich_text != NULL, RET_FAIL);\n\n  rich_text->yoffset_end = rich_text->yoffset + yoffset_delta;\n\n  return rich_text_scroll_to(widget, rich_text->yoffset_end);\n}",
            "key_variables": [
               [
                  341,
                  "e->y"
               ],
               [
                  342,
                  "rich_text->yoffset"
               ]
            ]
         },
         {
            "type": "func",
            "name": "rich_text_get_row_height",
            "line_range": [
               323,
               333
            ],
            "source_code": "static uint32_t rich_text_get_row_height(widget_t* widget) {\n  rich_text_t* rich_text = RICH_TEXT(widget);\n  return_value_if_fail(rich_text != NULL, 30);\n  if (rich_text->render_node != NULL) {\n    int32_t row_height = tk_max(rich_text->render_node->rect.h, 30);\n\n    return tk_min(row_height, widget->h / 2);\n  } else {\n    return 30;\n  }\n}",
            "key_variables": [
               [
                  354,
                  "rich_text->ydown"
               ]
            ]
         },
         {
            "type": "func",
            "name": "rich_text_on_pointer_up",
            "line_range": [
               365,
               378
            ],
            "source_code": "static ret_t rich_text_on_pointer_up(rich_text_t* rich_text, pointer_event_t* e) {\n  velocity_t* v = NULL;\n  int32_t yoffset_end = 0;\n  widget_t* widget = WIDGET(rich_text);\n  return_value_if_fail(rich_text != NULL && widget != NULL, RET_BAD_PARAMS);\n  v = &(rich_text->velocity);\n\n  velocity_update(v, e->e.time, e->x, e->y);\n  yoffset_end = rich_text->yoffset - v->yv;\n\n  rich_text_scroll_to(widget, yoffset_end);\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  374,
                  "v->yv"
               ]
            ]
         },
         {
            "type": "func",
            "name": "rich_text_pageup",
            "line_range": [
               403,
               414
            ],
            "source_code": "static ret_t rich_text_pageup(widget_t* widget) {\n  int32_t h = 0;\n  int32_t pageh = 0;\n  rich_text_t* rich_text = RICH_TEXT(widget);\n  uint32_t row_height = rich_text_get_row_height(widget);\n  return_value_if_fail(rich_text != NULL && widget != NULL, RET_BAD_PARAMS);\n\n  h = widget->h - rich_text->margin * 2 - 30;\n  pageh = tk_max(h, row_height);\n\n  return rich_text_scroll_delta_to(widget, -pageh);\n}",
            "key_variables": [
               [
                  445,
                  "e->type"
               ],
               [
                  446,
                  "rich_text->yslidable"
               ],
               [
                  491,
                  "rich_text->yoffset_save"
               ]
            ]
         }
      ],
      "src/ext_widgets/rich_text/rich_text_node.c": [
         {
            "type": "func",
            "name": "rich_text_image_destroy",
            "line_range": [
               96,
               104
            ],
            "source_code": "ret_t rich_text_image_destroy(rich_text_node_t* node) {\n  return_value_if_fail(node != NULL && node->type == RICH_TEXT_IMAGE, RET_BAD_PARAMS);\n\n  TKMEM_FREE(node->u.image.name);\n  memset(node, 0x00, sizeof(rich_text_node_t));\n  TKMEM_FREE(node);\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  116,
                  "iter->next"
               ]
            ]
         },
         {
            "type": "func",
            "name": "rich_text_node_append",
            "line_range": [
               106,
               121
            ],
            "source_code": "rich_text_node_t* rich_text_node_append(rich_text_node_t* node, rich_text_node_t* next) {\n  rich_text_node_t* iter = node;\n  return_value_if_fail(next != NULL, node);\n\n  if (node == NULL) {\n    return next;\n  }\n\n  while (iter->next != NULL) {\n    iter = iter->next;\n  }\n\n  iter->next = next;\n\n  return node;\n}",
            "key_variables": [
               [
                  130,
                  "iter->next"
               ],
               [
                  149,
                  "iter->next"
               ]
            ]
         }
      ],
      "src/ext_widgets/rich_text/rich_text_parser.c": [
         {
            "type": "block",
            "name": "block",
            "line_range": "",
            "source_code": "",
            "key_variables": [
               37,
               "fonts[MAX_FONT_LEVEL]"
            ]
         },
         {
            "type": "func",
            "name": "xml_rich_text_push_font",
            "line_range": [
               42,
               50
            ],
            "source_code": "static void xml_rich_text_push_font(xml_builder_t* b) {\n  b->font_level++;\n  b->fonts[b->font_level] = b->fonts[b->font_level - 1];\n\n  b->font = b->fonts + b->font_level;\n  if (b->font->name != NULL) {\n    b->font->name = tk_strdup(b->font->name);\n  }\n}",
            "key_variables": [
               [
                  45,
                  "fonts[b->font_level - 1]"
               ],
               [
                  47,
                  "b->font_level"
               ]
            ]
         },
         {
            "type": "func",
            "name": "xml_rich_text_pop_font",
            "line_range": [
               52,
               62
            ],
            "source_code": "static void xml_rich_text_pop_font(xml_builder_t* b) {\n  rich_text_font_t* font = b->fonts + b->font_level;\n\n  if (font->name != NULL) {\n    TKMEM_FREE(font->name);\n    font->name = NULL;\n  }\n\n  b->font_level--;\n  b->font = b->fonts + b->font_level;\n}",
            "key_variables": [
               [
                  54,
                  "b->font_level"
               ],
               [
                  62,
                  "b->font_level"
               ]
            ]
         },
         {
            "type": "func",
            "name": "xml_rich_text_on_start",
            "line_range": [
               64,
               129
            ],
            "source_code": "static void xml_rich_text_on_start(XmlBuilder* thiz, const char* tag, const char** attrs) {\n  int32_t i = 0;\n  xml_builder_t* b = (xml_builder_t*)thiz;\n\n  if (tk_str_eq(tag, \"font\")) {\n    xml_rich_text_push_font(b);\n    b->font->align_v = ALIGN_V_BOTTOM;\n\n    while (attrs[i]) {\n      const char* key = attrs[i];\n      const char* value = attrs[i + 1];\n      if (tk_str_eq(key, \"size\")) {\n        b->font->size = tk_atoi(value);\n      } else if (tk_str_eq(key, \"color\")) {\n        b->font->color = color_parse(value);\n      } else if (tk_str_eq(key, \"align_v\")) {\n        const key_type_value_t* kv = align_v_type_find(value);\n        if (kv != NULL) {\n          b->font->align_v = (align_v_t)(kv->value);\n        }\n      } else if (tk_str_eq(key, \"name\")) {\n        TKMEM_FREE(b->font->name);\n        b->font->name = tk_strdup(value);\n      }\n      i += 2;\n    }\n  } else if (tk_str_eq(tag, \"b\")) {\n    xml_rich_text_push_font(b);\n    b->font->bold = TRUE;\n  } else if (tk_str_eq(tag, \"i\")) {\n    xml_rich_text_push_font(b);\n    b->font->italic = TRUE;\n  } else if (tk_str_eq(tag, \"u\")) {\n    xml_rich_text_push_font(b);\n    b->font->underline = TRUE;\n  } else if (tk_str_eq(tag, \"image\")) {\n    int32_t w = 0;\n    int32_t h = 0;\n    int32_t draw_type = IMAGE_DRAW_CENTER;\n    const char* image_name = NULL;\n\n    while (attrs[i]) {\n      const char* key = attrs[i];\n      const char* value = attrs[i + 1];\n      if (tk_str_eq(key, \"name\")) {\n        image_name = value;\n      } else if (tk_str_eq(key, \"w\")) {\n        w = tk_atoi(value);\n      } else if (tk_str_eq(key, \"h\")) {\n        h = tk_atoi(value);\n      } else if (tk_str_eq(key, \"draw_type\")) {\n        const key_type_value_t* kv = image_draw_type_find(value);\n        if (kv != NULL) {\n          draw_type = kv->value;\n        }\n      }\n      i += 2;\n    }\n\n    if (image_name != NULL) {\n      b->node = rich_text_node_append(b->node, rich_text_image_create(image_name, w, h, draw_type));\n    }\n  }\n\n  return;\n}",
            "key_variables": [
               [
                  74,
                  "attrs[i]"
               ],
               [
                  75,
                  "attrs[i + 1]"
               ],
               [
                  107,
                  "attrs[i]"
               ],
               [
                  108,
                  "attrs[i + 1]"
               ],
               [
                  118,
                  "kv->value"
               ]
            ]
         },
         {
            "type": "func",
            "name": "xml_rich_text_on_text",
            "line_range": [
               140,
               148
            ],
            "source_code": "static void xml_rich_text_on_text(XmlBuilder* thiz, const char* text, size_t length) {\n  xml_builder_t* b = (xml_builder_t*)thiz;\n  rich_text_font_t* font = b->font;\n\n  str_decode_xml_entity_with_len(&(b->temp), text, length);\n  b->node = rich_text_node_append(b->node, rich_text_text_create(font, b->temp.str));\n\n  return;\n}",
            "key_variables": [
               [
                  143,
                  "b->font"
               ]
            ]
         },
         {
            "type": "func",
            "name": "xml_rich_text_destroy",
            "line_range": [
               156,
               160
            ],
            "source_code": "static void xml_rich_text_destroy(XmlBuilder* thiz) {\n  xml_builder_t* b = (xml_builder_t*)thiz;\n  str_reset(&(b->temp));\n  return;\n}",
            "key_variables": [
               [
                  173,
                  "b->fonts"
               ]
            ]
         }
      ],
      "src/ext_widgets/rich_text/rich_text_render_node.c": [
         {
            "type": "func",
            "name": "rich_text_render_node_tune_row",
            "line_range": [
               47,
               108
            ],
            "source_code": "ret_t rich_text_render_node_tune_row(rich_text_render_node_t* row_first_node, int32_t row_h,\n                                     int32_t flexible_w, int32_t client_w) {\n  int32_t dx = 0;\n  int32_t flexible_w_chars = 0;\n  int32_t flexible_w_chars_w = 0;\n  int32_t align_h_w = flexible_w > 0 ? 0 : client_w;\n  rich_text_render_node_t* iter = row_first_node;\n\n  while (iter != NULL) {\n    if (flexible_w > 0) {\n      if (iter->node->type == RICH_TEXT_TEXT) {\n        int32_t i = 0;\n        for (i = 0; i < iter->size; i++) {\n          if (rich_text_is_flexable_w_char(iter->text[i])) {\n            iter->flexible_w_chars++;\n            flexible_w_chars++;\n          }\n        }\n      }\n    } else {\n      align_h_w -= iter->rect.w;\n    }\n\n    iter = iter->next;\n  }\n\n  if (flexible_w_chars > 0) {\n    flexible_w_chars_w = tk_max(1, (flexible_w / flexible_w_chars));\n  } else {\n    flexible_w_chars_w = 0;\n  }\n\n  iter = row_first_node;\n  while (iter != NULL) {\n    iter->align_h_w = align_h_w;\n    iter->rect.h = row_h;\n    iter->rect.x += dx;\n\n    switch (iter->node->type) {\n      case RICH_TEXT_TEXT: {\n        if (flexible_w > 0) {\n          int32_t spacing = iter->flexible_w_chars * flexible_w_chars_w;\n          iter->spacing = tk_min(spacing, flexible_w);\n          iter->flexible_w_char_delta_w = flexible_w_chars_w;\n\n          flexible_w -= iter->spacing;\n          dx += iter->spacing;\n        }\n        break;\n      }\n      case RICH_TEXT_IMAGE: {\n        break;\n      }\n      default:\n        break;\n    }\n\n    iter = iter->next;\n  }\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  60,
                  "iter->size"
               ],
               [
                  71,
                  "iter->next"
               ],
               [
                  93,
                  "iter->spacing"
               ],
               [
                  94,
                  "iter->spacing"
               ],
               [
                  105,
                  "iter->next"
               ]
            ]
         },
         {
            "type": "func",
            "name": "rich_text_render_node_layout",
            "line_range": [
               128,
               319
            ],
            "source_code": "rich_text_render_node_t* rich_text_render_node_layout(widget_t* widget, rich_text_node_t* node,\n                                                      canvas_t* c, int32_t w, int32_t h,\n                                                      int32_t margin, int32_t line_gap) {\n  int32_t row_h = 0;\n  int32_t x = margin;\n  int32_t y = margin;\n  int32_t right = w - margin;\n  int32_t client_w = w - 2 * margin;\n  int32_t client_h = h - 2 * margin;\n  rich_text_node_t* iter = node;\n  rich_text_t* rich_text = RICH_TEXT(widget);\n  rich_text_render_node_t* new_node = NULL;\n  rich_text_render_node_t* render_node = NULL;\n  rich_text_render_node_t* row_first_node = NULL;\n  return_value_if_fail(node != NULL && c != NULL && client_w > 0 && client_h > 0, NULL);\n\n  while (iter != NULL) {\n    switch (iter->type) {\n      case RICH_TEXT_IMAGE: {\n        bitmap_t bitmap;\n        int32_t flexible_w = 0;\n        rich_text_image_t* image = &(iter->u.image);\n        const char* name = image->name;\n        new_node = rich_text_render_node_create(iter);\n        return_value_if_fail(new_node != NULL, render_node);\n\n        if (widget_load_image(widget, name, &bitmap) == RET_OK) {\n          if (image->w == 0) {\n            image->w = bitmap.w;\n          }\n          if (image->h == 0) {\n            image->h = bitmap.h;\n          }\n        }\n\n        if (x > margin && (image->w > ICON_SIZE || x + image->w > right)) {\n          MOVE_TO_NEXT_ROW();\n        }\n\n        new_node->rect.x = x;\n        new_node->rect.y = y;\n        new_node->rect.w = image->w;\n        new_node->rect.h = image->h;\n\n        if (image->w > ICON_SIZE) {\n          new_node->rect.w = client_w;\n        }\n\n        if (row_h < image->h) {\n          row_h = image->h;\n        }\n\n        render_node = rich_text_render_node_append(render_node, new_node);\n        if (x + image->w >= right) {\n          MOVE_TO_NEXT_ROW();\n        } else {\n          if (row_first_node == NULL) {\n            row_first_node = new_node;\n          }\n          x += new_node->rect.w + 1;\n        }\n\n        rich_text->content_h = new_node->rect.y + new_node->rect.h;\n        break;\n      }\n      case RICH_TEXT_TEXT: {\n        int32_t i = 0;\n        float_t tw = 0;\n        float_t cw = 0;\n        int32_t start = 0;\n        int32_t flexible_w = 0;\n        int32_t last_breakable = 0;\n        wchar_t* str = iter->u.text.text;\n        break_type_t break_type = LINE_BREAK_ALLOW;\n        int32_t font_size = iter->u.text.font.size;\n\n        if (row_h < font_size) {\n          row_h = font_size;\n        }\n        canvas_set_font(c, iter->u.text.font.name, font_size);\n\n        for (i = 0; str[i]; i++) {\n          cw = canvas_measure_text(c, str + i, 1);\n          if (i > 0) {\n            break_type = rich_text_line_break_check(str[i - 1], str[i]);\n          }\n          if (str[i] == '\\r' || str[i] == '\\n') {\n            break_type = LINE_BREAK_MUST;\n          }\n\n          if ((x + tw + cw) > right || break_type == LINE_BREAK_MUST) {\n            if (break_type != LINE_BREAK_MUST) {\n              if (last_breakable > start) {\n                if (i != last_breakable + 1 || break_type != LINE_BREAK_ALLOW) {\n                  tw -= canvas_measure_text(c, str + last_breakable, i - last_breakable);\n                  i = last_breakable;\n                }\n              }\n              if (x == margin) {\n                // 一行的起始不需要换行，且最少包含一个字符\n                if (i == start) {\n                  i = start + 1;\n                }\n              } else if (start == 0 && last_breakable == 0) {\n                // 不是起始，换行,重新计算\n                MOVE_TO_NEXT_ROW();\n                row_h = font_size;\n                --i;\n                continue;\n              }\n            }\n\n            new_node = rich_text_render_node_create(iter);\n            return_value_if_fail(new_node != NULL, render_node);\n\n            new_node->text = str + start;\n            new_node->size = i - start;\n            new_node->rect = rect_init(x, y, tw, font_size);\n\n            render_node = rich_text_render_node_append(render_node, new_node);\n            if (row_first_node == NULL) {\n              row_first_node = new_node;\n            }\n\n            if (break_type == LINE_BREAK_MUST) {\n              ++i;\n              if (str[i - 1] == '\\r' && str[i] == '\\n') ++i;\n            } else {\n              if (str[i] == ' ' || str[i] == '\\t') {\n                i++;\n              }\n            }\n\n            MOVE_TO_NEXT_ROW();\n            row_h = font_size;\n\n            while (str[i] == '\\r' || str[i] == '\\n') {\n              if (str[i] == '\\r' && str[i + 1] == '\\n') {\n                ++i;\n              }\n              MOVE_TO_NEXT_ROW();\n              row_h = font_size;\n              ++i;\n            }\n            start = i;\n\n            if (!str[i]) break;\n            last_breakable = i;\n            tw = canvas_measure_text(c, str + i, 1);\n          } else {\n            if (i > 0) {\n              if (rich_text_line_break_check(str[i - 1], str[i]) == LINE_BREAK_ALLOW) {\n                last_breakable = i;\n              }\n            }\n\n            tw += cw;\n          }\n        }\n\n        if (i > start) {\n          new_node = rich_text_render_node_create(iter);\n          return_value_if_fail(new_node != NULL, render_node);\n\n          new_node->text = str + start;\n          new_node->size = i - start;\n          new_node->rect = rect_init(x, y, tw, font_size);\n          x += tw + 1;\n          tw = 0;\n\n          render_node = rich_text_render_node_append(render_node, new_node);\n          if (row_first_node == NULL) {\n            row_first_node = new_node;\n          }\n        }\n\n        rich_text->content_h = new_node->rect.y + new_node->rect.h;\n        break;\n      }\n      default:\n        break;\n    }\n\n    iter = iter->next;\n  }\n\n  if (row_first_node != NULL) {\n    rich_text_render_node_tune_row(row_first_node, row_h, 0, client_w);\n  }\n\n  return render_node;\n}",
            "key_variables": [
               [
                  151,
                  "image->name"
               ],
               [
                  170,
                  "image->w"
               ],
               [
                  171,
                  "image->h"
               ],
               [
                  178,
                  "image->h"
               ],
               [
                  210,
                  "str[i]"
               ],
               [
                  312,
                  "iter->next"
               ],
               [
                  332,
                  "iter->next"
               ]
            ]
         },
         {
            "type": "func",
            "name": "rich_text_render_node_append",
            "line_range": [
               321,
               337
            ],
            "source_code": "rich_text_render_node_t* rich_text_render_node_append(rich_text_render_node_t* node,\n                                                      rich_text_render_node_t* next) {\n  rich_text_render_node_t* iter = node;\n  return_value_if_fail(next != NULL, node);\n\n  if (node == NULL) {\n    return next;\n  }\n\n  while (iter->next != NULL) {\n    iter = iter->next;\n  }\n\n  iter->next = next;\n\n  return node;\n}",
            "key_variables": [
               [
                  347,
                  "iter->next"
               ],
               [
                  359,
                  "iter->next"
               ]
            ]
         }
      ],
      "src/ext_widgets/rich_text/rich_text_view.c": [
         {
            "type": "func",
            "name": "rich_text_view_sync_rich_text_to_scroll_bar",
            "line_range": [
               49,
               75
            ],
            "source_code": "static ret_t rich_text_view_sync_rich_text_to_scroll_bar(widget_t* widget) {\n  int32_t h = 0;\n  int32_t max = 0;\n  int32_t value = 0;\n  int32_t yoffset = 0;\n  int32_t virtual_h = 0;\n  rich_text_view_t* rich_text_view = RICH_TEXT_VIEW(widget);\n  return_value_if_fail(rich_text_view != NULL, RET_BAD_PARAMS);\n\n  yoffset = widget_get_prop_int(rich_text_view->rich_text, WIDGET_PROP_YOFFSET, 0);\n  virtual_h = widget_get_prop_int(rich_text_view->rich_text, WIDGET_PROP_VIRTUAL_H, 0);\n  h = rich_text_view->rich_text->h;\n  max = tk_max(virtual_h, h);\n\n  if (max > h) {\n    value = (yoffset * max) / (max - h);\n  }\n\n  if (rich_text_view->scroll_bar != NULL) {\n    emitter_disable(rich_text_view->scroll_bar->emitter);\n    widget_set_prop_int(rich_text_view->scroll_bar, WIDGET_PROP_MAX, max);\n    widget_set_prop_int(rich_text_view->scroll_bar, WIDGET_PROP_VALUE, value);\n    emitter_enable(rich_text_view->scroll_bar->emitter);\n  }\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  61,
                  "rich_text->h"
               ]
            ]
         }
      ],
      "src/ext_widgets/scroll_label/hscroll_label.c": [
         {
            "type": "func",
            "name": "hscroll_label_do_paint_self",
            "line_range": [
               36,
               68
            ],
            "source_code": "static ret_t hscroll_label_do_paint_self(widget_t* widget, canvas_t* c, uint32_t left_margin,\n                                         uint32_t right_margin) {\n  rect_t r = {0, 0, 0, 0};\n  wstr_t* text = &(widget->text);\n  uint32_t w = widget->w - left_margin - right_margin;\n  hscroll_label_t* hscroll_label = HSCROLL_LABEL(widget);\n\n  hscroll_label->text_w = canvas_measure_text(c, text->str, text->size);\n  if (hscroll_label->text_w != hscroll_label->old_text_w) {\n    if (tk_str_eq(widget->state, WIDGET_STATE_FOCUSED)) {\n      hscroll_label_start(widget);\n    } else {\n      hscroll_label_check_and_start(widget);\n    }\n    hscroll_label->old_text_w = hscroll_label->text_w;\n  }\n  if (w < hscroll_label->text_w && hscroll_label->ellipses && !hscroll_label_is_running(widget)) {\n    r = rect_init(left_margin, 0, w, widget->h);\n\n    return widget_draw_text_in_rect(widget, c, text->str, text->size, &r, TRUE);\n  }\n\n  if (w > hscroll_label->text_w) {\n    int32_t align_v = style_get_int(widget->astyle, STYLE_ID_TEXT_ALIGN_V, ALIGN_V_MIDDLE);\n    int32_t align_h = style_get_int(widget->astyle, STYLE_ID_TEXT_ALIGN_H, ALIGN_H_LEFT);\n    canvas_set_text_align(c, (align_h_t)align_h, (align_v_t)align_v);\n  } else {\n    canvas_set_text_align(c, ALIGN_H_LEFT, ALIGN_V_MIDDLE);\n  }\n\n  r = rect_init(left_margin - hscroll_label->xoffset, 0, w, widget->h);\n  return widget_draw_text_in_rect(widget, c, text->str, text->size, &r, FALSE);\n}",
            "key_variables": [
               [
                  51,
                  "hscroll_label->text_w"
               ],
               [
                  78,
                  "widget->astyle"
               ]
            ]
         },
         {
            "type": "func",
            "name": "hscroll_label_step",
            "line_range": [
               240,
               274
            ],
            "source_code": "ret_t hscroll_label_step(widget_t* widget) {\n  int32_t range = 0;\n  float_t percent = 0;\n  ret_t ret = RET_REPEAT;\n  hscroll_label_t* hscroll_label = HSCROLL_LABEL(widget);\n\n  int32_t left_margin = style_get_int(widget->astyle, STYLE_ID_MARGIN_LEFT, 2);\n  int32_t right_margin = style_get_int(widget->astyle, STYLE_ID_MARGIN_RIGHT, 2);\n  int32_t w = widget->w - left_margin - right_margin;\n\n  if (hscroll_label->elapsed >= hscroll_label->duration) {\n    hscroll_label->elapsed = hscroll_label->duration;\n  }\n\n  if (hscroll_label->text_w < w) {\n    range = 0;\n    ret = RET_REMOVE;\n  } else {\n    range = hscroll_label->text_w - w;\n  }\n\n  percent = (float_t)hscroll_label->elapsed / (float_t)(hscroll_label->duration);\n  if (hscroll_label->reversed) {\n    percent = 1 - percent;\n  }\n\n  hscroll_label->xoffset += range * percent - hscroll_label->xoffset;\n  if (hscroll_label->xoffset > range) {\n    ret = RET_REMOVE;\n  }\n\n  widget_invalidate_force(widget, NULL);\n\n  return ret;\n}",
            "key_variables": [
               [
                  252,
                  "hscroll_label->duration"
               ],
               [
                  267,
                  "hscroll_label->xoffset"
               ]
            ]
         },
         {
            "type": "func",
            "name": "hscroll_label_check_and_start",
            "line_range": [
               276,
               291
            ],
            "source_code": "static ret_t hscroll_label_check_and_start(widget_t* widget) {\n  hscroll_label_t* hscroll_label = HSCROLL_LABEL(widget);\n  return_value_if_fail(widget != NULL && hscroll_label != NULL, RET_BAD_PARAMS);\n  if (hscroll_label->only_focus) {\n    if (widget->focused) {\n      hscroll_label_start(widget);\n    }\n  } else if (hscroll_label->only_parent_focus) {\n    if (widget->parent->focused) {\n      hscroll_label_start(widget);\n    }\n  } else {\n    hscroll_label_start(widget);\n  }\n  return RET_OK;\n}",
            "key_variables": [
               [
                  312,
                  "info->duration"
               ],
               [
                  334,
                  "hscroll_label->lull"
               ],
               [
                  348,
                  "hscroll_label->reversed"
               ]
            ]
         },
         {
            "type": "func",
            "name": "hscroll_label_on_destroy",
            "line_range": [
               384,
               390
            ],
            "source_code": "static ret_t hscroll_label_on_destroy(widget_t* widget) {\n  if (hscroll_label_is_running(widget)) {\n    hscroll_label_stop(widget);\n  }\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  394,
                  "e->type"
               ]
            ]
         }
      ],
      "src/ext_widgets/scroll_view/children_layouter_list_view.c": [
         {
            "type": "func",
            "name": "children_layouter_list_view_to_string",
            "line_range": [
               32,
               88
            ],
            "source_code": "static const char* children_layouter_list_view_to_string(children_layouter_t* layouter) {\n  char temp[32];\n  str_t* str = &(layouter->params);\n  children_layouter_list_view_t* layout = (children_layouter_list_view_t*)layouter;\n  return_value_if_fail(layout != NULL, NULL);\n  memset(temp, 0, sizeof(temp));\n  str_set(str, \"list_view(\");\n  str_append(str, temp);\n\n  if (layout->item_height) {\n    tk_snprintf(temp, sizeof(temp) - 1, \"item_height=%d,\", (int)(layout->item_height));\n  }\n  str_append(str, temp);\n\n  if (layout->default_item_height) {\n    tk_snprintf(temp, sizeof(temp) - 1, \"default_item_height=%d,\",\n                (int)(layout->default_item_height));\n  }\n  str_append(str, temp);\n\n  if (layout->x_margin) {\n    tk_snprintf(temp, sizeof(temp) - 1, \"x_margin=%d,\", (int)(layout->x_margin));\n    str_append(str, temp);\n  }\n\n  if (layout->y_margin) {\n    tk_snprintf(temp, sizeof(temp) - 1, \"y_margin=%d,\", (int)(layout->y_margin));\n    str_append(str, temp);\n  }\n\n  if (layout->spacing) {\n    tk_snprintf(temp, sizeof(temp) - 1, \"spacing=%d,\", (int)(layout->spacing));\n    str_append(str, temp);\n  }\n\n  if (layout->cols > 1) {\n    tk_snprintf(temp, sizeof(temp) - 1, \"cols=%d,\", (int)(layout->cols));\n    str_append(str, temp);\n  }\n\n  if (!(layout->keep_disable)) {\n    str_append(str, \"keep_disable=false,\");\n  }\n\n  if (layout->keep_invisible) {\n    str_append(str, \"keep_invisible=true,\");\n  }\n\n  if (layout->hlayouter) {\n    str_append(str, \"hlayouter=true,\");\n  }\n\n  str_trim_right(str, \",\");\n  str_append(str, \")\");\n\n  return str->str;\n}",
            "key_variables": [
               [
                  34,
                  "temp[32]"
               ],
               [
                  88,
                  "str->str"
               ]
            ]
         },
         {
            "type": "func",
            "name": "children_layouter_list_view_get_param",
            "line_range": [
               146,
               202
            ],
            "source_code": "static ret_t children_layouter_list_view_get_param(children_layouter_t* layouter, const char* name,\n                                                   value_t* v) {\n  children_layouter_list_view_t* l = (children_layouter_list_view_t*)layouter;\n\n  switch (*name) {\n    case 'x': {\n      value_set_int(v, l->x_margin);\n      return RET_OK;\n    }\n    case 'y': {\n      value_set_int(v, l->y_margin);\n      return RET_OK;\n    }\n    case 'm': {\n      value_set_int(v, l->x_margin);\n      return RET_OK;\n    }\n    case 's': {\n      value_set_int(v, l->spacing);\n      return RET_OK;\n    }\n    case 'i': {\n      value_set_int(v, l->item_height);\n      return RET_OK;\n    }\n    case 'd': {\n      value_set_int(v, l->default_item_height);\n      return RET_OK;\n    }\n    case 'c': {\n      value_set_int(v, l->cols);\n      return RET_OK;\n    }\n    case 'k': {\n      if (strstr(name, \"invisible\") != NULL || name[1] == 'i') {\n        value_set_bool(v, l->keep_invisible);\n        return RET_OK;\n      } else if (strstr(name, \"disable\") != NULL || name[1] == 'd') {\n        value_set_bool(v, l->keep_disable);\n        return RET_OK;\n      }\n      break;\n    }\n    case 'h': {\n      if (strstr(name, \"layouter\") != NULL || name[1] == 'l') {\n        value_set_bool(v, l->hlayouter);\n      }\n      break;\n    }\n    default: {\n      assert(!\"not support param\");\n      break;\n    }\n  }\n\n  return RET_FAIL;\n}",
            "key_variables": [
               [
                  212,
                  "children_for_layout->size"
               ],
               [
                  213,
                  "children_for_layout->elms"
               ],
               [
                  215,
                  "children[i]"
               ],
               [
                  218,
                  "parent->w"
               ],
               [
                  228,
                  "iter->h"
               ]
            ]
         },
         {
            "type": "func",
            "name": "children_layouter_list_view_for_list_view_children_layout_w",
            "line_range": [
               237,
               276
            ],
            "source_code": "static ret_t children_layouter_list_view_for_list_view_children_layout_w(\n    darray_t* children_for_layout, uint32_t cols, int32_t x_margin, int32_t y_margin,\n    int32_t spacing, int32_t scroll_view_w) {\n  int32_t i = 0;\n  int32_t w = 0;\n  int32_t x = x_margin;\n  int32_t y = y_margin;\n  widget_t** children = NULL;\n  return_value_if_fail(children_for_layout != NULL, RET_BAD_PARAMS);\n  w = scroll_view_w - 2 * x_margin;\n  children = (widget_t**)children_for_layout->elms;\n  if (cols <= 1) {\n    for (i = 0; i < children_for_layout->size; i++) {\n      widget_t* iter = children[i];\n      widget_move_resize(iter, x, y, w, iter->h);\n      widget_layout_children(iter);\n      y += (iter->h + spacing);\n    }\n  } else {\n    int32_t j = 0;\n    int32_t n = 0;\n    int32_t h = 0;\n    int32_t size = children_for_layout->size;\n    uint32_t rows = (size % cols) ? (size / cols) + 1 : (size / cols);\n\n    w = (w - (cols - 1) * spacing) / cols;\n    for (i = 0; i < rows && n < size; i++) {\n      h = 0;\n      for (j = 0; j < cols && n < size; j++, n++) {\n        widget_t* iter = children[n];\n        int32_t tmp_x = x + j * (w + spacing);\n        widget_move_resize(iter, tmp_x, y, w, iter->h);\n        widget_layout_children(iter);\n        h = tk_max(h, iter->h);\n      }\n      y += (h + spacing);\n    }\n  }\n  return RET_OK;\n}",
            "key_variables": [
               [
                  248,
                  "children_for_layout->elms"
               ],
               [
                  250,
                  "children_for_layout->size"
               ],
               [
                  251,
                  "children[i]"
               ],
               [
                  260,
                  "children_for_layout->size"
               ],
               [
                  267,
                  "children[n]"
               ],
               [
                  285,
                  "children_for_layout->elms"
               ],
               [
                  287,
                  "children_for_layout->size"
               ],
               [
                  294,
                  "children_for_layout->size"
               ],
               [
                  296,
                  "children_for_layout->size"
               ],
               [
                  297,
                  "children_for_layout->size"
               ]
            ]
         },
         {
            "type": "func",
            "name": "children_layouter_list_view_for_list_view_get_virtual_h",
            "line_range": [
               278,
               303
            ],
            "source_code": "static int32_t children_layouter_list_view_for_list_view_get_virtual_h(\n    darray_t* children_for_layout, uint32_t cols, int32_t y_margin, int32_t spacing) {\n  int32_t i = 0;\n  widget_t** children = NULL;\n  int32_t virtual_h = y_margin;\n  return_value_if_fail(children_for_layout != NULL, 0);\n  children = (widget_t**)children_for_layout->elms;\n  if (cols <= 1) {\n    for (i = 0; i < children_for_layout->size; i++) {\n      virtual_h += (children[i]->h + spacing);\n    }\n  } else {\n    int32_t j = 0;\n    int32_t h = 0;\n    int32_t num = 0;\n    int32_t n = children_for_layout->size;\n    uint32_t rows = (n % cols) ? (n / cols) + 1 : (n / cols);\n    for (i = 0; i < rows && num < children_for_layout->size; i++) {\n      for (j = 0, h = 0; j < cols && num < children_for_layout->size; j++, num++) {\n        h = tk_max(h, children[num]->h);\n      }\n      virtual_h += (h + spacing);\n    }\n  }\n  return virtual_h;\n}",
            "key_variables": [
               [
                  312,
                  "list_view->scroll_bar"
               ],
               [
                  318,
                  "scroll_bar->w"
               ],
               [
                  343,
                  "widget->h"
               ]
            ]
         },
         {
            "type": "func",
            "name": "children_layouter_list_view_for_list_view_set_scroll_bar_info",
            "line_range": [
               352,
               388
            ],
            "source_code": "static ret_t children_layouter_list_view_for_list_view_set_scroll_bar_info(widget_t* widget,\n                                                                           list_view_t* list_view,\n                                                                           widget_t* scroll_view,\n                                                                           int32_t virtual_h,\n                                                                           int32_t item_height) {\n  scroll_view_t* ascroll_view = SCROLL_VIEW(scroll_view);\n  return_value_if_fail(list_view != NULL && ascroll_view != NULL, RET_BAD_PARAMS);\n\n  scroll_bar_set_params(widget, virtual_h, item_height);\n  if (scroll_bar_is_mobile(widget)) {\n    if (widget->h > virtual_h) {\n      scroll_bar_set_params(widget, widget->h, item_height);\n    }\n\n    if (SCROLL_BAR(widget)->auto_hide && !ascroll_view->dragged && ascroll_view->wa == NULL) {\n      widget_set_visible_only(widget, FALSE);\n    }\n  } else {\n    if (scroll_view->h >= virtual_h) {\n      scroll_bar_set_value(widget, 0);\n      if (list_view->auto_hide_scroll_bar || list_view->floating_scroll_bar) {\n        widget_set_visible_only(widget, FALSE);\n      } else {\n        widget_set_enable(widget, FALSE);\n        widget_set_visible_only(widget, TRUE);\n      }\n    } else {\n      if (list_view->auto_hide_scroll_bar && list_view->floating_scroll_bar) {\n        widget_set_visible_only(widget, list_view->is_over);\n      } else {\n        widget_set_enable(widget, TRUE);\n        widget_set_visible_only(widget, TRUE);\n      }\n    }\n  }\n  return RET_OK;\n}",
            "key_variables": [
               [
                  404,
                  "l->item_height"
               ],
               [
                  406,
                  "l->default_item_height"
               ],
               [
                  411,
                  "l->cols"
               ]
            ]
         },
         {
            "type": "func",
            "name": "children_layouter_list_view_for_list_view_layout",
            "line_range": [
               390,
               441
            ],
            "source_code": "static ret_t children_layouter_list_view_for_list_view_layout(children_layouter_t* layouter,\n                                                              widget_t* widget) {\n  int32_t virtual_h = 0;\n  int32_t item_height = 0;\n  list_view_t* list_view = NULL;\n  int32_t default_item_height = 0;\n  scroll_view_t* scroll_view = SCROLL_VIEW(widget);\n  children_layouter_list_view_t* l = (children_layouter_list_view_t*)layouter;\n  return_value_if_fail(widget != NULL && scroll_view != NULL && l != NULL, RET_BAD_PARAMS);\n\n  list_view = LIST_VIEW(widget->parent);\n  return_value_if_fail(list_view != NULL, RET_BAD_PARAMS);\n\n  item_height = list_view->item_height ? list_view->item_height : l->item_height;\n  default_item_height =\n      list_view->default_item_height ? list_view->default_item_height : l->default_item_height;\n\n  if (widget->children != NULL) {\n    int32_t scroll_view_w = 0;\n    darray_t children_for_layout;\n    uint32_t cols = l->cols <= 1 ? 1 : l->cols;\n\n    widget_layout_floating_children(widget);\n    darray_init(&children_for_layout, widget->children->size, NULL, NULL);\n\n    return_value_if_fail(\n        widget_get_children_for_layout(widget, &children_for_layout, l->keep_disable,\n                                       l->keep_invisible) == RET_OK,\n        RET_BAD_PARAMS);\n\n    children_layouter_list_view_for_list_view_children_layout_h(&children_for_layout, item_height,\n                                                                default_item_height);\n    virtual_h = children_layouter_list_view_for_list_view_get_virtual_h(&children_for_layout, cols,\n                                                                        l->y_margin, l->spacing);\n    scroll_view_w =\n        children_layouter_list_view_for_list_view_get_scroll_view_w(list_view, widget, virtual_h);\n\n    widget_resize(widget, scroll_view_w, widget->h);\n    children_layouter_list_view_for_list_view_children_layout_w(\n        &children_for_layout, cols, l->x_margin, l->y_margin, l->spacing, scroll_view_w);\n\n    darray_deinit(&(children_for_layout));\n  }\n\n  children_layouter_list_view_for_list_view_set_scroll_view_info(widget, list_view->scroll_bar,\n                                                                 virtual_h);\n  if (list_view->scroll_bar != NULL) {\n    children_layouter_list_view_for_list_view_set_scroll_bar_info(list_view->scroll_bar, list_view,\n                                                                  widget, virtual_h, item_height);\n  }\n  return RET_OK;\n}",
            "key_variables": [
               [
                  458,
                  "l->x_margin"
               ],
               [
                  459,
                  "l->y_margin"
               ],
               [
                  460,
                  "l->cols"
               ],
               [
                  463,
                  "l->spacing"
               ],
               [
                  481,
                  "children[i]"
               ]
            ]
         }
      ],
      "src/ext_widgets/scroll_view/list_item.c": [
         {
            "type": "func",
            "name": "list_item_remove_timer",
            "line_range": [
               60,
               70
            ],
            "source_code": "static ret_t list_item_remove_timer(widget_t* widget) {\n  list_item_t* list_item = LIST_ITEM(widget);\n  return_value_if_fail(list_item != NULL, RET_BAD_PARAMS);\n\n  if (list_item->timer_id != TK_INVALID_ID) {\n    timer_remove(list_item->timer_id);\n    list_item->timer_id = TK_INVALID_ID;\n  }\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  74,
                  "e->type"
               ],
               [
                  82,
                  "evt->x"
               ],
               [
                  83,
                  "evt->y"
               ]
            ]
         }
      ],
      "src/ext_widgets/scroll_view/list_view.c": [
         {
            "type": "func",
            "name": "list_view_get_prop",
            "line_range": [
               39,
               58
            ],
            "source_code": "static ret_t list_view_get_prop(widget_t* widget, const char* name, value_t* v) {\n  list_view_t* list_view = LIST_VIEW(widget);\n  return_value_if_fail(list_view != NULL && name != NULL && v != NULL, RET_BAD_PARAMS);\n\n  if (tk_str_eq(name, WIDGET_PROP_ITEM_HEIGHT)) {\n    value_set_int(v, list_view->item_height);\n    return RET_OK;\n  } else if (tk_str_eq(name, WIDGET_PROP_DEFAULT_ITEM_HEIGHT)) {\n    value_set_int(v, list_view->default_item_height);\n    return RET_OK;\n  } else if (tk_str_eq(name, WIDGET_PROP_AUTO_HIDE_SCROLL_BAR)) {\n    value_set_bool(v, list_view->auto_hide_scroll_bar);\n    return RET_OK;\n  } else if (tk_str_eq(name, LIST_VIEW_PROP_FLOATING_SCROLL_BAR)) {\n    value_set_bool(v, list_view->floating_scroll_bar);\n    return RET_OK;\n  }\n\n  return RET_NOT_FOUND;\n}",
            "key_variables": [
               [
                  62,
                  "list_view->scroll_bar"
               ]
            ]
         },
         {
            "type": "func",
            "name": "list_view_set_prop",
            "line_range": [
               70,
               88
            ],
            "source_code": "static ret_t list_view_set_prop(widget_t* widget, const char* name, const value_t* v) {\n  list_view_t* list_view = LIST_VIEW(widget);\n  return_value_if_fail(list_view != NULL && name != NULL && v != NULL, RET_BAD_PARAMS);\n\n  if (tk_str_eq(name, WIDGET_PROP_ITEM_HEIGHT)) {\n    list_view->item_height = value_int(v);\n    return RET_OK;\n  } else if (tk_str_eq(name, WIDGET_PROP_DEFAULT_ITEM_HEIGHT)) {\n    list_view->default_item_height = value_int(v);\n    return RET_OK;\n  } else if (tk_str_eq(name, WIDGET_PROP_AUTO_HIDE_SCROLL_BAR)) {\n    list_view->auto_hide_scroll_bar = value_bool(v);\n    return RET_OK;\n  } else if (tk_str_eq(name, LIST_VIEW_PROP_FLOATING_SCROLL_BAR)) {\n    return list_view_set_floating_scroll_bar(widget, value_bool(v));\n  }\n\n  return RET_NOT_FOUND;\n}",
            "key_variables": [
               [
                  93,
                  "evt->dy"
               ]
            ]
         },
         {
            "type": "func",
            "name": "list_view_on_event",
            "line_range": [
               150,
               196
            ],
            "source_code": "static ret_t list_view_on_event(widget_t* widget, event_t* e) {\n  ret_t ret = RET_OK;\n  list_view_t* list_view = LIST_VIEW(widget);\n  return_value_if_fail(list_view != NULL, RET_BAD_PARAMS);\n\n  switch (e->type) {\n    case EVT_WHEEL: {\n      ret = list_view_hanlde_wheel_event(list_view, e);\n      break;\n    }\n    case EVT_KEY_DOWN: {\n      key_event_t* evt = (key_event_t*)e;\n      if (evt->key == TK_KEY_PAGEDOWN) {\n        scroll_view_scroll_delta_to(list_view->scroll_view, 0, widget->h, TK_ANIMATING_TIME);\n        ret = RET_STOP;\n      } else if (evt->key == TK_KEY_PAGEUP) {\n        scroll_view_scroll_delta_to(list_view->scroll_view, 0, -widget->h, TK_ANIMATING_TIME);\n        ret = RET_STOP;\n      } else if (evt->key == TK_KEY_UP) {\n        uint32_t item_height = tk_max(list_view->item_height, list_view->default_item_height);\n        scroll_view_scroll_delta_to(list_view->scroll_view, 0, -item_height, TK_ANIMATING_TIME);\n        ret = RET_STOP;\n      } else if (evt->key == TK_KEY_DOWN) {\n        uint32_t item_height = tk_max(list_view->item_height, list_view->default_item_height);\n        scroll_view_scroll_delta_to(list_view->scroll_view, 0, item_height, TK_ANIMATING_TIME);\n        ret = RET_STOP;\n      }\n      break;\n    }\n    case EVT_POINTER_UP: {\n      pointer_event_t* evt = (pointer_event_t*)e;\n      list_view_on_pointer_up(list_view, evt);\n      break;\n    }\n    case EVT_POINTER_LEAVE: {\n      list_view_on_pointer_leave(list_view);\n      break;\n    }\n    case EVT_POINTER_ENTER: {\n      list_view_on_pointer_enter(list_view);\n      break;\n    }\n    default:\n      break;\n  }\n  return ret;\n}",
            "key_variables": [
               [
                  221,
                  "scroll_bar->virtual_size"
               ]
            ]
         },
         {
            "type": "func",
            "name": "scroll_bar_to_scroll_view",
            "line_range": [
               209,
               224
            ],
            "source_code": "static int32_t scroll_bar_to_scroll_view(list_view_t* list_view, int32_t v) {\n  int32_t range = 0;\n  float_t percent = 0;\n  scroll_view_t* scroll_view = NULL;\n  scroll_bar_t* scroll_bar = NULL;\n  return_value_if_fail(list_view != NULL, 0);\n\n  scroll_view = SCROLL_VIEW(list_view->scroll_view);\n  scroll_bar = SCROLL_BAR(list_view->scroll_bar);\n  return_value_if_fail(scroll_bar != NULL && scroll_view != NULL, 0);\n\n  range = scroll_bar->virtual_size;\n  percent = range > 0 ? (float_t)v / (float_t)(range) : 0;\n\n  return percent * (scroll_view->virtual_h - list_view->scroll_view->h);\n}",
            "key_variables": [
               [
                  251,
                  "scroll_view->h"
               ],
               [
                  254,
                  "scroll_bar->virtual_size"
               ]
            ]
         },
         {
            "type": "func",
            "name": "list_view_on_scroll_view_scroll_to",
            "line_range": [
               273,
               289
            ],
            "source_code": "static ret_t list_view_on_scroll_view_scroll_to(widget_t* widget, int32_t xoffset_end,\n                                                int32_t yoffset_end, int32_t duration) {\n  list_view_t* list_view = LIST_VIEW(widget->parent);\n  return_value_if_fail(widget != NULL && list_view != NULL, RET_BAD_PARAMS);\n\n  if (scroll_bar_is_mobile(list_view->scroll_bar)) {\n    int32_t value = scroll_view_to_scroll_bar(list_view, yoffset_end);\n\n    emitter_disable(list_view->scroll_bar->emitter);\n    scroll_bar_scroll_to(list_view->scroll_bar, value, duration);\n    emitter_enable(list_view->scroll_bar->emitter);\n\n    (void)xoffset_end;\n  }\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  317,
                  "iter->x"
               ],
               [
                  318,
                  "iter->y"
               ],
               [
                  319,
                  "iter->h"
               ],
               [
                  320,
                  "iter->w"
               ]
            ]
         },
         {
            "type": "func",
            "name": "list_view_on_scroll_view_paint_children",
            "line_range": [
               301,
               340
            ],
            "source_code": "static ret_t list_view_on_scroll_view_paint_children(widget_t* widget, canvas_t* c) {\n  int32_t left = 0;\n  int32_t top = 0;\n  int32_t bottom = 0;\n  int32_t right = 0;\n  int32_t max_w = canvas_get_width(c);\n  int32_t max_h = canvas_get_height(c);\n\n  WIDGET_FOR_EACH_CHILD_BEGIN(widget, iter, i)\n\n  if (!iter->visible) {\n    iter->dirty = FALSE;\n    continue;\n  }\n\n  left = c->ox + iter->x;\n  top = c->oy + iter->y;\n  bottom = top + iter->h;\n  right = left + iter->w;\n\n  if (top > max_h || left > max_w) {\n    break;\n  }\n\n  if (bottom < 0 || right < 0) {\n    iter->dirty = FALSE;\n    continue;\n  }\n\n  if (left > c->clip_right || right < c->clip_left || top > c->clip_bottom ||\n      bottom < c->clip_top) {\n    iter->dirty = FALSE;\n    continue;\n  }\n\n  widget_paint(iter, c);\n  WIDGET_FOR_EACH_CHILD_END();\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  349,
                  "list_view->scroll_view"
               ]
            ]
         }
      ],
      "src/ext_widgets/scroll_view/list_view_h.c": [
         {
            "type": "func",
            "name": "list_view_h_on_event",
            "line_range": [
               63,
               85
            ],
            "source_code": "static ret_t list_view_h_on_event(widget_t* widget, event_t* e) {\n  ret_t ret = RET_OK;\n  list_view_h_t* list_view = LIST_VIEW_H(widget);\n  return_value_if_fail(list_view != NULL, RET_BAD_PARAMS);\n\n  switch (e->type) {\n    case EVT_KEY_DOWN: {\n      key_event_t* evt = (key_event_t*)e;\n      if (evt->key == TK_KEY_PAGEDOWN) {\n        scroll_view_scroll_delta_to(list_view->scroll_view, widget->w, 0, TK_ANIMATING_TIME);\n        ret = RET_STOP;\n      } else if (evt->key == TK_KEY_PAGEUP) {\n        scroll_view_scroll_delta_to(list_view->scroll_view, -widget->w, 0, TK_ANIMATING_TIME);\n        ret = RET_STOP;\n      }\n      break;\n    }\n    default:\n      break;\n  }\n\n  return ret;\n}",
            "key_variables": [
               [
                  105,
                  "list_view_h->item_width"
               ],
               [
                  106,
                  "widget->h"
               ],
               [
                  110,
                  "widget->w"
               ],
               [
                  124,
                  "list_view_h->spacing"
               ],
               [
                  128,
                  "children->size"
               ]
            ]
         }
      ],
      "src/ext_widgets/scroll_view/scroll_bar.c": [
         {
            "type": "func",
            "name": "scroll_bar_mobile_get_dragger_size",
            "line_range": [
               51,
               92
            ],
            "source_code": "static ret_t scroll_bar_mobile_get_dragger_size(widget_t* widget, rect_t* r) {\n  int64_t x = 0;\n  int64_t y = 0;\n  int64_t w = 0;\n  int64_t h = 0;\n  int64_t virtual_size = 0;\n  int64_t value = 0;\n  int64_t widget_w = widget->w;\n  int64_t widget_h = widget->h;\n  scroll_bar_t* scroll_bar = SCROLL_BAR(widget);\n\n  if (scroll_bar->virtual_size <= 0) {\n    return RET_OK;\n  }\n\n  virtual_size = scroll_bar->virtual_size;\n  value = scroll_bar->value;\n  if (widget_w > widget_h) {\n    /*horizon*/\n    return_value_if_fail(virtual_size >= widget_w, RET_BAD_PARAMS);\n    y = 1;\n    h = widget_h - 2;\n    w = (widget_w * widget_w) / virtual_size;\n    w = tk_max(w, 4);\n    x = (widget_w - w) * value / virtual_size;\n  } else {\n    /*vertical*/\n    return_value_if_fail(virtual_size >= widget_h, RET_BAD_PARAMS);\n    x = 1;\n    w = widget_w - 2;\n    h = (widget_h * widget_h) / virtual_size;\n    h = tk_max(h, 4);\n    y = (widget_h - h) * value / virtual_size;\n  }\n\n  r->x = x;\n  r->y = y;\n  r->w = w;\n  r->h = h;\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  59,
                  "widget->w"
               ],
               [
                  60,
                  "widget->h"
               ],
               [
                  67,
                  "scroll_bar->virtual_size"
               ],
               [
                  68,
                  "scroll_bar->value"
               ]
            ]
         },
         {
            "type": "func",
            "name": "scroll_bar_mobile_on_paint_self",
            "line_range": [
               94,
               111
            ],
            "source_code": "static ret_t scroll_bar_mobile_on_paint_self(widget_t* widget, canvas_t* c) {\n  rect_t r = rect_init(0, 0, 0, 0);\n  style_t* style = widget->astyle;\n  color_t trans = color_init(80, 80, 80, 0xff);\n  color_t fg = style_get_color(style, STYLE_ID_FG_COLOR, trans);\n  uint32_t round_radius = style_get_int(style, STYLE_ID_ROUND_RADIUS, 0);\n  return_value_if_fail(scroll_bar_mobile_get_dragger_size(widget, &r) == RET_OK, RET_FAIL);\n\n  canvas_set_fill_color(c, fg);\n\n  if (round_radius > 0) {\n    canvas_fill_rounded_rect(c, &r, &r, &fg, round_radius);\n  } else {\n    canvas_fill_rect(c, r.x, r.y, r.w, r.h);\n  }\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  97,
                  "widget->astyle"
               ]
            ]
         },
         {
            "type": "func",
            "name": "scroll_bar_desktop_on_click",
            "line_range": [
               114,
               152
            ],
            "source_code": "static ret_t scroll_bar_desktop_on_click(widget_t* widget, pointer_event_t* e) {\n  int32_t delta = 0;\n  point_t p = {e->x, e->y};\n  scroll_bar_t* scroll_bar = SCROLL_BAR(widget);\n\n  if (widget->target != NULL) {\n    return RET_OK;\n  }\n\n  widget_to_local(widget, &p);\n  if (widget->w > widget->h) {\n    if (p.x < scroll_bar->dragger->x) {\n      delta = -widget->w;\n    } else {\n      delta = widget->w;\n    }\n    if (scroll_bar->dragger->x <= p.y && p.x <= (scroll_bar->dragger->x + scroll_bar->dragger->w)) {\n      return RET_OK;\n    }\n  } else {\n    if (p.y < scroll_bar->dragger->y) {\n      delta = -widget->h;\n    } else {\n      delta = widget->h;\n    }\n    if (scroll_bar->dragger->y <= p.y && p.y <= (scroll_bar->dragger->y + scroll_bar->dragger->h)) {\n      return RET_OK;\n    }\n  }\n\n  if (delta > 0) {\n    delta -= scroll_bar->row;\n  } else {\n    delta += scroll_bar->row;\n  }\n  scroll_bar_scroll_delta(widget, delta);\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  127,
                  "widget->w"
               ],
               [
                  129,
                  "widget->w"
               ],
               [
                  136,
                  "widget->h"
               ],
               [
                  138,
                  "widget->h"
               ],
               [
                  146,
                  "scroll_bar->row"
               ],
               [
                  148,
                  "scroll_bar->row"
               ],
               [
                  156,
                  "e->type"
               ],
               [
                  173,
                  "widget->h"
               ]
            ]
         },
         {
            "type": "func",
            "name": "scroll_bar_destop_get_dragger_size",
            "line_range": [
               199,
               255
            ],
            "source_code": "static ret_t scroll_bar_destop_get_dragger_size(widget_t* widget, rect_t* r) {\n  int64_t x = 0;\n  int64_t y = 0;\n  int64_t w = 0;\n  int64_t h = 0;\n  int64_t value = 0;\n  int64_t virtual_size = 0;\n  uint32_t button_margin = 0;\n  int64_t widget_w = widget->w;\n  int64_t widget_h = widget->h;\n  scroll_bar_t* scroll_bar = SCROLL_BAR(widget);\n  widget_t* up = widget_lookup(widget, CHILD_UP, FALSE);\n  widget_t* down = widget_lookup(widget, CHILD_DOWN, FALSE);\n\n  memset(r, 0x00, sizeof(rect_t));\n  if (scroll_bar->virtual_size <= 0) {\n    return RET_OK;\n  }\n\n  if (SCROLL_BAR_UP_AND_DOWN_BUTTON_STYLE_IS_EXIST(up, down)) {\n    if (widget_w > widget_h) {\n      button_margin = widget_h;\n    } else {\n      button_margin = widget_w;\n    }\n  }\n\n  value = scroll_bar->value;\n  if (widget_w > widget_h) {\n    int64_t max_bar_w = widget_w - 2 * button_margin;\n    /*horizon*/\n    virtual_size = tk_max(widget_w, scroll_bar->virtual_size);\n\n    y = 1;\n    h = widget_h - 2;\n    w = (widget_w * max_bar_w) / virtual_size;\n    w = tk_max(w, TK_DRAGGER_MIN_SIZE);\n    x = (widget_w - w - 2 * button_margin) * value / virtual_size + button_margin;\n  } else {\n    /*vertical*/\n    int64_t max_bar_h = widget_h - 2 * button_margin;\n    virtual_size = tk_max(widget_h, scroll_bar->virtual_size);\n\n    x = 1;\n    w = widget_w - 2;\n    h = (widget_h * max_bar_h) / virtual_size;\n    h = tk_max(h, TK_DRAGGER_MIN_SIZE);\n    y = (widget_h - h - 2 * button_margin) * value / virtual_size + button_margin;\n  }\n\n  r->x = x;\n  r->y = y;\n  r->w = w;\n  r->h = h;\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  208,
                  "widget->w"
               ],
               [
                  209,
                  "widget->h"
               ],
               [
                  227,
                  "scroll_bar->value"
               ]
            ]
         },
         {
            "type": "func",
            "name": "scroll_bar_on_down_button_clicked",
            "line_range": [
               301,
               303
            ],
            "source_code": "static ret_t scroll_bar_on_down_button_clicked(void* ctx, event_t* e) {\n  return scroll_bar_scroll_delta(WIDGET(ctx), SCROLL_BAR(ctx)->row);\n}",
            "key_variables": [
               [
                  310,
                  "widget->w"
               ],
               [
                  311,
                  "widget->h"
               ],
               [
                  313,
                  "scroll_bar->dragger"
               ],
               [
                  326,
                  "dragger->x"
               ],
               [
                  334,
                  "dragger->y"
               ],
               [
                  351,
                  "widget->w"
               ],
               [
                  352,
                  "widget->h"
               ],
               [
                  355,
                  "scroll_bar->dragger"
               ]
            ]
         },
         {
            "type": "func",
            "name": "scroll_bar_update_dragger",
            "line_range": [
               620,
               631
            ],
            "source_code": "static ret_t scroll_bar_update_dragger(widget_t* widget) {\n  scroll_bar_t* scroll_bar = SCROLL_BAR(widget);\n  return_value_if_fail(scroll_bar != NULL, RET_BAD_PARAMS);\n\n  if (!scroll_bar_is_mobile(widget)) {\n    rect_t r = rect_init(0, 0, 0, 0);\n    return_value_if_fail(scroll_bar_destop_get_dragger_size(widget, &r) == RET_OK, RET_FAIL);\n    widget_move_resize(scroll_bar->dragger, r.x, r.y, r.w, r.h);\n  }\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  666,
                  "scroll_bar->virtual_size"
               ]
            ]
         }
      ],
      "src/ext_widgets/scroll_view/scroll_view.c": [
         {
            "type": "func",
            "name": "scroll_view_update_virtual_size",
            "line_range": [
               52,
               85
            ],
            "source_code": "static ret_t scroll_view_update_virtual_size(widget_t* widget) {\n  int32_t virtual_w = 0;\n  int32_t virtual_h = 0;\n  scroll_view_t* scroll_view = SCROLL_VIEW(widget);\n  return_value_if_fail(scroll_view != NULL && widget != NULL, RET_BAD_PARAMS);\n\n  virtual_w = tk_max(scroll_view->virtual_w, widget->w);\n  virtual_h = tk_max(scroll_view->virtual_h, widget->h);\n\n  WIDGET_FOR_EACH_CHILD_BEGIN(widget, iter, i)\n  int32_t r = 0;\n  int32_t b = 0;\n  if (scroll_view->recursive) {\n    rect_t rect = rect_init(0, 0, iter->w, iter->h);\n    scroll_view_get_item_rect(iter, iter, &rect);\n    r = iter->x + rect.x + rect.w;\n    b = iter->y + rect.y + rect.h;\n  } else {\n    r = iter->x + iter->w;\n    b = iter->y + iter->h;\n  }\n  if (r > virtual_w) {\n    virtual_w = r;\n  }\n  if (b > virtual_h) {\n    virtual_h = b;\n  }\n  WIDGET_FOR_EACH_CHILD_END();\n\n  scroll_view->virtual_w = virtual_w;\n  scroll_view->virtual_h = virtual_h;\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  71,
                  "iter->w"
               ],
               [
                  72,
                  "iter->h"
               ]
            ]
         },
         {
            "type": "func",
            "name": "scroll_view_on_layout_children",
            "line_range": [
               87,
               116
            ],
            "source_code": "static ret_t scroll_view_on_layout_children(widget_t* widget) {\n  scroll_view_t* scroll_view = SCROLL_VIEW(widget);\n  return_value_if_fail(widget != NULL && scroll_view != NULL, RET_BAD_PARAMS);\n\n  if (scroll_view->on_layout_children) {\n    scroll_view->on_layout_children(widget);\n  } else {\n    widget_layout_children_default(widget);\n    scroll_view_update_virtual_size(widget);\n    scroll_view_set_offset(widget,\n                           tk_min(scroll_view->xoffset, (scroll_view->virtual_w - widget->w)),\n                           tk_min(scroll_view->yoffset, (scroll_view->virtual_h - widget->h)));\n  }\n  if (scroll_view->snap_to_page) {\n    int32_t curr_page = scroll_view_get_curr_page(widget);\n    uint32_t max_page = scroll_view_get_page_max_number(widget);\n    scroll_view->xoffset_end = scroll_view->xoffset;\n    scroll_view->yoffset_end = scroll_view->yoffset;\n    scroll_view->fix_end_offset(widget);\n    scroll_view->xoffset = scroll_view->xoffset_end;\n    scroll_view->yoffset = scroll_view->yoffset_end;\n    if (scroll_view->curr_page != curr_page || scroll_view->max_page != max_page) {\n      scroll_view->max_page = max_page;\n      scroll_view->curr_page = curr_page;\n      widget_dispatch_simple_event(widget, EVT_PAGE_CHANGED);\n    }\n  }\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  104,
                  "scroll_view->xoffset"
               ],
               [
                  105,
                  "scroll_view->yoffset"
               ],
               [
                  107,
                  "scroll_view->xoffset_end"
               ],
               [
                  108,
                  "scroll_view->yoffset_end"
               ],
               [
                  123,
                  "e->x"
               ],
               [
                  124,
                  "e->y"
               ],
               [
                  125,
                  "scroll_view->xoffset"
               ],
               [
                  126,
                  "scroll_view->yoffset"
               ],
               [
                  127,
                  "scroll_view->xoffset"
               ],
               [
                  128,
                  "scroll_view->yoffset"
               ]
            ]
         },
         {
            "type": "func",
            "name": "scroll_view_on_scroll_done",
            "line_range": [
               134,
               146
            ],
            "source_code": "static ret_t scroll_view_on_scroll_done(void* ctx, event_t* e) {\n  widget_t* widget = WIDGET(ctx);\n  scroll_view_t* scroll_view = SCROLL_VIEW(ctx);\n  return_value_if_fail(widget != NULL && scroll_view != NULL, RET_BAD_PARAMS);\n\n  scroll_view->wa = NULL;\n  scroll_view->curr_page = scroll_view_get_curr_page(widget);\n  widget_invalidate_force(widget, NULL);\n  widget_dispatch_simple_event(widget, EVT_SCROLL_END);\n  widget_dispatch_simple_event(widget, EVT_PAGE_CHANGED);\n\n  return RET_REMOVE;\n}",
            "key_variables": [
               [
                  155,
                  "scroll_view->xoffset_end"
               ],
               [
                  156,
                  "scroll_view->yoffset_end"
               ]
            ]
         },
         {
            "type": "func",
            "name": "scroll_view_fix_end_offset_default",
            "line_range": [
               148,
               174
            ],
            "source_code": "static ret_t scroll_view_fix_end_offset_default(widget_t* widget) {\n  int32_t xoffset_end = 0;\n  int32_t yoffset_end = 0;\n  scroll_view_t* scroll_view = SCROLL_VIEW(widget);\n  return_value_if_fail(widget != NULL && scroll_view != NULL, RET_BAD_PARAMS);\n\n  xoffset_end = scroll_view->xoffset_end;\n  yoffset_end = scroll_view->yoffset_end;\n\n  xoffset_end = tk_max(xoffset_end, 0);\n  yoffset_end = tk_max(yoffset_end, 0);\n  xoffset_end = tk_min(xoffset_end, (scroll_view->virtual_w - widget->w));\n  yoffset_end = tk_min(yoffset_end, (scroll_view->virtual_h - widget->h));\n\n  if (scroll_view->virtual_w <= widget->w) {\n    xoffset_end = 0;\n  }\n\n  if (scroll_view->virtual_h <= widget->h) {\n    yoffset_end = 0;\n  }\n\n  scroll_view->xoffset_end = xoffset_end;\n  scroll_view->yoffset_end = yoffset_end;\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  182,
                  "widget->w"
               ],
               [
                  184,
                  "widget->h"
               ]
            ]
         },
         {
            "type": "func",
            "name": "scroll_view_get_snap_to_page_offset_value",
            "line_range": [
               176,
               197
            ],
            "source_code": "static int32_t scroll_view_get_snap_to_page_offset_value(widget_t* widget, int32_t offset_end) {\n  uint32_t tmp = 0;\n  scroll_view_t* scroll_view = SCROLL_VIEW(widget);\n  return_value_if_fail(scroll_view != NULL, offset_end);\n  if (scroll_view->xslidable && !scroll_view->yslidable) {\n    tmp = widget->w;\n  } else if (!scroll_view->xslidable && scroll_view->yslidable) {\n    tmp = widget->h;\n  }\n  if (tmp != 0) {\n    int32_t n = (int32_t)((offset_end + tmp * 0.5f) / tmp);\n    if (scroll_view->move_to_page) {\n      if (scroll_view->curr_page - n > 1) {\n        n = scroll_view->curr_page - 1;\n      } else if (n - scroll_view->curr_page > 1) {\n        n = scroll_view->curr_page + 1;\n      }\n    }\n    offset_end = n * tmp;\n  }\n  return offset_end;\n}",
            "key_variables": [
               [
                  216,
                  "scroll_view->xoffset_end"
               ],
               [
                  217,
                  "scroll_view->yoffset_end"
               ],
               [
                  224,
                  "scroll_view->xoffset"
               ],
               [
                  225,
                  "scroll_view->yoffset"
               ],
               [
                  233,
                  "scroll_view->wa"
               ],
               [
                  239,
                  "scroll_view->xoffset"
               ],
               [
                  250,
                  "scroll_view->yoffset"
               ]
            ]
         },
         {
            "type": "func",
            "name": "scroll_view_on_pointer_down_abort",
            "line_range": [
               286,
               296
            ],
            "source_code": "static ret_t scroll_view_on_pointer_down_abort(scroll_view_t* scroll_view, pointer_event_t* e) {\n  widget_t* widget = WIDGET(scroll_view);\n  (void)e;\n\n  if (scroll_view->xslidable || scroll_view->yslidable) {\n    scroll_view_scroll_to(widget, scroll_view->xoffset_end, scroll_view->yoffset_end,\n                          TK_ANIMATING_TIME);\n  }\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  308,
                  "v->yv"
               ],
               [
                  309,
                  "v->xv"
               ],
               [
                  315,
                  "scroll_view->wa"
               ],
               [
                  316,
                  "scroll_view->xoffset"
               ],
               [
                  317,
                  "scroll_view->yoffset"
               ],
               [
                  325,
                  "scroll_view->xspeed_scale"
               ],
               [
                  327,
                  "scroll_view->xspeed_scale"
               ],
               [
                  333,
                  "scroll_view->yspeed_scale"
               ],
               [
                  335,
                  "scroll_view->yspeed_scale"
               ]
            ]
         },
         {
            "type": "func",
            "name": "scroll_view_is_dragged",
            "line_range": [
               382,
               397
            ],
            "source_code": "static bool_t scroll_view_is_dragged(widget_t* widget, pointer_event_t* evt) {\n  int32_t delta = 0;\n  scroll_view_t* scroll_view = SCROLL_VIEW(widget);\n  return_value_if_fail(scroll_view != NULL, FALSE);\n  if (scroll_view->xslidable && scroll_view->yslidable) {\n    int32_t xdelta = evt->x - scroll_view->down.x;\n    int32_t ydelta = evt->y - scroll_view->down.y;\n    delta = tk_abs(xdelta) > tk_abs(ydelta) ? xdelta : ydelta;\n  } else if (scroll_view->yslidable) {\n    delta = evt->y - scroll_view->down.y;\n  } else {\n    delta = evt->x - scroll_view->down.x;\n  }\n\n  return scroll_view->snap_to_page || (tk_abs(delta) >= TK_DRAG_THRESHOLD);\n}",
            "key_variables": [
               [
                  402,
                  "e->type"
               ],
               [
                  471,
                  "scroll_view->xoffset"
               ],
               [
                  472,
                  "scroll_view->yoffset"
               ]
            ]
         },
         {
            "type": "func",
            "name": "scroll_view_get_page_max_number",
            "line_range": [
               523,
               532
            ],
            "source_code": "static uint32_t scroll_view_get_page_max_number(widget_t* widget) {\n  scroll_view_t* scroll_view = SCROLL_VIEW(widget);\n  return_value_if_fail(widget != NULL && scroll_view != NULL, 0);\n  if (scroll_view->xslidable && !scroll_view->yslidable) {\n    return scroll_view->virtual_w / widget->w;\n  } else if (!scroll_view->xslidable && scroll_view->yslidable) {\n    return scroll_view->virtual_h / widget->h;\n  }\n  return 0;\n}",
            "key_variables": [
               [
                  528,
                  "widget->w"
               ],
               [
                  530,
                  "widget->h"
               ],
               [
                  539,
                  "widget->w"
               ],
               [
                  541,
                  "widget->h"
               ]
            ]
         },
         {
            "type": "func",
            "name": "scroll_view_get_curr_page",
            "line_range": [
               534,
               543
            ],
            "source_code": "static uint32_t scroll_view_get_curr_page(widget_t* widget) {\n  scroll_view_t* scroll_view = SCROLL_VIEW(widget);\n  return_value_if_fail(widget != NULL && scroll_view != NULL, 0);\n  if (scroll_view->xslidable && !scroll_view->yslidable) {\n    return scroll_view->xoffset / widget->w;\n  } else if (!scroll_view->xslidable && scroll_view->yslidable) {\n    return scroll_view->yoffset / widget->h;\n  }\n  return 0;\n}",
            "key_variables": [
               [
                  551,
                  "widget->w"
               ],
               [
                  553,
                  "widget->h"
               ]
            ]
         },
         {
            "type": "func",
            "name": "scroll_view_set_prop",
            "line_range": [
               612,
               655
            ],
            "source_code": "static ret_t scroll_view_set_prop(widget_t* widget, const char* name, const value_t* v) {\n  scroll_view_t* scroll_view = SCROLL_VIEW(widget);\n  return_value_if_fail(scroll_view != NULL && name != NULL && v != NULL, RET_BAD_PARAMS);\n\n  if (tk_str_eq(name, WIDGET_PROP_VIRTUAL_W)) {\n    scroll_view->virtual_w = value_int(v);\n    return RET_OK;\n  } else if (tk_str_eq(name, WIDGET_PROP_VIRTUAL_H)) {\n    scroll_view->virtual_h = value_int(v);\n    return RET_OK;\n  } else if (tk_str_eq(name, WIDGET_PROP_XSLIDABLE)) {\n    scroll_view->xslidable = value_bool(v);\n    return RET_OK;\n  } else if (tk_str_eq(name, WIDGET_PROP_YSLIDABLE)) {\n    scroll_view->yslidable = value_bool(v);\n    return RET_OK;\n  } else if (tk_str_eq(name, WIDGET_PROP_XOFFSET)) {\n    scroll_view->xoffset = value_int(v);\n    scroll_view_notify_scrolled(scroll_view);\n    widget_invalidate_force(widget, NULL);\n    return RET_OK;\n  } else if (tk_str_eq(name, WIDGET_PROP_YOFFSET)) {\n    scroll_view->yoffset = value_int(v);\n    scroll_view_notify_scrolled(scroll_view);\n    widget_invalidate_force(widget, NULL);\n    return RET_OK;\n  } else if (tk_str_eq(name, SCROLL_VIEW_X_SPEED_SCALE)) {\n    scroll_view->xspeed_scale = value_float(v);\n    return RET_OK;\n  } else if (tk_str_eq(name, SCROLL_VIEW_Y_SPEED_SCALE)) {\n    scroll_view->yspeed_scale = value_float(v);\n    return RET_OK;\n  } else if (tk_str_eq(name, SCROLL_VIEW_RECURSIVE)) {\n    return scroll_view_set_recursive(widget, value_bool(v));\n  } else if (tk_str_eq(name, SCROLL_VIEW_MOVE_TO_PAGE)) {\n    return scroll_view_set_move_to_page(widget, value_bool(v));\n  } else if (tk_str_eq(name, SCROLL_VIEW_SNAP_TO_PAGE)) {\n    return scroll_view_set_snap_to_page(widget, value_bool(v));\n  } else if (scroll_view->snap_to_page && tk_str_eq(name, WIDGET_PROP_CURR_PAGE)) {\n    return scroll_view_set_curr_page(widget, value_int(v));\n  }\n\n  return RET_NOT_FOUND;\n}",
            "key_variables": [
               [
                  661,
                  "scroll_view->xoffset"
               ],
               [
                  662,
                  "scroll_view->yoffset"
               ]
            ]
         }
      ],
      "src/ext_widgets/slide_menu/slide_menu.c": [
         {
            "type": "block",
            "name": "block",
            "line_range": "",
            "source_code": "",
            "key_variables": [
               63,
               "children[slide_menu_fix_index(widget, index)]"
            ]
         },
         {
            "type": "func",
            "name": "slide_menu_set_xoffset",
            "line_range": [
               70,
               86
            ],
            "source_code": "static ret_t slide_menu_set_xoffset(slide_menu_t* slide_menu, int32_t xoffset) {\n\n  if (slide_menu->xoffset != xoffset) {\n\n    slide_menu->xoffset = xoffset;\n\n    widget_layout_children(WIDGET(slide_menu));\n\n    widget_invalidate(WIDGET(slide_menu), NULL);\n\n  }\n\n\n\n  return RET_OK;\n\n}",
            "key_variables": [
               [
                  77,
                  "widget->grab_widget"
               ],
               [
                  84,
                  "current->w"
               ],
               [
                  85,
                  "current->h"
               ]
            ]
         },
         {
            "type": "func",
            "name": "slide_menu_fix_index",
            "line_range": [
               90,
               106
            ],
            "source_code": "int32_t slide_menu_fix_index(widget_t* widget, int32_t index) {\n\n  uint32_t nr = widget_count_children(widget);\n\n\n\n  while (index < 0) {\n\n    index += nr;\n\n  }\n\n\n\n  return (index % nr);\n\n}",
            "key_variables": [
               [
                  110,
                  "widget->h"
               ],
               [
                  120,
                  "slide_menu->min_scale"
               ]
            ]
         },
         {
            "type": "func",
            "name": "slide_menu_set_xoffset",
            "line_range": [
               70,
               86
            ],
            "source_code": "static ret_t slide_menu_set_xoffset(slide_menu_t* slide_menu, int32_t xoffset) {\n\n  if (slide_menu->xoffset != xoffset) {\n\n    slide_menu->xoffset = xoffset;\n\n    widget_layout_children(WIDGET(slide_menu));\n\n    widget_invalidate(WIDGET(slide_menu), NULL);\n\n  }\n\n\n\n  return RET_OK;\n\n}",
            "key_variables": [
               [
                  128,
                  "iter->x"
               ],
               [
                  129,
                  "iter->w"
               ]
            ]
         },
         {
            "type": "func",
            "name": "slide_menu_find_target",
            "line_range": [
               130,
               186
            ],
            "source_code": "static widget_t* slide_menu_find_target(widget_t* widget, xy_t x, xy_t y) {\n\n  widget_t* current = NULL;\n\n  int32_t r = 0;\n\n  int32_t b = 0;\n\n  int32_t xx = 0;\n\n  int32_t yy = 0;\n\n  point_t p = {x, y};\n\n  slide_menu_t* slide_menu = SLIDE_MENU(widget);\n\n  return_value_if_fail(widget != NULL && slide_menu != NULL, NULL);\n\n\n\n  if (widget->grab_widget != NULL) {\n\n    return widget->grab_widget;\n\n  }\n\n\n\n  widget_to_local(widget, &p);\n\n  current = slide_menu_get_child(widget, slide_menu->value);\n\n  return_value_if_fail(current != NULL, NULL);\n\n\n\n  r = current->x + current->w;\n\n  b = current->y + current->h;\n\n  xx = p.x;\n\n  yy = p.y;\n\n\n\n  if (current->enable && xx >= current->x && yy >= current->y && xx <= r && yy <= b) {\n\n    return current;\n\n  }\n\n\n\n  return NULL;\n\n}",
            "key_variables": [
               [
                  147,
                  "widget->astyle"
               ],
               [
                  184,
                  "c->ox"
               ],
               [
                  185,
                  "c->oy"
               ]
            ]
         },
         {
            "type": "func",
            "name": "slide_menu_get_visible_nr",
            "line_range": [
               190,
               208
            ],
            "source_code": "static int32_t slide_menu_get_visible_nr(widget_t* widget) {\n\n  if (widget->w == 0 || widget->h == 0) return 0;\n\n  slide_menu_t* slide_menu = SLIDE_MENU(widget);\n\n  int32_t n = (widget->w - widget->h) / (slide_menu->min_scale * widget->h) + 1;\n\n\n\n  n = tk_min(n, MAX_VISIBLE_NR);\n\n  n = tk_min(n, widget_count_children(widget));\n\n\n\n  return n > 0 ? n : 0;\n\n}",
            "key_variables": [
               [
                  223,
                  "widget->h"
               ],
               [
                  272,
                  "children[i]"
               ]
            ]
         },
         {
            "type": "func",
            "name": "slide_menu_paint_mask",
            "line_range": [
               282,
               348
            ],
            "source_code": "static ret_t slide_menu_paint_mask(widget_t* widget, canvas_t* c, rect_t* r) {\n\n  int32_t i = 0;\n\n  int32_t x = 0;\n\n  int32_t n = r->w / 2 + 2;\n\n  int32_t cx = widget->w / 2;\n\n  style_t* style = widget->astyle;\n\n  color_t trans = color_init(0, 0, 0, 0);\n\n  easing_func_t easing = easing_get(EASING_LINEAR);\n\n  color_t mask_color = style_get_color(style, STYLE_ID_MASK_COLOR, trans);\n\n\n\n  if (mask_color.rgba.a) {\n\n    for (i = 0; i < n; i++) {\n\n      x = cx - i;\n\n\n\n      if (x >= 0) {\n\n        mask_color.rgba.a = 0xff * easing((float_t)i / (float_t)n);\n\n        canvas_set_stroke_color(c, mask_color);\n\n        canvas_draw_vline(c, x, 0, widget->h);\n\n      }\n\n    }\n\n\n\n    for (i = 0; i < n; i++) {\n\n      x = cx + i;\n\n\n\n      if (x < widget->w) {\n\n        mask_color.rgba.a = 0xff * easing((float_t)i / (float_t)n);\n\n        canvas_set_stroke_color(c, mask_color);\n\n        canvas_draw_vline(c, x, 0, widget->h);\n\n      }\n\n    }\n\n  }\n\n\n\n  return RET_OK;\n\n}",
            "key_variables": [
               [
                  286,
                  "slide_menu->min_scale"
               ],
               [
                  325,
                  "widget->h"
               ],
               [
                  327,
                  "children[MAX_VISIBLE_NR]"
               ],
               [
                  336,
                  "children[curr]"
               ],
               [
                  345,
                  "children[i]"
               ],
               [
                  357,
                  "children[i]"
               ]
            ]
         },
         {
            "type": "func",
            "name": "slide_menu_on_paint_children",
            "line_range": [
               352,
               418
            ],
            "source_code": "static ret_t slide_menu_on_paint_children(widget_t* widget, canvas_t* c) {\n\n  if (slide_menu_get_visible_nr(widget) >= 1) {\n\n    rect_t r;\n\n    rect_t save_r;\n\n    rect_t clip_r = slide_menu_get_clip_r(widget);\n\n    vgcanvas_t* vg = canvas_get_vgcanvas(c);\n\n\n\n    clip_r.x += c->ox;\n\n    clip_r.y += c->oy;\n\n    canvas_get_clip_rect(c, &save_r);\n\n    r = rect_intersect(&save_r, &clip_r);\n\n\n\n    canvas_save(c);\n\n    if (vg != NULL) {\n\n      vgcanvas_save(vg);\n\n      vgcanvas_clip_rect(vg, (float_t)r.x, (float_t)r.y, (float_t)r.w, (float_t)r.h);\n\n    }\n\n\n\n    canvas_set_clip_rect(c, &r);\n\n    slide_menu_paint_children(widget, c);\n\n    canvas_set_clip_rect(c, &save_r);\n\n\n\n    if (vg != NULL) {\n\n      vgcanvas_clip_rect(vg, (float_t)save_r.x, (float_t)save_r.y, (float_t)save_r.w,\n\n                         (float_t)save_r.h);\n\n      vgcanvas_restore(vg);\n\n    }\n\n    canvas_restore(c);\n\n\n\n    slide_menu_paint_mask(widget, c, &clip_r);\n\n  }\n\n\n\n  return RET_OK;\n\n}",
            "key_variables": [
               [
                  437,
                  "e->x"
               ],
               [
                  497,
                  "slide_menu->xoffset"
               ],
               [
                  535,
                  "slide_menu->min_scale"
               ],
               [
                  542,
                  "widget->h"
               ],
               [
                  547,
                  "widget->h"
               ],
               [
                  558,
                  "v->xv"
               ]
            ]
         },
         {
            "type": "func",
            "name": "slide_menu_paint_mask",
            "line_range": [
               282,
               348
            ],
            "source_code": "static ret_t slide_menu_paint_mask(widget_t* widget, canvas_t* c, rect_t* r) {\n\n  int32_t i = 0;\n\n  int32_t x = 0;\n\n  int32_t n = r->w / 2 + 2;\n\n  int32_t cx = widget->w / 2;\n\n  style_t* style = widget->astyle;\n\n  color_t trans = color_init(0, 0, 0, 0);\n\n  easing_func_t easing = easing_get(EASING_LINEAR);\n\n  color_t mask_color = style_get_color(style, STYLE_ID_MASK_COLOR, trans);\n\n\n\n  if (mask_color.rgba.a) {\n\n    for (i = 0; i < n; i++) {\n\n      x = cx - i;\n\n\n\n      if (x >= 0) {\n\n        mask_color.rgba.a = 0xff * easing((float_t)i / (float_t)n);\n\n        canvas_set_stroke_color(c, mask_color);\n\n        canvas_draw_vline(c, x, 0, widget->h);\n\n      }\n\n    }\n\n\n\n    for (i = 0; i < n; i++) {\n\n      x = cx + i;\n\n\n\n      if (x < widget->w) {\n\n        mask_color.rgba.a = 0xff * easing((float_t)i / (float_t)n);\n\n        canvas_set_stroke_color(c, mask_color);\n\n        canvas_draw_vline(c, x, 0, widget->h);\n\n      }\n\n    }\n\n  }\n\n\n\n  return RET_OK;\n\n}",
            "key_variables": [
               [
                  559,
                  "widget->h"
               ]
            ]
         },
         {
            "type": "func",
            "name": "slide_menu_get_visible_children",
            "line_range": [
               436,
               558
            ],
            "source_code": "static uint32_t slide_menu_get_visible_children(widget_t* widget,\n\n                                                widget_t* children[MAX_VISIBLE_NR]) {\n\n  int32_t i = 0;\n\n  int32_t curr = 0;\n\n  int32_t max_size = widget->h;\n\n  uint32_t nr = widget_count_children(widget);\n\n  slide_menu_t* slide_menu = SLIDE_MENU(widget);\n\n  rect_t clip_rect = slide_menu_get_clip_r(widget);\n\n  int32_t delta_index = slide_menu_get_delta_index(widget);\n\n  int32_t index = slide_menu_fix_index(widget, slide_menu->value - delta_index);\n\n  int32_t rounded_xoffset = delta_index * max_size;\n\n  int32_t xoffset = slide_menu->xoffset - rounded_xoffset;\n\n\n\n  for (i = 0; i < MAX_VISIBLE_NR; i++) {\n\n    children[i] = NULL;\n\n  }\n\n\n\n  for (i = 0; i < nr; i++) {\n\n    widget_get_child(widget, i)->visible = FALSE;\n\n  }\n\n\n\n  nr = slide_menu_get_visible_nr(widget);\n\n  if (nr == 0) return 0;\n\n\n\n  if (xoffset >= 0) {\n\n    curr = MAX_VISIBLE_NR / 2;\n\n  } else {\n\n    curr = MAX_VISIBLE_NR / 2 - 1;\n\n  }\n\n\n\n  children[curr] = slide_menu_get_child(widget, index);\n\n  for (i = 1; i <= (nr - 1) / 2; i++) {\n\n    children[curr - i] = slide_menu_get_child(widget, index - i);\n\n    children[curr + i] = slide_menu_get_child(widget, index + i);\n\n  }\n\n\n\n  if (nr % 2 == 0) {\n\n    if (xoffset >= 0) {\n\n      children[curr - i] = slide_menu_get_child(widget, index - i);\n\n    } else {\n\n      children[curr + i] = slide_menu_get_child(widget, index + i);\n\n    }\n\n  }\n\n  /* 保持边缘的 iter 不会突然消失 */\n\n  if (children[curr - i + 1]->x > clip_rect.x && curr - i >= 0 && nr < widget->children->size) {\n\n    children[curr - i] = slide_menu_get_child(widget, index - i);\n\n  }\n\n  if (children[curr + i - 1]->x + children[curr + i - 1]->w < clip_rect.x + clip_rect.w &&\n\n      curr + i < MAX_VISIBLE_NR && nr < widget->children->size) {\n\n    children[curr + i] = slide_menu_get_child(widget, index + i);\n\n  }\n\n\n\n  for (i = 0; i < MAX_VISIBLE_NR; i++) {\n\n    widget_t* iter = children[i];\n\n    if (iter != NULL) {\n\n      iter->visible = TRUE;\n\n      /*log_debug(\"nr=%d %d %s\\n\", nr, i, iter->name);*/\n\n    }\n\n  }\n\n\n\n  return curr;\n\n}",
            "key_variables": [
               [
                  569,
                  "e->type"
               ],
               [
                  609,
                  "slide_menu->xdown"
               ]
            ]
         }
      ],
      "src/ext_widgets/slide_view/slide_indicator.c": [
         {
            "type": "func",
            "name": "slide_indicator_set_anchor_x",
            "line_range": [
               56,
               69
            ],
            "source_code": "ret_t slide_indicator_set_anchor_x(widget_t* widget, const char* anchor) {\n  float_t val = 0.0f;\n  slide_indicator_t* slide_indicator = SLIDE_INDICATOR(widget);\n  return_value_if_fail(slide_indicator != NULL && anchor != NULL, RET_BAD_PARAMS);\n\n  val = tk_atof(anchor);\n  if (strrchr(anchor, '%')) {\n    val = val * widget->w;\n  }\n  slide_indicator->anchor_x = val;\n  slide_indicator->anchor_x_fixed = TRUE;\n  slide_indicator->reset_icon_rect_list = TRUE;\n  return RET_OK;\n}",
            "key_variables": [
               [
                  64,
                  "widget->w"
               ]
            ]
         },
         {
            "type": "func",
            "name": "slide_indicator_set_anchor_y",
            "line_range": [
               71,
               84
            ],
            "source_code": "ret_t slide_indicator_set_anchor_y(widget_t* widget, const char* anchor) {\n  float_t val = 0.0f;\n  slide_indicator_t* slide_indicator = SLIDE_INDICATOR(widget);\n  return_value_if_fail(slide_indicator != NULL && anchor != NULL, RET_BAD_PARAMS);\n\n  val = tk_atof(anchor);\n  if (strrchr(anchor, '%')) {\n    val = val * widget->h;\n  }\n  slide_indicator->anchor_y = val;\n  slide_indicator->anchor_y_fixed = TRUE;\n  slide_indicator->reset_icon_rect_list = TRUE;\n  return RET_OK;\n}",
            "key_variables": [
               [
                  79,
                  "widget->h"
               ]
            ]
         },
         {
            "type": "func",
            "name": "slide_indicator_fix_anchor",
            "line_range": [
               162,
               181
            ],
            "source_code": "static ret_t slide_indicator_fix_anchor(widget_t* widget) {\n  slide_indicator_t* slide_indicator = SLIDE_INDICATOR(widget);\n  return_value_if_fail(slide_indicator != NULL, RET_BAD_PARAMS);\n\n  if (!slide_indicator->anchor_x_fixed || !slide_indicator->anchor_y_fixed) {\n    point_t p = {0, 0};\n    widget_t* target = slide_indicator->indicated_widget;\n    return_value_if_fail(target != NULL, RET_BAD_PARAMS);\n\n    widget_to_screen(target, &p);\n    p.x += target->w / 2;\n    p.y += target->h / 2;\n    widget_to_local(widget, &p);\n\n    slide_indicator->anchor_x = slide_indicator->anchor_x_fixed ? slide_indicator->anchor_x : p.x;\n    slide_indicator->anchor_y = slide_indicator->anchor_y_fixed ? slide_indicator->anchor_y : p.y;\n  }\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  169,
                  "slide_indicator->indicated_widget"
               ],
               [
                  188,
                  "widget->parent"
               ]
            ]
         },
         {
            "type": "func",
            "name": "slide_indicator_default_paint_active_indicator",
            "line_range": [
               284,
               299
            ],
            "source_code": "static ret_t slide_indicator_default_paint_active_indicator(widget_t* widget, canvas_t* c,\n                                                            rect_t* r, color_t color) {\n  slide_indicator_t* slide_indicator = SLIDE_INDICATOR(widget);\n  return_value_if_fail(slide_indicator != NULL, RET_BAD_PARAMS);\n\n  switch (slide_indicator->default_paint) {\n    case INDICATOR_DEFAULT_PAINT_STROKE_RECT:\n    case INDICATOR_DEFAULT_PAINT_FILL_RECT:\n      slide_indicator_fill_rect(c, r, color);\n      break;\n    default:\n      slide_indicator_fill_dot(c, r, color);\n  }\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  303,
                  "widget->astyle"
               ],
               [
                  335,
                  "slide_indicator->max"
               ],
               [
                  336,
                  "slide_indicator->size"
               ],
               [
                  337,
                  "slide_indicator->anchor_x"
               ],
               [
                  338,
                  "slide_indicator->anchor_y"
               ],
               [
                  339,
                  "slide_indicator->margin"
               ],
               [
                  372,
                  "icon_rect_list->size"
               ]
            ]
         },
         {
            "type": "func",
            "name": "slide_indicator_paint_one",
            "line_range": [
               301,
               322
            ],
            "source_code": "static ret_t slide_indicator_paint_one(widget_t* widget, canvas_t* c, rect_t* r, bool_t active) {\n  style_t* style = widget->astyle;\n  color_t trans = color_init(0, 0, 0, 0);\n  color_t color =\n      style_get_color(style, active ? STYLE_ID_SELECTED_FG_COLOR : STYLE_ID_FG_COLOR, trans);\n  const char* icon = style_get_str(style, active ? STYLE_ID_ACTIVE_ICON : STYLE_ID_ICON, NULL);\n  bitmap_t img;\n\n  if (icon && widget_load_image(widget, icon, &img) == RET_OK) {\n    int32_t x = r->x + (r->w >> 1);\n    int32_t y = r->y + (r->h >> 1);\n    canvas_draw_icon(c, &img, x, y);\n  } else if (color.rgba.a) {\n    if (active) {\n      slide_indicator_default_paint_active_indicator(widget, c, r, color);\n    } else {\n      slide_indicator_default_paint_indicator(widget, c, r, color);\n    }\n  }\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  390,
                  "slide_indicator->max"
               ],
               [
                  391,
                  "slide_indicator->size"
               ],
               [
                  392,
                  "slide_indicator->anchor_x"
               ],
               [
                  393,
                  "slide_indicator->anchor_y"
               ],
               [
                  394,
                  "widget->h"
               ],
               [
                  395,
                  "slide_indicator->margin"
               ],
               [
                  396,
                  "slide_indicator->spacing"
               ],
               [
                  437,
                  "icon_rect_list->size"
               ]
            ]
         },
         {
            "type": "func",
            "name": "slide_indicator_set_visible",
            "line_range": [
               455,
               480
            ],
            "source_code": "static ret_t slide_indicator_set_visible(widget_t* widget, bool_t visible) {\n  slide_indicator_t* slide_indicator = SLIDE_INDICATOR(widget);\n  return_value_if_fail(widget != NULL && slide_indicator != NULL, RET_REMOVE);\n\n  if (slide_indicator->wa_opactiy != NULL) {\n    widget_animator_destroy(slide_indicator->wa_opactiy);\n    slide_indicator->wa_opactiy = NULL;\n  }\n\n  if (!visible && slide_indicator->auto_hide) {\n    slide_indicator->wa_opactiy = widget_animator_opacity_create(\n        widget, SLIDE_INDICATOR_HIDE_ANIMATOR_TIME, 0, EASING_SIN_INOUT);\n    widget_animator_on(slide_indicator->wa_opactiy, EVT_ANIM_END, slide_indicator_on_animate_end,\n                       slide_indicator);\n    widget_animator_opacity_set_params(slide_indicator->wa_opactiy, 0xff, 0);\n    widget_set_opacity(widget, 0xff);\n    widget_animator_start(slide_indicator->wa_opactiy);\n  } else {\n    if (visible) {\n      widget_set_opacity(widget, 0xff);\n    }\n    widget_set_visible(widget, visible);\n  }\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  525,
                  "evt->x"
               ],
               [
                  526,
                  "evt->y"
               ]
            ]
         },
         {
            "type": "func",
            "name": "slide_indicator_reset_indicated_widget",
            "line_range": [
               543,
               562
            ],
            "source_code": "static ret_t slide_indicator_reset_indicated_widget(widget_t* widget) {\n  slide_indicator_t* slide_indicator = SLIDE_INDICATOR(widget);\n  return_value_if_fail(slide_indicator != NULL, RET_BAD_PARAMS);\n\n  if (slide_indicator->indicated_widget != NULL) {\n    widget_t* target = slide_indicator->indicated_widget;\n    widget_off_by_func(target, EVT_MOVE, slide_indicator_target_on_move_resize, widget);\n    widget_off_by_func(target, EVT_MOVE_RESIZE, slide_indicator_target_on_move_resize, widget);\n    widget_off_by_func(target, EVT_RESIZE, slide_indicator_target_on_move_resize, widget);\n    widget_off_by_func(target, EVT_PAGE_CHANGED, slide_indicator_target_on_value_changed, widget);\n    widget_off_by_func(target, EVT_DESTROY, slide_indicator_target_on_destroy, widget);\n\n    if (slide_indicator->auto_hide) {\n      widget_off_by_func(target, EVT_POINTER_MOVE, slide_indicator_target_on_pointer_move, widget);\n    }\n    slide_indicator->indicated_widget = NULL;\n  }\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  549,
                  "slide_indicator->indicated_widget"
               ]
            ]
         },
         {
            "type": "func",
            "name": "slide_indicator_on_destroy",
            "line_range": [
               624,
               638
            ],
            "source_code": "ret_t slide_indicator_on_destroy(widget_t* widget) {\n  slide_indicator_t* slide_indicator = SLIDE_INDICATOR(widget);\n  return_value_if_fail(widget != NULL && slide_indicator != NULL, RET_BAD_PARAMS);\n\n  if (slide_indicator->check_hide_idle != TK_INVALID_ID) {\n    idle_remove(slide_indicator->check_hide_idle);\n  }\n\n  darray_deinit(&(slide_indicator->icon_rect_list));\n\n  slide_indicator_reset_indicated_widget(widget);\n  TKMEM_FREE(slide_indicator->indicated_target);\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  659,
                  "e->type"
               ]
            ]
         }
      ],
      "src/ext_widgets/slide_view/slide_view.c": [
         {
            "type": "func",
            "name": "anim_hint_is_overlap_with_alpha",
            "line_range": [
               39,
               41
            ],
            "source_code": "static bool_t anim_hint_is_overlap_with_alpha(slide_view_t* slide_view) {\n  return tk_str_eq(slide_view->anim_hint, \"overlap_with_alpha\");\n}",
            "key_variables": [
               [
                  45,
                  "slide_view->loop"
               ]
            ]
         },
         {
            "type": "func",
            "name": "canvas_set_clip_rect_with_offset",
            "line_range": [
               47,
               58
            ],
            "source_code": "static ret_t canvas_set_clip_rect_with_offset(canvas_t* c, rect_t* r, rect_t* save_r, int32_t ox,\n                                              int32_t oy) {\n  rect_t rr = *r;\n  vgcanvas_t* vg = canvas_get_vgcanvas(c);\n  rr.x += ox;\n  rr.y += oy;\n\n  rr = rect_intersect(&rr, save_r);\n\n  vgcanvas_clip_rect(vg, rr.x, rr.y, rr.w, rr.h);\n  return canvas_set_clip_rect(c, &rr);\n}",
            "key_variables": [
               [
                  63,
                  "slide_view->active"
               ]
            ]
         },
         {
            "type": "func",
            "name": "slide_view_get_prev",
            "line_range": [
               60,
               72
            ],
            "source_code": "widget_t* slide_view_get_prev(slide_view_t* slide_view) {\n  widget_t* widget = WIDGET(slide_view);\n  uint32_t active = slide_view->active;\n  uint32_t nr = widget_count_children(widget);\n\n  if (active > 0) {\n    return widget_get_child(widget, active - 1);\n  } else if (slide_view_is_loopable(slide_view) && nr > 1) {\n    return widget_get_child(widget, nr - 1);\n  } else {\n    return NULL;\n  }\n}",
            "key_variables": [
               [
                  77,
                  "slide_view->active"
               ]
            ]
         },
         {
            "type": "func",
            "name": "slide_view_activate_prev",
            "line_range": [
               88,
               100
            ],
            "source_code": "ret_t slide_view_activate_prev(slide_view_t* slide_view) {\n  widget_t* widget = WIDGET(slide_view);\n  uint32_t active = slide_view->active;\n  uint32_t nr = widget_count_children(widget);\n\n  if (active > 0) {\n    return slide_view_set_active(widget, active - 1);\n  } else if (slide_view_is_loopable(slide_view) && nr > 1) {\n    return slide_view_set_active(widget, nr - 1);\n  } else {\n    return RET_FAIL;\n  }\n}",
            "key_variables": [
               [
                  91,
                  "slide_view->active"
               ],
               [
                  105,
                  "slide_view->active"
               ]
            ]
         },
         {
            "type": "func",
            "name": "slide_view_on_paint_self",
            "line_range": [
               116,
               120
            ],
            "source_code": "static ret_t slide_view_on_paint_self(widget_t* widget, canvas_t* c) {\n  (void)widget;\n  (void)c;\n  return RET_OK;\n}",
            "key_variables": [
               [
                  127,
                  "e->x"
               ],
               [
                  128,
                  "e->y"
               ]
            ]
         },
         {
            "type": "func",
            "name": "slide_view_on_pointer_up",
            "line_range": [
               190,
               237
            ],
            "source_code": "static ret_t slide_view_on_pointer_up(slide_view_t* slide_view, pointer_event_t* e) {\n  int32_t xoffset_end = 0;\n  int32_t yoffset_end = 0;\n  int32_t xoffset = slide_view->xoffset;\n  int32_t yoffset = slide_view->yoffset;\n  uint32_t v_threshhold = 100;\n  widget_t* widget = WIDGET(slide_view);\n  velocity_t* v = &(slide_view->velocity);\n\n  velocity_update(v, e->e.time, e->x, e->y);\n  if (slide_view->vertical) {\n    int32_t h = widget->h;\n    int32_t yv = tk_abs(v->yv);\n    bool_t rollback = (yv < v_threshhold) && (tk_abs(yoffset) < h / 2);\n\n    if (yoffset > 0 && slide_view_get_prev(slide_view) == NULL) {\n      rollback = TRUE;\n    } else if (yoffset < 0 && slide_view_get_next(slide_view) == NULL) {\n      rollback = TRUE;\n    }\n    if (tk_abs(yoffset) < TK_DRAG_THRESHOLD) {\n      rollback = TRUE;\n    }\n\n    if (!rollback) {\n      yoffset_end = yoffset > 0 ? h : -h;\n    }\n  } else {\n    int32_t w = widget->w;\n    int32_t xv = tk_abs(v->xv);\n    bool_t rollback = (xv < v_threshhold) && (tk_abs(xoffset) < w / 2);\n\n    if (xoffset > 0 && slide_view_get_prev(slide_view) == NULL) {\n      rollback = TRUE;\n    } else if (xoffset < 0 && slide_view_get_next(slide_view) == NULL) {\n      rollback = TRUE;\n    }\n    if (tk_abs(xoffset) < TK_DRAG_THRESHOLD) {\n      rollback = TRUE;\n    }\n\n    if (!rollback) {\n      xoffset_end = xoffset > 0 ? w : -w;\n    }\n  }\n\n  return slide_view_animate_to(slide_view, xoffset, yoffset, xoffset_end, yoffset_end);\n}",
            "key_variables": [
               [
                  194,
                  "slide_view->xoffset"
               ],
               [
                  195,
                  "slide_view->yoffset"
               ],
               [
                  202,
                  "widget->h"
               ],
               [
                  219,
                  "widget->w"
               ]
            ]
         },
         {
            "type": "func",
            "name": "slide_view_on_pointer_move",
            "line_range": [
               239,
               252
            ],
            "source_code": "static ret_t slide_view_on_pointer_move(slide_view_t* slide_view, pointer_event_t* e) {\n  velocity_t* v = &(slide_view->velocity);\n  velocity_update(v, e->e.time, e->x, e->y);\n\n  if (slide_view->vertical) {\n    slide_view->xoffset = 0;\n    slide_view->yoffset = (e->y - slide_view->down.y);\n  } else {\n    slide_view->yoffset = 0;\n    slide_view->xoffset = (e->x - slide_view->down.x);\n  }\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  257,
                  "e->type"
               ]
            ]
         },
         {
            "type": "func",
            "name": "slide_view_get_prop",
            "line_range": [
               375,
               407
            ],
            "source_code": "static ret_t slide_view_get_prop(widget_t* widget, const char* name, value_t* v) {\n  slide_view_t* slide_view = SLIDE_VIEW(widget);\n  return_value_if_fail(widget != NULL && name != NULL && v != NULL, RET_BAD_PARAMS);\n\n  if (tk_str_eq(name, WIDGET_PROP_VALUE) || tk_str_eq(name, WIDGET_PROP_ACTIVE) ||\n      tk_str_eq(name, WIDGET_PROP_CURR_PAGE)) {\n    value_set_int(v, slide_view->active);\n    return RET_OK;\n  } else if (tk_str_eq(name, WIDGET_PROP_VERTICAL)) {\n    value_set_bool(v, slide_view->vertical);\n    return RET_OK;\n  } else if (tk_str_eq(name, WIDGET_PROP_ANIM_HINT)) {\n    value_set_str(v, slide_view->anim_hint);\n    return RET_OK;\n  } else if (tk_str_eq(name, WIDGET_PROP_LOOP)) {\n    value_set_bool(v, slide_view->loop);\n    return RET_OK;\n  } else if (tk_str_eq(name, WIDGET_PROP_AUTO_PLAY)) {\n    value_set_int(v, slide_view->auto_play);\n    return RET_OK;\n  } else if (tk_str_eq(name, WIDGET_PROP_XOFFSET)) {\n    value_set_int(v, slide_view->xoffset);\n    return RET_OK;\n  } else if (tk_str_eq(name, WIDGET_PROP_YOFFSET)) {\n    value_set_int(v, slide_view->yoffset);\n    return RET_OK;\n  } else if (tk_str_eq(name, WIDGET_PROP_PAGE_MAX_NUMBER)) {\n    value_set_uint32(v, slide_view_get_page_max_number(widget));\n    return RET_OK;\n  }\n\n  return RET_NOT_FOUND;\n}",
            "key_variables": [
               [
                  442,
                  "c->ox"
               ],
               [
                  443,
                  "c->oy"
               ]
            ]
         },
         {
            "type": "func",
            "name": "slide_view_paint_prev_next_v_translate",
            "line_range": [
               437,
               482
            ],
            "source_code": "static ret_t slide_view_paint_prev_next_v_translate(slide_view_t* slide_view, canvas_t* c,\n                                                    rect_t* save_r, widget_t* prev, widget_t* next,\n                                                    int32_t yoffset) {\n  rect_t r;\n  int32_t ox = c->ox;\n  int32_t oy = c->oy;\n  xy_t w = WIDGET(slide_view)->w;\n  xy_t h = WIDGET(slide_view)->h;\n  int32_t r_yoffset = h - yoffset;\n\n  if (prev != NULL) {\n    if (yoffset > h) {\n      r = rect_init(0, yoffset - h, w, h + h - yoffset);\n    } else {\n      r = rect_init(0, 0, w, yoffset);\n    }\n\n    if (r.h > 0) {\n      canvas_save(c);\n      canvas_translate(c, 0, -r_yoffset);\n      canvas_set_clip_rect_with_offset(c, &r, save_r, ox, oy);\n      widget_paint(prev, c);\n      canvas_untranslate(c, 0, -r_yoffset);\n      canvas_restore(c);\n    }\n  }\n\n  if (next != NULL) {\n    if (r_yoffset > h) {\n      r = rect_init(0, 0, w, h + h - r_yoffset);\n    } else {\n      r = rect_init(0, yoffset, w, r_yoffset);\n    }\n\n    if (r.h > 0) {\n      canvas_save(c);\n      canvas_translate(c, 0, yoffset);\n      canvas_set_clip_rect_with_offset(c, &r, save_r, ox, oy);\n      widget_paint(next, c);\n      canvas_untranslate(c, 0, yoffset);\n      canvas_restore(c);\n    }\n  }\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  499,
                  "c->ox"
               ],
               [
                  500,
                  "c->oy"
               ],
               [
                  540,
                  "slide_view->prev"
               ]
            ]
         },
         {
            "type": "func",
            "name": "slide_view_set_global_alpha",
            "line_range": [
               484,
               492
            ],
            "source_code": "static ret_t slide_view_set_global_alpha(slide_view_t* slide_view, canvas_t* c, int32_t offset,\n                                         int32_t total) {\n  if (anim_hint_is_overlap_with_alpha(slide_view)) {\n    uint8_t a = 0xff - (0xff * offset) / total;\n    canvas_set_global_alpha(c, a);\n  }\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  551,
                  "slide_view->next"
               ]
            ]
         },
         {
            "type": "func",
            "name": "slide_view_paint_prev_next_h_translate",
            "line_range": [
               561,
               606
            ],
            "source_code": "static ret_t slide_view_paint_prev_next_h_translate(slide_view_t* slide_view, canvas_t* c,\n                                                    rect_t* save_r, widget_t* prev, widget_t* next,\n                                                    int32_t xoffset) {\n  rect_t r;\n  int32_t ox = c->ox;\n  int32_t oy = c->oy;\n  xy_t w = WIDGET(slide_view)->w;\n  xy_t h = WIDGET(slide_view)->h;\n  int32_t r_xoffset = w - xoffset;\n\n  if (prev != NULL) {\n    if (xoffset > w) {\n      r = rect_init(xoffset - w, 0, w + w - xoffset, h);\n    } else {\n      r = rect_init(0, 0, xoffset, h);\n    }\n\n    if (r.w > 0) {\n      canvas_save(c);\n      canvas_translate(c, -r_xoffset, 0);\n      canvas_set_clip_rect_with_offset(c, &r, save_r, ox, oy);\n      widget_paint(prev, c);\n      canvas_untranslate(c, -r_xoffset, 0);\n      canvas_restore(c);\n    }\n  }\n\n  if (next != NULL) {\n    if (r_xoffset > w) {\n      r = rect_init(0, 0, w + w - r_xoffset, h);\n    } else {\n      r = rect_init(xoffset, 0, r_xoffset, h);\n    }\n\n    if (r.w > 0) {\n      canvas_save(c);\n      canvas_translate(c, xoffset, 0);\n      canvas_set_clip_rect_with_offset(c, &r, save_r, ox, oy);\n      widget_paint(next, c);\n      canvas_untranslate(c, xoffset, 0);\n      canvas_restore(c);\n    }\n  }\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  566,
                  "c->ox"
               ],
               [
                  567,
                  "c->oy"
               ],
               [
                  613,
                  "c->ox"
               ],
               [
                  614,
                  "c->oy"
               ]
            ]
         },
         {
            "type": "func",
            "name": "slide_view_paint_prev_next_h_overlap",
            "line_range": [
               608,
               649
            ],
            "source_code": "static ret_t slide_view_paint_prev_next_h_overlap(slide_view_t* slide_view, canvas_t* c,\n                                                  rect_t* save_r, widget_t* prev, widget_t* next,\n                                                  int32_t xoffset) {\n  rect_t r;\n  int32_t ox = c->ox;\n  int32_t oy = c->oy;\n  xy_t w = WIDGET(slide_view)->w;\n  xy_t h = WIDGET(slide_view)->h;\n  int32_t r_xoffset = w - xoffset;\n\n  if (prev != NULL && xoffset >= 0) {\n    canvas_save(c);\n    if (xoffset > w) {\n      widget_paint(prev, c);\n    } else {\n      slide_view_set_global_alpha(slide_view, c, r_xoffset, w);\n      widget_paint(prev, c);\n      canvas_set_global_alpha(c, 0xff);\n    }\n    canvas_restore(c);\n  }\n\n  if (next != NULL) {\n    if (r_xoffset > w) {\n      xoffset = 0;\n      r_xoffset = w;\n    }\n\n    r = rect_init(xoffset, 0, r_xoffset, h);\n\n    if (r.w > 0) {\n      canvas_save(c);\n      canvas_translate(c, xoffset, 0);\n      canvas_set_clip_rect_with_offset(c, &r, save_r, ox, oy);\n      widget_paint(next, c);\n      canvas_untranslate(c, xoffset, 0);\n      canvas_restore(c);\n    }\n  }\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  654,
                  "slide_view->prev"
               ]
            ]
         },
         {
            "type": "func",
            "name": "slide_view_paint_children_h_gt",
            "line_range": [
               651,
               661
            ],
            "source_code": "static ret_t slide_view_paint_children_h_gt(slide_view_t* slide_view, canvas_t* c, rect_t* save_r) {\n  int32_t xoffset = tk_abs(slide_view->xoffset);\n  widget_t* prev = slide_view->prev;\n  widget_t* active = widget_get_child(WIDGET(slide_view), slide_view->active);\n\n  if (anim_hint_is_overlap(slide_view)) {\n    return slide_view_paint_prev_next_h_overlap(slide_view, c, save_r, prev, active, xoffset);\n  } else {\n    return slide_view_paint_prev_next_h_translate(slide_view, c, save_r, prev, active, xoffset);\n  }\n}",
            "key_variables": [
               [
                  665,
                  "slide_view->next"
               ],
               [
                  679,
                  "lcd->global_alpha"
               ]
            ]
         },
         {
            "type": "func",
            "name": "slide_view_on_idle_init_save_target",
            "line_range": [
               756,
               765
            ],
            "source_code": "static ret_t slide_view_on_idle_init_save_target(const idle_info_t* idle) {\n  slide_view_t* slide_view = NULL;\n  return_value_if_fail(idle != NULL, RET_BAD_PARAMS);\n  slide_view = SLIDE_VIEW(idle->ctx);\n\n  slide_view_restore_target(WIDGET(slide_view));\n  slide_view->init_idle_id = TK_INVALID_ID;\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  785,
                  "target->target"
               ]
            ]
         },
         {
            "type": "func",
            "name": "slide_view_set_active_no_animate_impl",
            "line_range": [
               834,
               862
            ],
            "source_code": "static ret_t slide_view_set_active_no_animate_impl(widget_t* widget, uint32_t active,\n                                                   bool_t force) {\n  slide_view_t* slide_view = SLIDE_VIEW(widget);\n  return_value_if_fail(slide_view != NULL, RET_BAD_PARAMS);\n\n  if ((force || slide_view->active != active) && widget->children != NULL) {\n    value_change_event_t evt;\n\n    slide_view_save_target(widget);\n\n    value_change_event_init(&evt, EVT_VALUE_WILL_CHANGE, widget);\n    value_set_uint32(&(evt.old_value), slide_view->active);\n    value_set_uint32(&(evt.new_value), active);\n\n    if (widget_dispatch(widget, (event_t*)&evt) != RET_STOP) {\n      slide_view->active = active;\n      evt.e.type = EVT_VALUE_CHANGED;\n      widget_dispatch(widget, (event_t*)&evt);\n      widget_dispatch_simple_event(widget, EVT_PAGE_CHANGED);\n      widget_invalidate(widget, NULL);\n    }\n\n    slide_view_restore_target(widget);\n  } else {\n    slide_view->active = active;\n  }\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  879,
                  "slide_view->active"
               ],
               [
                  885,
                  "widget->w"
               ],
               [
                  890,
                  "widget->w"
               ]
            ]
         },
         {
            "type": "func",
            "name": "slide_view_set_anim_hint",
            "line_range": [
               921,
               928
            ],
            "source_code": "ret_t slide_view_set_anim_hint(widget_t* widget, const char* anim_hint) {\n  slide_view_t* slide_view = SLIDE_VIEW(widget);\n  return_value_if_fail(slide_view != NULL, RET_BAD_PARAMS);\n\n  slide_view->anim_hint = tk_str_copy(slide_view->anim_hint, anim_hint);\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  964,
                  "widget->h"
               ],
               [
                  966,
                  "widget->w"
               ]
            ]
         },
         {
            "type": "func",
            "name": "slide_view_set_loop",
            "line_range": [
               930,
               937
            ],
            "source_code": "ret_t slide_view_set_loop(widget_t* widget, bool_t loop) {\n  slide_view_t* slide_view = SLIDE_VIEW(widget);\n  return_value_if_fail(slide_view != NULL, RET_BAD_PARAMS);\n\n  slide_view->loop = loop;\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  1004,
                  "slide_view->active"
               ]
            ]
         }
      ],
      "src/ext_widgets/svg_image/svg_image.c": [
         {
            "type": "func",
            "name": "svg_image_on_paint_self",
            "line_range": [
               51,
               98
            ],
            "source_code": "static ret_t svg_image_on_paint_self(widget_t* widget, canvas_t* c) {\n  svg_image_t* svg_image = SVG_IMAGE(widget);\n  vgcanvas_t* vg = canvas_get_vgcanvas(c);\n  image_base_t* image_base = IMAGE_BASE(widget);\n  return_value_if_fail(svg_image != NULL && image_base != NULL && widget != NULL, RET_BAD_PARAMS);\n\n  if (image_base->image == NULL || image_base->image[0] == '\\0') {\n    widget_paint_helper(widget, c, NULL, NULL);\n    return RET_OK;\n  }\n\n  if (svg_image_load_bsvg(widget) == RET_OK) {\n    bsvg_t bsvg;\n    int32_t x = 0;\n    int32_t y = 0;\n    style_t* style = widget->astyle;\n    color_t black = color_init(0, 0, 0, 0xff);\n    const asset_info_t* asset = svg_image->bsvg_asset;\n    color_t bg = style_get_color(style, STYLE_ID_BG_COLOR, black);\n    color_t fg = style_get_color(style, STYLE_ID_FG_COLOR, black);\n    return_value_if_fail(asset != NULL && asset->data != NULL, RET_FAIL);\n\n    return_value_if_fail(bsvg_init(&bsvg, (const uint32_t*)asset->data, asset->size) != NULL,\n                         RET_BAD_PARAMS);\n    if (bsvg.header->w && bsvg.header->h) {\n      x = (widget->w - (int32_t)bsvg.header->w) / 2;\n      y = (widget->h - (int32_t)bsvg.header->h) / 2;\n    } else if (bsvg.header->viewport.w && bsvg.header->viewport.h) {\n      x = (widget->w - (int32_t)bsvg.header->viewport.w) / 2;\n      y = (widget->h - (int32_t)bsvg.header->viewport.h) / 2;\n    }\n\n    vgcanvas_save(vg);\n\n    image_transform(widget, c);\n    vgcanvas_translate(vg, x, y);\n    vgcanvas_set_fill_color(vg, bg);\n    vgcanvas_set_stroke_color(vg, fg);\n\n    bsvg_draw(&bsvg, vg);\n\n    vgcanvas_restore(vg);\n  }\n\n  widget_paint_helper(widget, c, NULL, NULL);\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  67,
                  "widget->astyle"
               ],
               [
                  69,
                  "svg_image->bsvg_asset"
               ]
            ]
         }
      ],
      "src/ext_widgets/switch/switch.c": [
         {
            "type": "func",
            "name": "switch_on_pointer_down",
            "line_range": [
               29,
               39
            ],
            "source_code": "static ret_t switch_on_pointer_down(switch_t* aswitch, pointer_event_t* e) {\n  velocity_t* v = &(aswitch->velocity);\n\n  velocity_reset(v);\n  aswitch->xdown = e->x;\n  aswitch->xoffset_save = aswitch->xoffset;\n\n  velocity_update(v, e->e.time, e->x, e->y);\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  34,
                  "e->x"
               ],
               [
                  35,
                  "aswitch->xoffset"
               ]
            ]
         },
         {
            "type": "func",
            "name": "switch_on_pointer_move",
            "line_range": [
               41,
               56
            ],
            "source_code": "static ret_t switch_on_pointer_move(switch_t* aswitch, pointer_event_t* e) {\n  velocity_t* v = &(aswitch->velocity);\n  widget_t* widget = WIDGET(aswitch);\n  int32_t dx = e->x - aswitch->xdown;\n  int32_t max_xoffset = aswitch->max_xoffset_ratio * widget->w;\n\n  velocity_update(v, e->e.time, e->x, e->y);\n  if (aswitch->wa == NULL && dx) {\n    aswitch->xoffset = aswitch->xoffset_save - dx;\n  }\n\n  aswitch->xoffset = tk_max(0, aswitch->xoffset);\n  aswitch->xoffset = tk_min(aswitch->xoffset, max_xoffset);\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  45,
                  "aswitch->xdown"
               ],
               [
                  46,
                  "widget->w"
               ]
            ]
         },
         {
            "type": "func",
            "name": "switch_scroll_to",
            "line_range": [
               69,
               93
            ],
            "source_code": "static ret_t switch_scroll_to(widget_t* widget, int32_t xoffset_end) {\n  int32_t xoffset = 0;\n  switch_t* aswitch = SWITCH(widget);\n  return_value_if_fail(aswitch != NULL, RET_FAIL);\n\n  xoffset = aswitch->xoffset;\n  if (xoffset == xoffset_end) {\n    switch_set_value(widget, aswitch->xoffset == 0);\n    return RET_OK;\n  }\n\n#ifndef WITHOUT_WIDGET_ANIMATORS\n  aswitch->wa = widget_animator_scroll_create(widget, ANIMATING_TIME, 0, EASING_SIN_INOUT);\n  return_value_if_fail(aswitch->wa != NULL, RET_OOM);\n\n  widget_animator_scroll_set_params(aswitch->wa, xoffset, 0, xoffset_end, 0);\n  widget_animator_on(aswitch->wa, EVT_ANIM_END, switch_on_scroll_done, aswitch);\n  widget_animator_start(aswitch->wa);\n#else\n  aswitch->xoffset = xoffset_end;\n  switch_on_scroll_done(widget, NULL);\n#endif /*WITHOUT_WIDGET_ANIMATORS*/\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  75,
                  "aswitch->xoffset"
               ],
               [
                  105,
                  "widget->w"
               ],
               [
                  108,
                  "v->xv"
               ]
            ]
         },
         {
            "type": "func",
            "name": "switch_on_pointer_up",
            "line_range": [
               95,
               124
            ],
            "source_code": "static ret_t switch_on_pointer_up(switch_t* aswitch, pointer_event_t* e) {\n  velocity_t* v = NULL;\n  int32_t xoffset_end = 0;\n  int32_t min_xoffset = 0;\n  int32_t max_xoffset = 0;\n  widget_t* widget = WIDGET(aswitch);\n  return_value_if_fail(widget != NULL && aswitch != NULL, RET_BAD_PARAMS);\n\n  v = &(aswitch->velocity);\n  max_xoffset = aswitch->max_xoffset_ratio * widget->w;\n\n  velocity_update(v, e->e.time, e->x, e->y);\n  xoffset_end = aswitch->xoffset - v->xv;\n\n  if (e->x == aswitch->xdown) {\n    /*click*/\n    pointer_event_t click;\n    widget_dispatch(widget, pointer_event_init(&click, EVT_CLICK, widget, e->x, e->y));\n  } else {\n    if (xoffset_end < max_xoffset / 2) {\n      xoffset_end = min_xoffset;\n    } else {\n      xoffset_end = max_xoffset;\n    }\n\n    switch_scroll_to(widget, xoffset_end);\n  }\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  128,
                  "e->type"
               ],
               [
                  145,
                  "aswitch->xoffset_save"
               ],
               [
                  158,
                  "aswitch->xoffset_save"
               ],
               [
                  163,
                  "widget->w"
               ],
               [
                  181,
                  "widget->w"
               ],
               [
                  193,
                  "widget->astyle"
               ]
            ]
         },
         {
            "type": "func",
            "name": "switch_on_paint_background_img",
            "line_range": [
               229,
               275
            ],
            "source_code": "static ret_t switch_on_paint_background_img(widget_t* widget, canvas_t* c, bitmap_t* img) {\n  float_t fw = 0;\n  int32_t iw = 0;\n  int32_t ih = 0;\n  float_t wscale = 0;\n  float_t hscale = 0;\n  int32_t xoffset = 0;\n  int32_t round_radius = 0;\n  vgcanvas_t* vg = canvas_get_vgcanvas(c);\n  switch_t* aswitch = SWITCH(widget);\n  return_value_if_fail(img != NULL && widget != NULL && aswitch != NULL && vg != NULL,\n                       RET_BAD_PARAMS);\n\n  iw = img->w;\n  ih = img->h;\n  wscale = (float_t)(widget->w) / (float_t)iw;\n  hscale = (float_t)(widget->h) / (float_t)ih;\n  xoffset = (float_t)(aswitch->xoffset) / wscale;\n  round_radius = style_get_int(widget->astyle, STYLE_ID_ROUND_RADIUS, 0) / hscale;\n\n  fw = iw * (1.0f - aswitch->max_xoffset_ratio);\n  wscale = (float_t)(widget->w) / fw;\n\n  if (vg == NULL || (round_radius < 5 && tk_abs(wscale - 1) <= 0.000001f)) {\n    int32_t x = (widget->w - (int32_t)fw) >> 1;\n    int32_t y = (widget->h - ih) >> 1;\n    rect_t src = rect_init(xoffset, 0, (int32_t)fw, ih);\n    rect_t dst = rect_init(x, y, (int32_t)fw, ih);\n\n    dst.y = tk_max(0, y);\n    dst.h = tk_min(dst.h, widget->h);\n\n    return canvas_draw_image(c, img, &src, &dst);\n  }\n\n  if (vg != NULL) {\n    vgcanvas_save(vg);\n    vgcanvas_translate(vg, c->ox, c->oy);\n    vgcanvas_scale(vg, wscale, hscale);\n    vgcanvas_translate(vg, -xoffset, 0);\n    vgcanvas_rounded_rect(vg, xoffset, 0, fw, ih, round_radius);\n    vgcanvas_paint(vg, FALSE, img);\n    vgcanvas_restore(vg);\n  }\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  243,
                  "img->w"
               ],
               [
                  244,
                  "img->h"
               ],
               [
                  284,
                  "widget->astyle"
               ],
               [
                  293,
                  "widget->w"
               ]
            ]
         },
         {
            "type": "func",
            "name": "switch_on_paint_background",
            "line_range": [
               277,
               298
            ],
            "source_code": "static ret_t switch_on_paint_background(widget_t* widget, canvas_t* c) {\n  style_t* style = NULL;\n  const char* image_name = NULL;\n  switch_t* aswitch = SWITCH(widget);\n  return_value_if_fail(aswitch != NULL && widget->astyle != NULL, RET_BAD_PARAMS);\n\n  style = widget->astyle;\n  image_name = style_get_str(style, STYLE_ID_BG_IMAGE, NULL);\n\n  if (image_name != NULL && *image_name) {\n    bitmap_t img;\n    if (widget_load_image(widget, image_name, &img) == RET_OK) {\n      return switch_on_paint_background_img(widget, c, &img);\n    }\n  } else {\n    int32_t w = widget->w;  //tk_roundi(widget->w * 1.5 * (1 - aswitch->max_xoffset_ratio));\n    rect_t r = rect_init((widget->w - w) / 2.0f, 0, w, widget->h);\n    return switch_fill_rect_color(widget, c, &r, TRUE);\n  }\n\n  return RET_FAIL;\n}",
            "key_variables": [
               [
                  318,
                  "widget->astyle"
               ],
               [
                  329,
                  "widget->w"
               ],
               [
                  372,
                  "widget->w"
               ]
            ]
         },
         {
            "type": "func",
            "name": "switch_set_value",
            "line_range": [
               350,
               377
            ],
            "source_code": "ret_t switch_set_value(widget_t* widget, bool_t value) {\n  switch_t* aswitch = SWITCH(widget);\n  return_value_if_fail(aswitch != NULL, RET_BAD_PARAMS);\n\n  if (aswitch->value != value) {\n    value_change_event_t evt;\n    value_change_event_init(&evt, EVT_VALUE_WILL_CHANGE, widget);\n    value_set_bool(&(evt.old_value), aswitch->value);\n    value_set_bool(&(evt.new_value), value);\n\n    if (widget_dispatch(widget, (event_t*)&evt) != RET_STOP) {\n      aswitch->value = value;\n      evt.e.type = EVT_VALUE_CHANGED;\n      widget_dispatch(widget, (event_t*)&evt);\n      widget_invalidate(widget, NULL);\n    }\n  }\n\n  if (aswitch->value) {\n    aswitch->xoffset = 0;\n  } else {\n    aswitch->xoffset = aswitch->max_xoffset_ratio * widget->w;\n  }\n\n  widget_invalidate(widget, NULL);\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  417,
                  "widget->w"
               ]
            ]
         }
      ],
      "src/ext_widgets/text_selector/text_selector.c": [
         {
            "type": "block",
            "name": "block",
            "line_range": "",
            "source_code": "",
            "key_variables": [
               58,
               "widget->astyle"
            ]
         },
         {
            "type": "block",
            "name": "block",
            "line_range": "",
            "source_code": "",
            "key_variables": [
               66,
               "text_selector->visible_nr"
            ]
         },
         {
            "type": "func",
            "name": "text_selector_paint_mask",
            "line_range": [
               106,
               210
            ],
            "source_code": "static ret_t text_selector_paint_mask(widget_t* widget, canvas_t* c) {\n\n  int32_t i = 0;\n\n  int32_t y = 0;\n\n  int32_t n = widget->h / 2;\n\n  style_t* style = widget->astyle;\n\n  color_t trans = color_init(0, 0, 0, 0);\n\n  easing_func_t easing = easing_get(EASING_CUBIC_IN);\n\n  color_t fc = style_get_color(style, STYLE_ID_FG_COLOR, trans);\n\n  const char* fg_image = style_get_str(style, STYLE_ID_FG_IMAGE, NULL);\n\n  color_t mask_color = style_get_color(style, STYLE_ID_MASK_COLOR, trans);\n\n\n\n  text_selector_t* text_selector = TEXT_SELECTOR(widget);\n\n  int32_t visible_nr = text_selector->visible_nr;\n\n  int32_t item_height = text_selector->draw_widget_h / visible_nr;\n\n\n\n  if (fc.rgba.a) {\n\n    canvas_set_stroke_color(c, fc);\n\n    for (i = 1; i < visible_nr; i++) {\n\n      y = i * item_height;\n\n      canvas_draw_hline(c, 0, y, widget->w);\n\n    }\n\n  }\n\n\n\n  if (mask_color.rgba.a) {\n\n    for (i = 0; i < n; i++) {\n\n      y = n - i - 1;\n\n\n\n      mask_color.rgba.a = 0xff * easing((float_t)i / (float_t)n);\n\n      canvas_set_stroke_color(c, mask_color);\n\n      canvas_draw_hline(c, 0, y, widget->w);\n\n    }\n\n\n\n    for (i = 0; i < n; i++) {\n\n      y = widget->h - n + i;\n\n\n\n      mask_color.rgba.a = 0xff * easing((float_t)i / (float_t)n);\n\n      canvas_set_stroke_color(c, mask_color);\n\n      canvas_draw_hline(c, 0, y, widget->w);\n\n    }\n\n  }\n\n\n\n  if (fg_image != NULL && *fg_image) {\n\n    bitmap_t img;\n\n    rect_t r = rect_init(0, 0, widget->w, widget->h);\n\n    if (widget_load_image(widget, fg_image, &img) == RET_OK) {\n\n      image_draw_type_t draw_type =\n\n          (image_draw_type_t)style_get_int(style, STYLE_ID_FG_IMAGE_DRAW_TYPE, IMAGE_DRAW_CENTER);\n\n      canvas_draw_image_ex(c, &img, draw_type, (const rect_t*)&r);\n\n    }\n\n  }\n\n\n\n  return RET_OK;\n\n}",
            "key_variables": [
               [
                  132,
                  "widget->astyle"
               ],
               [
                  185,
                  "text_selector->yoffset"
               ],
               [
                  186,
                  "text_selector->visible_nr"
               ],
               [
                  193,
                  "text_selector->draw_widget_h"
               ],
               [
                  198,
                  "text_selector->option_items"
               ]
            ]
         },
         {
            "type": "func",
            "name": "text_selector_range_yoffset",
            "line_range": [
               214,
               254
            ],
            "source_code": "static int32_t text_selector_range_yoffset(int32_t value, int32_t min_yoffset, int32_t max_yoffset,\n\n                                           int32_t item_height, int32_t empty_item_height,\n\n                                           bool_t loop_options) {\n\n  if (value < min_yoffset) {\n\n    int32_t tmp = max_yoffset + empty_item_height + item_height;\n\n    if (loop_options && tmp != 0) {\n\n      int32_t n = tk_abs(value / tmp) + 1;\n\n      value = value + tmp * n;\n\n    } else {\n\n      value = min_yoffset;\n\n    }\n\n  } else if (value > max_yoffset) {\n\n    int32_t tmp = max_yoffset + empty_item_height + item_height;\n\n    if (loop_options && tmp != 0) {\n\n      value = value % tmp;\n\n    } else {\n\n      value = max_yoffset;\n\n    }\n\n  }\n\n  return value;\n\n}",
            "key_variables": [
               [
                  227,
                  "iter->next"
               ],
               [
                  258,
                  "text_selector->visible_nr"
               ],
               [
                  261,
                  "widget->h"
               ]
            ]
         },
         {
            "type": "func",
            "name": "text_selector_paint_text",
            "line_range": [
               318,
               342
            ],
            "source_code": "static ret_t text_selector_paint_text(widget_t* widget, canvas_t* c, rect_t* r,\n\n                                      text_selector_option_t* iter, int32_t empty_item_height,\n\n                                      int32_t item_height) {\n\n  uint32_t d = tk_abs(r->y - empty_item_height);\n\n\n\n  if (d < item_height) {\n\n    text_selector_prepare_highlight_style(widget, c, (item_height - d) / (float_t)item_height,\n\n                                          d < item_height / 2);\n\n  } else {\n\n    widget_prepare_text_style(widget, c);\n\n  }\n\n  return canvas_draw_text_in_rect(c, iter->text.str, iter->text.size, r);\n\n}",
            "key_variables": [
               [
                  328,
                  "text[64]"
               ],
               [
                  354,
                  "format[41]"
               ]
            ]
         },
         {
            "type": "func",
            "name": "text_selector_prepare_highlight_style",
            "line_range": [
               258,
               314
            ],
            "source_code": "static ret_t text_selector_prepare_highlight_style(widget_t* widget, canvas_t* c, float_t d,\n\n                                                   bool_t set_color) {\n\n  style_t* style = widget->astyle;\n\n  color_t trans = color_init(0, 0, 0, 0);\n\n  color_t tc = style_get_color(style, STYLE_ID_TEXT_COLOR, trans);\n\n  color_t hg_tc = style_get_color(style, STYLE_ID_HIGHLIGHT_TEXT_COLOR, trans);\n\n  const char* font_name = style_get_str(style, STYLE_ID_FONT_NAME, NULL);\n\n  uint16_t font_size = style_get_int(style, STYLE_ID_FONT_SIZE, TK_DEFAULT_FONT_SIZE);\n\n  uint16_t hg_font_size = style_get_int(style, STYLE_ID_HIGHLIGHT_FONT_SIZE, font_size);\n\n  const char* hg_font_name = style_get_str(style, STYLE_ID_HIGHLIGHT_FONT_NAME, font_name);\n\n  uint16_t tmp_font_size = hg_font_size;\n\n\n\n  if (hg_tc.rgba.a > 0 && set_color) {\n\n    canvas_set_text_color(c, hg_tc);\n\n  } else {\n\n    canvas_set_text_color(c, tc);\n\n  }\n\n\n\n  if (hg_font_size != font_size) {\n\n    if (d >= 1.0f) {\n\n      tmp_font_size = hg_font_size;\n\n    } else {\n\n      tmp_font_size = font_size + tk_roundi((hg_font_size - font_size) * d);\n\n    }\n\n  }\n\n  canvas_set_font(c, hg_font_name, tmp_font_size);\n\n\n\n  return RET_OK;\n\n}",
            "key_variables": [
               [
                  464,
                  "e->y"
               ],
               [
                  465,
                  "text_selector->yoffset"
               ]
            ]
         },
         {
            "type": "func",
            "name": "text_selector_paint_self",
            "line_range": [
               346,
               462
            ],
            "source_code": "static ret_t text_selector_paint_self(widget_t* widget, canvas_t* c) {\n\n  rect_t r;\n\n  uint32_t y = 0;\n\n  uint32_t i = 0;\n\n  text_selector_option_t* iter = NULL;\n\n  int32_t max_yoffset, tolal_height;\n\n  int32_t yoffset, visible_nr, item_height;\n\n  int32_t options_nr, empty_item_height, min_yoffset;\n\n  text_selector_t* text_selector = TEXT_SELECTOR(widget);\n\n  return_value_if_fail(text_selector != NULL, RET_BAD_PARAMS);\n\n\n\n  yoffset = text_selector->yoffset;\n\n  visible_nr = text_selector->visible_nr;\n\n  item_height = text_selector->draw_widget_h / visible_nr;\n\n  r = rect_init(0, 0, widget->w, item_height);\n\n\n\n  options_nr = text_selector_count_options(widget);\n\n  empty_item_height = (text_selector->visible_nr / 2) * item_height;\n\n  min_yoffset = -empty_item_height;\n\n  max_yoffset = (options_nr * item_height + empty_item_height) - text_selector->draw_widget_h;\n\n  tolal_height = max_yoffset + empty_item_height;\n\n  return_value_if_fail(options_nr > 0, RET_BAD_PARAMS);\n\n\n\n  widget_prepare_text_style(widget, c);\n\n  iter = text_selector->option_items;\n\n\n\n  yoffset = text_selector_range_yoffset(yoffset, min_yoffset, max_yoffset, item_height,\n\n                                        empty_item_height, text_selector->loop_options);\n\n\n\n  while (iter != NULL) {\n\n    r.y = y - yoffset;\n\n\n\n    if (text_selector->loop_options) {\n\n      if (yoffset <= 0 && r.y > tolal_height) {\n\n        /* 当 yoffset <= 0 说明顶部有空位，需要显示，\n\n         * r.y 是选项加上 yoffset ，如果 r.y 大于 tolal_height 说明这个选项是加上 yoffset 后偏移出来的尾部。\n\n         * 然后把该选项设置到顶部的空位上面。\n\n         */\n\n        r.y = r.y - tolal_height - item_height;\n\n      } else if (r.y + max_yoffset < empty_item_height) {\n\n        /* max_yoffset 为总队列长度，而 r.y 一定为负数，empty_item_height 是做多的剩余空位高度\n\n         * 符合该条件的选项，等于是选项加上 yoffset 后大于总队列长度，意味着选项为偏移出来的头部。\n\n         * 然后把该选项设置到尾部的空位上面。\n\n         */\n\n        r.y = empty_item_height + item_height + r.y + max_yoffset;\n\n      }\n\n    }\n\n\n\n    if ((r.y + item_height) >= 0 && r.y < widget->h) {\n\n      text_selector_paint_text(widget, c, &r, iter, empty_item_height, item_height);\n\n    }\n\n\n\n    i++;\n\n    iter = iter->next;\n\n    y += item_height;\n\n  }\n\n\n\n  return RET_OK;\n\n}",
            "key_variables": [
               [
                  473,
                  "text_selector->ydown"
               ],
               [
                  495,
                  "text_selector->selected_index"
               ]
            ]
         },
         {
            "type": "func",
            "name": "text_selector_set_real_draw_info",
            "line_range": [
               506,
               532
            ],
            "source_code": "static ret_t text_selector_set_real_draw_info(widget_t* widget) {\n\n  int32_t tmp_h = 0;\n\n  text_selector_t* text_selector = TEXT_SELECTOR(widget);\n\n  return_value_if_fail(text_selector != NULL, RET_BAD_PARAMS);\n\n  tmp_h = widget->h % text_selector->visible_nr;\n\n  if (tmp_h == 0) {\n\n    text_selector->draw_widget_y = 0;\n\n    text_selector->draw_widget_h = widget->h;\n\n  } else {\n\n    text_selector->draw_widget_y = tmp_h / 2;\n\n    text_selector->draw_widget_h = widget->h - tmp_h;\n\n  }\n\n  return RET_OK;\n\n}",
            "key_variables": [
               [
                  513,
                  "text_selector->visible_nr"
               ],
               [
                  531,
                  "text_selector->yoffset"
               ]
            ]
         },
         {
            "type": "func",
            "name": "text_selector_on_paint_self",
            "line_range": [
               466,
               502
            ],
            "source_code": "static ret_t text_selector_on_paint_self(widget_t* widget, canvas_t* c) {\n\n  rect_t r_save;\n\n  text_selector_t* text_selector = TEXT_SELECTOR(widget);\n\n  rect_t r = rect_init(c->ox, c->oy, widget->w, widget->h);\n\n  return_value_if_fail(widget != NULL && text_selector != NULL, RET_BAD_PARAMS);\n\n\n\n  canvas_get_clip_rect(c, &r_save);\n\n  r = rect_intersect(&r_save, &r);\n\n  if (r.w > 0 && r.h > 0) {\n\n    canvas_translate(c, 0, text_selector->draw_widget_y);\n\n    canvas_set_clip_rect(c, &r);\n\n    text_selector_paint_self(widget, c);\n\n    text_selector_paint_mask(widget, c);\n\n    canvas_set_clip_rect(c, &r_save);\n\n    canvas_untranslate(c, 0, text_selector->draw_widget_y);\n\n  }\n\n\n\n  return RET_OK;\n\n}",
            "key_variables": [
               [
                  556,
                  "text_selector->visible_nr"
               ]
            ]
         },
         {
            "type": "func",
            "name": "text_selector_on_layout_children",
            "line_range": [
               536,
               554
            ],
            "source_code": "static ret_t text_selector_on_layout_children(widget_t* widget) {\n\n  text_selector_t* text_selector = TEXT_SELECTOR(widget);\n\n  return_value_if_fail(text_selector != NULL, RET_BAD_PARAMS);\n\n  text_selector_set_real_draw_info(widget);\n\n  if (!text_selector->is_init) {\n\n    text_selector_sync_yoffset_with_selected_index(text_selector, FALSE);\n\n    text_selector->is_init = TRUE;\n\n  }\n\n  return RET_OK;\n\n}",
            "key_variables": [
               [
                  582,
                  "text_selector->visible_nr"
               ]
            ]
         },
         {
            "type": "func",
            "name": "text_selector_set_real_draw_info",
            "line_range": [
               506,
               532
            ],
            "source_code": "static ret_t text_selector_set_real_draw_info(widget_t* widget) {\n\n  int32_t tmp_h = 0;\n\n  text_selector_t* text_selector = TEXT_SELECTOR(widget);\n\n  return_value_if_fail(text_selector != NULL, RET_BAD_PARAMS);\n\n  tmp_h = widget->h % text_selector->visible_nr;\n\n  if (tmp_h == 0) {\n\n    text_selector->draw_widget_y = 0;\n\n    text_selector->draw_widget_h = widget->h;\n\n  } else {\n\n    text_selector->draw_widget_y = tmp_h / 2;\n\n    text_selector->draw_widget_h = widget->h - tmp_h;\n\n  }\n\n  return RET_OK;\n\n}",
            "key_variables": [
               [
                  585,
                  "text_selector->draw_widget_h"
               ]
            ]
         },
         {
            "type": "func",
            "name": "text_selector_on_destroy",
            "line_range": [
               558,
               582
            ],
            "source_code": "static ret_t text_selector_on_destroy(widget_t* widget) {\n\n  text_selector_t* text_selector = TEXT_SELECTOR(widget);\n\n  return_value_if_fail(widget != NULL && text_selector != NULL, RET_BAD_PARAMS);\n\n\n\n  str_reset(&(text_selector->text));\n\n  text_selector_reset_options(widget);\n\n\n\n  if (text_selector->locale_info_id != TK_INVALID_ID) {\n\n    locale_info_off(locale_info(), text_selector->locale_info_id);\n\n  }\n\n\n\n  return RET_OK;\n\n}",
            "key_variables": [
               [
                  609,
                  "text_selector->visible_nr"
               ],
               [
                  612,
                  "text_selector->draw_widget_h"
               ],
               [
                  626,
                  "text_selector->yoffset"
               ],
               [
                  651,
                  "text_selector->visible_nr"
               ],
               [
                  654,
                  "text_selector->yspeed_scale"
               ],
               [
                  667,
                  "text_selector->yspeed_scale"
               ]
            ]
         },
         {
            "type": "func",
            "name": "text_selector_set_options",
            "line_range": [
               688,
               746
            ],
            "source_code": "ret_t text_selector_set_options(widget_t* widget, const char* options) {\n\n  return_value_if_fail(widget != NULL && options != NULL, RET_BAD_PARAMS);\n\n\n\n  text_selector_reset_options(widget);\n\n  if (strchr(options, ':') == NULL && strchr(options, '-') != NULL) {\n\n    int nr = 0;\n\n    int end = 0;\n\n    int step = 1;\n\n    int start = 0;\n\n    char format[41];\n\n    memset(format, 0x00, sizeof(format));\n\n\n\n    nr = tk_sscanf(options, \"%d-%d-%40s\", &start, &end, format);\n\n\n\n    if (nr < 3) {\n\n      tk_strncpy(format, \"%d\", sizeof(format) - 1);\n\n    } else {\n\n      char* f = strchr(format, '-');\n\n      if (f != NULL) {\n\n        int p = f - format;\n\n        step = tk_atoi(f + 1);\n\n        memset((void*)f, 0x0, sizeof(format) - p);\n\n      }\n\n    }\n\n\n\n    return text_selector_set_range_options_ex(widget, start, end - start + 1, step, format);\n\n  } else {\n\n    return text_selector_parse_options(widget, options);\n\n  }\n\n}",
            "key_variables": [
               [
                  696,
                  "e->type"
               ],
               [
                  714,
                  "text_selector->yoffset_save"
               ],
               [
                  815,
                  "text_selector->option_items"
               ],
               [
                  817,
                  "iter->next"
               ]
            ]
         },
         {
            "type": "func",
            "name": "text_selector_get_prop",
            "line_range": [
               750,
               836
            ],
            "source_code": "static ret_t text_selector_get_prop(widget_t* widget, const char* name, value_t* v) {\n\n  text_selector_t* text_selector = TEXT_SELECTOR(widget);\n\n  return_value_if_fail(widget != NULL && text_selector != NULL, RET_BAD_PARAMS);\n\n\n\n  if (tk_str_eq(name, WIDGET_PROP_TEXT)) {\n\n    value_set_wstr(v, text_selector_get_wtext(widget));\n\n    return RET_OK;\n\n  } else if (tk_str_eq(name, WIDGET_PROP_VALUE)) {\n\n    value_set_int(v, text_selector_get_value(widget));\n\n    return RET_OK;\n\n  } else if (tk_str_eq(name, TEXT_SELECTOR_PROP_VISIBLE_NR)) {\n\n    value_set_int(v, text_selector->visible_nr);\n\n    return RET_OK;\n\n  } else if (tk_str_eq(name, WIDGET_PROP_SELECTED_INDEX)) {\n\n    value_set_int(v, text_selector->selected_index);\n\n    return RET_OK;\n\n  } else if (tk_str_eq(name, WIDGET_PROP_XOFFSET)) {\n\n    value_set_int(v, 0);\n\n    return RET_OK;\n\n  } else if (tk_str_eq(name, WIDGET_PROP_YOFFSET)) {\n\n    value_set_int(v, text_selector->yoffset);\n\n    return RET_OK;\n\n  } else if (tk_str_eq(name, WIDGET_PROP_OPTIONS)) {\n\n    value_set_str(v, text_selector->options);\n\n    return RET_OK;\n\n  } else if (tk_str_eq(name, WIDGET_PROP_LOCALIZE_OPTIONS)) {\n\n    value_set_bool(v, text_selector->localize_options);\n\n    return RET_OK;\n\n  } else if (tk_str_eq(name, TEXT_SELECTOR_PROP_Y_SPEED_SCALE)) {\n\n    value_set_float(v, text_selector->yspeed_scale);\n\n    return RET_OK;\n\n  } else if (tk_str_eq(name, TEXT_SELECTOR_PROP_LOOP_OPTIONS)) {\n\n    value_set_bool(v, text_selector->loop_options);\n\n    return RET_OK;\n\n  } else if (tk_str_eq(name, TEXT_SELECTOR_PROP_ANIMATION_TIME)) {\n\n    value_set_uint32(v, text_selector->animating_time);\n\n    return RET_OK;\n\n  } else if (tk_str_eq(name, TEXT_SELECTOR_PROP_ENABLE_VALUE_ANIMATOR)) {\n\n    value_set_bool(v, text_selector->enable_value_animator);\n\n    return RET_OK;\n\n  }\n\n\n\n  return RET_NOT_FOUND;\n\n}",
            "key_variables": [
               [
                  851,
                  "text_selector->option_items"
               ],
               [
                  854,
                  "iter->next"
               ],
               [
                  880,
                  "text_selector->option_items"
               ],
               [
                  881,
                  "iter->next"
               ],
               [
                  896,
                  "text_selector->option_items"
               ],
               [
                  899,
                  "iter->next"
               ],
               [
                  911,
                  "text_selector->option_items"
               ],
               [
                  918,
                  "iter->next"
               ],
               [
                  933,
                  "text_selector->option_items"
               ]
            ]
         },
         {
            "type": "func",
            "name": "text_selector_on_pointer_down",
            "line_range": [
               918,
               938
            ],
            "source_code": "static ret_t text_selector_on_pointer_down(text_selector_t* text_selector, pointer_event_t* e) {\n\n  velocity_t* v = &(text_selector->velocity);\n\n\n\n  velocity_reset(v);\n\n  text_selector->ydown = e->y;\n\n  text_selector->yoffset_save = text_selector->yoffset;\n\n\n\n  velocity_update(v, e->e.time, e->x, e->y);\n\n\n\n  return RET_OK;\n\n}",
            "key_variables": [
               [
                  941,
                  "iter->next"
               ],
               [
                  954,
                  "text_selector->option_items"
               ]
            ]
         },
         {
            "type": "func",
            "name": "text_selector_set_prop",
            "line_range": [
               840,
               914
            ],
            "source_code": "static ret_t text_selector_set_prop(widget_t* widget, const char* name, const value_t* v) {\n\n  text_selector_t* text_selector = TEXT_SELECTOR(widget);\n\n  return_value_if_fail(widget != NULL && text_selector != NULL, RET_BAD_PARAMS);\n\n\n\n  if (tk_str_eq(name, WIDGET_PROP_VALUE)) {\n\n    text_selector_set_value(widget, value_int(v));\n\n    return RET_OK;\n\n  } else if (tk_str_eq(name, WIDGET_PROP_TEXT)) {\n\n    text_selector_set_text(widget, value_str(v));\n\n    return RET_OK;\n\n  } else if (tk_str_eq(name, TEXT_SELECTOR_PROP_VISIBLE_NR)) {\n\n    text_selector_set_visible_nr(widget, value_int(v));\n\n    return RET_OK;\n\n  } else if (tk_str_eq(name, WIDGET_PROP_SELECTED_INDEX)) {\n\n    text_selector_set_selected_index(widget, value_int(v));\n\n    return RET_OK;\n\n  } else if (tk_str_eq(name, WIDGET_PROP_YOFFSET)) {\n\n    text_selector->yoffset = value_int(v);\n\n    return RET_OK;\n\n  } else if (tk_str_eq(name, WIDGET_PROP_XOFFSET)) {\n\n    return RET_OK;\n\n  } else if (tk_str_eq(name, WIDGET_PROP_OPTIONS)) {\n\n    text_selector_set_options(widget, value_str(v));\n\n    return RET_OK;\n\n  } else if (tk_str_eq(name, WIDGET_PROP_LOCALIZE_OPTIONS)) {\n\n    return text_selector_set_localize_options(widget, value_bool(v));\n\n  } else if (tk_str_eq(name, TEXT_SELECTOR_PROP_Y_SPEED_SCALE)) {\n\n    return text_selector_set_yspeed_scale(widget, value_float(v));\n\n  } else if (tk_str_eq(name, TEXT_SELECTOR_PROP_LOOP_OPTIONS)) {\n\n    return text_selector_set_loop_options(widget, value_bool(v));\n\n  } else if (tk_str_eq(name, TEXT_SELECTOR_PROP_ANIMATION_TIME)) {\n\n    return text_selector_set_animating_time(widget, value_uint32(v));\n\n  } else if (tk_str_eq(name, TEXT_SELECTOR_PROP_ENABLE_VALUE_ANIMATOR)) {\n\n    return text_selector_set_enable_value_animator(widget, value_bool(v));\n\n  }\n\n\n\n  return RET_NOT_FOUND;\n\n}",
            "key_variables": [
               [
                  961,
                  "iter->next"
               ]
            ]
         }
      ],
      "src/font_loader/font_loader_bitmap.c": [
         {
            "type": "func",
            "name": "font_bitmap_get_vmetrics",
            "line_range": [
               86,
               96
            ],
            "source_code": "static font_vmetrics_t font_bitmap_get_vmetrics(font_t* f, font_size_t font_size) {\n  font_vmetrics_t vmetrics;\n  font_bitmap_t* font = (font_bitmap_t*)f;\n  font_bitmap_header_t* header = (font_bitmap_header_t*)(font->buff);\n\n  vmetrics.ascent = header->ascent;\n  vmetrics.descent = header->descent;\n  vmetrics.line_gap = header->line_gap;\n\n  return vmetrics;\n}",
            "key_variables": [
               [
                  92,
                  "header->ascent"
               ],
               [
                  93,
                  "header->descent"
               ],
               [
                  94,
                  "header->line_gap"
               ]
            ]
         }
      ],
      "src/font_loader/font_loader_ft.c": [
         {
            "type": "block",
            "name": "block",
            "line_range": "",
            "source_code": "",
            "key_variables": [
               86,
               "face->glyph"
            ]
         },
         {
            "type": "func",
            "name": "glyph_ft_create",
            "line_range": [
               90,
               94
            ],
            "source_code": "static glyph_ft_t* glyph_ft_create(void) {\n\n  return TKMEM_ZALLOC(glyph_ft_t);\n\n}",
            "key_variables": [
               [
                  93,
                  "glyf->bitmap_left"
               ],
               [
                  94,
                  "glyf->bitmap_top"
               ]
            ]
         }
      ],
      "src/font_loader/font_loader_stb.c": [
         {
            "type": "func",
            "name": "font_stb_gray_to_mono_by_threshold",
            "line_range": [
               48,
               79
            ],
            "source_code": "static ret_t font_stb_gray_to_mono_by_threshold(const glyph_t* gray, glyph_t* mono,\n                                                uint32_t threshold) {\n  return_value_if_fail(gray != NULL && mono != NULL && gray->format == GLYPH_FMT_ALPHA,\n                       RET_BAD_PARAMS);\n  uint32_t i = 0;\n  uint32_t j = 0;\n  uint16_t h = gray->h;\n  uint16_t w = gray->w;\n\n  mono->format = GLYPH_FMT_MONO;\n  mono->h = h;\n  mono->w = w;\n  mono->pitch = ((mono->w + 15) >> 4) << 1;\n  mono->x = gray->x;\n  mono->y = gray->y;\n  mono->advance = gray->advance;\n\n  uint32_t nmemb = mono->pitch * h;\n  uint8_t* bitmap = TKMEM_CALLOC(nmemb, sizeof(uint8_t));\n  return_value_if_fail(bitmap != NULL, RET_OOM);\n  for (j = 0; j < h; ++j) {\n    for (i = 0; i < w; ++i) {\n      if (gray->data[w * j + i] > threshold) {\n        uint32_t offset = j * mono->pitch + (i >> 3);\n        uint32_t offset_bit = 7 - (i % 8);\n        bitmap[offset] += 0x1 << offset_bit;\n      }\n    }\n  }\n  mono->data = bitmap;\n  return RET_OK;\n}",
            "key_variables": [
               [
                  55,
                  "gray->h"
               ],
               [
                  56,
                  "gray->w"
               ],
               [
                  62,
                  "gray->x"
               ],
               [
                  63,
                  "gray->y"
               ],
               [
                  64,
                  "gray->advance"
               ]
            ]
         },
         {
            "type": "func",
            "name": "font_stb_get_vmetrics",
            "line_range": [
               86,
               97
            ],
            "source_code": "static font_vmetrics_t font_stb_get_vmetrics(font_t* f, font_size_t font_size) {\n  font_vmetrics_t vmetrics;\n  font_stb_t* font = (font_stb_t*)f;\n  stbtt_fontinfo* sf = &(font->stb_font);\n  float scale = stbtt_ScaleForPixelHeight(sf, font_size);\n\n  vmetrics.ascent = scale * font->ascent;\n  vmetrics.descent = scale * font->descent;\n  vmetrics.line_gap = scale * font->line_gap;\n\n  return vmetrics;\n}",
            "key_variables": [
               [
                  93,
                  "font->ascent"
               ],
               [
                  94,
                  "font->descent"
               ],
               [
                  95,
                  "font->line_gap"
               ]
            ]
         }
      ],
      "src/fscript_ext/fscript_array.c": [
         {
            "type": "func",
            "name": "func_array_create",
            "line_range": [
               18,
               32
            ],
            "source_code": "static ret_t func_array_create(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  uint32_t i = 0;\n  object_t* obj = object_array_create();\n  value_set_object(result, obj);\n  result->free_handle = TRUE;\n\n  for (i = 0; i < args->size; i++) {\n    ret_t ret = object_array_push(obj, args->args + i);\n    if (ret != RET_OK) {\n      break;\n    }\n  }\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  25,
                  "args->size"
               ]
            ]
         },
         {
            "type": "func",
            "name": "func_array_dup",
            "line_range": [
               65,
               97
            ],
            "source_code": "static ret_t func_array_dup(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  uint32_t start = 0;\n  uint32_t end = 0;\n  object_t* obj = NULL;\n  object_t* dup = NULL;\n  object_array_t* arr = NULL;\n  FSCRIPT_FUNC_CHECK(args->size >= 1, RET_BAD_PARAMS);\n\n  obj = value_object(args->args);\n  arr = OBJECT_ARRAY(obj);\n  return_value_if_fail(arr != NULL, RET_BAD_PARAMS);\n\n  if (arr->size == 0) {\n    dup = object_array_clone(obj);\n  } else {\n    if (args->size == 1) {\n      start = 0;\n      end = arr->size;\n    } else if (args->size == 2) {\n      start = value_uint32(args->args + 1);\n      end = arr->size;\n    } else {\n      start = value_uint32(args->args + 1);\n      end = value_uint32(args->args + 2);\n    }\n    dup = object_array_dup(obj, start, end);\n  }\n  value_set_object(result, dup);\n  return_value_if_fail(dup != NULL, RET_BAD_PARAMS);\n  result->free_handle = TRUE;\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  83,
                  "arr->size"
               ],
               [
                  86,
                  "arr->size"
               ]
            ]
         },
         {
            "type": "func",
            "name": "func_array_create_repeated",
            "line_range": [
               99,
               119
            ],
            "source_code": "static ret_t func_array_create_repeated(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  uint32_t i = 0;\n  uint32_t n = 0;\n  object_t* obj = NULL;\n  FSCRIPT_FUNC_CHECK(args->size == 2, RET_BAD_PARAMS);\n\n  obj = object_array_create();\n  value_set_object(result, obj);\n  return_value_if_fail(obj != NULL, RET_BAD_PARAMS);\n\n  result->free_handle = TRUE;\n  n = value_uint32(args->args + 1);\n  for (i = 0; i < n; i++) {\n    ret_t ret = object_array_push(obj, args->args);\n    if (ret != RET_OK) {\n      break;\n    }\n  }\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  131,
                  "args->size"
               ]
            ]
         },
         {
            "type": "func",
            "name": "func_array_shift",
            "line_range": [
               157,
               171
            ],
            "source_code": "static ret_t func_array_shift(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  object_t* obj = NULL;\n  object_array_t* arr = NULL;\n  FSCRIPT_FUNC_CHECK(args->size == 1, RET_BAD_PARAMS);\n  obj = value_object(args->args);\n  arr = OBJECT_ARRAY(obj);\n  return_value_if_fail(arr != NULL, RET_BAD_PARAMS);\n\n  if (arr->size > 0) {\n    return object_array_shift(obj, result);\n  } else {\n    result->type = VALUE_TYPE_INVALID;\n    return RET_OK;\n  }\n}",
            "key_variables": [
               [
                  185,
                  "arr->size"
               ]
            ]
         },
         {
            "type": "func",
            "name": "func_array_set",
            "line_range": [
               173,
               191
            ],
            "source_code": "static ret_t func_array_set(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  int32_t index = 0;\n  object_t* obj = NULL;\n  object_array_t* arr = NULL;\n  FSCRIPT_FUNC_CHECK(args->size == 3, RET_BAD_PARAMS);\n  obj = value_object(args->args);\n  arr = OBJECT_ARRAY(obj);\n  return_value_if_fail(arr != NULL, RET_BAD_PARAMS);\n\n  index = value_int(args->args + 1);\n  if (index < 0) {\n    index += arr->size;\n  }\n  return_value_if_fail(index >= 0 && index < arr->size, RET_BAD_PARAMS);\n\n  value_set_bool(result, object_array_set(obj, index, args->args + 2) == RET_OK);\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  205,
                  "arr->size"
               ],
               [
                  223,
                  "arr->size"
               ]
            ]
         },
         {
            "type": "func",
            "name": "func_array_get",
            "line_range": [
               193,
               209
            ],
            "source_code": "static ret_t func_array_get(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  int32_t index = 0;\n  object_t* obj = NULL;\n  object_array_t* arr = NULL;\n  FSCRIPT_FUNC_CHECK(args->size == 2, RET_BAD_PARAMS);\n  obj = value_object(args->args);\n  arr = OBJECT_ARRAY(obj);\n  return_value_if_fail(arr != NULL, RET_BAD_PARAMS);\n\n  index = value_int(args->args + 1);\n  if (index < 0) {\n    index += arr->size;\n  }\n  return_value_if_fail(index >= 0 && index < arr->size, RET_BAD_PARAMS);\n\n  return object_array_get(obj, index, result);\n}",
            "key_variables": [
               [
                  243,
                  "arr->size"
               ]
            ]
         },
         {
            "type": "func",
            "name": "func_array_get_and_remove",
            "line_range": [
               251,
               267
            ],
            "source_code": "static ret_t func_array_get_and_remove(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  int32_t index = 0;\n  object_t* obj = NULL;\n  object_array_t* arr = NULL;\n  FSCRIPT_FUNC_CHECK(args->size == 2, RET_BAD_PARAMS);\n  obj = value_object(args->args);\n  arr = OBJECT_ARRAY(obj);\n  return_value_if_fail(arr != NULL, RET_BAD_PARAMS);\n\n  index = value_int(args->args + 1);\n  if (index < 0) {\n    index += arr->size;\n  }\n  return_value_if_fail(index >= 0 && index < arr->size, RET_BAD_PARAMS);\n\n  return object_array_get_and_remove(obj, index, result);\n}",
            "key_variables": [
               [
                  263,
                  "arr->size"
               ]
            ]
         }
      ],
      "src/fscript_ext/fscript_bits.c": [
         {
            "type": "func",
            "name": "func_lshift",
            "line_range": [
               24,
               74
            ],
            "source_code": "static ret_t func_lshift(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  uint32_t n = 0;\n  value_t* value = NULL;\n  ret_t ret = RET_OK;\n\n  result->type = VALUE_TYPE_INVALID;\n  FSCRIPT_FUNC_CHECK(args->size == 2, RET_BAD_PARAMS);\n  value = args->args;\n  n = value_uint32(args->args + 1);\n\n  switch (value->type) {\n    case VALUE_TYPE_INT8: {\n      value_set_int8(result, value_int8(value) << n);\n      break;\n    }\n    case VALUE_TYPE_UINT8: {\n      value_set_uint8(result, value_uint8(value) << n);\n      break;\n    }\n    case VALUE_TYPE_INT16: {\n      value_set_int16(result, value_int16(value) << n);\n      break;\n    }\n    case VALUE_TYPE_UINT16: {\n      value_set_uint16(result, value_uint16(value) << n);\n      break;\n    }\n    case VALUE_TYPE_INT32: {\n      value_set_int32(result, value_int32(value) << n);\n      break;\n    }\n    case VALUE_TYPE_UINT32: {\n      value_set_uint32(result, value_uint32(value) << n);\n      break;\n    }\n    case VALUE_TYPE_INT64: {\n      value_set_int64(result, value_int64(value) << n);\n      break;\n    }\n    case VALUE_TYPE_UINT64: {\n      value_set_uint64(result, value_uint64(value) << n);\n      break;\n    }\n    default: {\n      ret = RET_BAD_PARAMS;\n      break;\n    }\n  }\n\n  return ret;\n}",
            "key_variables": [
               [
                  32,
                  "args->args"
               ]
            ]
         },
         {
            "type": "func",
            "name": "func_rshift",
            "line_range": [
               76,
               126
            ],
            "source_code": "static ret_t func_rshift(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  uint32_t n = 0;\n  value_t* value = NULL;\n  ret_t ret = RET_OK;\n\n  result->type = VALUE_TYPE_INVALID;\n  FSCRIPT_FUNC_CHECK(args->size == 2, RET_BAD_PARAMS);\n  value = args->args;\n  n = value_uint32(args->args + 1);\n\n  switch (value->type) {\n    case VALUE_TYPE_INT8: {\n      value_set_int8(result, value_int8(value) >> n);\n      break;\n    }\n    case VALUE_TYPE_UINT8: {\n      value_set_uint8(result, value_uint8(value) >> n);\n      break;\n    }\n    case VALUE_TYPE_INT16: {\n      value_set_int16(result, value_int16(value) >> n);\n      break;\n    }\n    case VALUE_TYPE_UINT16: {\n      value_set_uint16(result, value_uint16(value) >> n);\n      break;\n    }\n    case VALUE_TYPE_INT32: {\n      value_set_int32(result, value_int32(value) >> n);\n      break;\n    }\n    case VALUE_TYPE_UINT32: {\n      value_set_uint32(result, value_uint32(value) >> n);\n      break;\n    }\n    case VALUE_TYPE_INT64: {\n      value_set_int64(result, value_int64(value) >> n);\n      break;\n    }\n    case VALUE_TYPE_UINT64: {\n      value_set_uint64(result, value_uint64(value) >> n);\n      break;\n    }\n    default: {\n      ret = RET_BAD_PARAMS;\n      break;\n    }\n  }\n\n  return ret;\n}",
            "key_variables": [
               [
                  84,
                  "args->args"
               ]
            ]
         },
         {
            "type": "func",
            "name": "func_bit_set",
            "line_range": [
               128,
               194
            ],
            "source_code": "static ret_t func_bit_set(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  uint32_t n = 0;\n  value_t* value = NULL;\n  ret_t ret = RET_OK;\n\n  result->type = VALUE_TYPE_INVALID;\n  FSCRIPT_FUNC_CHECK(args->size == 2, RET_BAD_PARAMS);\n  value = args->args;\n  n = value_uint32(args->args + 1);\n\n  switch (value->type) {\n    case VALUE_TYPE_INT8: {\n      int8_t vv = value_int8(value);\n      TK_SET_BIT(vv, n);\n      value_set_int8(result, vv);\n      break;\n    }\n    case VALUE_TYPE_UINT8: {\n      uint8_t vv = value_uint8(value);\n      TK_SET_BIT(vv, n);\n      value_set_uint8(result, vv);\n      break;\n    }\n    case VALUE_TYPE_INT16: {\n      int16_t vv = value_int16(value);\n      TK_SET_BIT(vv, n);\n      value_set_int16(result, vv);\n      break;\n    }\n    case VALUE_TYPE_UINT16: {\n      uint16_t vv = value_uint16(value);\n      TK_SET_BIT(vv, n);\n      value_set_uint16(result, vv);\n      break;\n    }\n    case VALUE_TYPE_INT32: {\n      int32_t vv = value_int32(value);\n      TK_SET_BIT(vv, n);\n      value_set_int32(result, vv);\n      break;\n    }\n    case VALUE_TYPE_UINT32: {\n      uint32_t vv = value_uint32(value);\n      TK_SET_BIT(vv, n);\n      value_set_uint32(result, vv);\n      break;\n    }\n    case VALUE_TYPE_INT64: {\n      int64_t vv = value_int64(value);\n      TK_SET_BIT(vv, n);\n      value_set_int64(result, vv);\n      break;\n    }\n    case VALUE_TYPE_UINT64: {\n      uint64_t vv = value_uint64(value);\n      TK_SET_BIT(vv, n);\n      value_set_uint64(result, vv);\n      break;\n    }\n    default: {\n      ret = RET_BAD_PARAMS;\n      break;\n    }\n  }\n\n  return ret;\n}",
            "key_variables": [
               [
                  136,
                  "args->args"
               ],
               [
                  204,
                  "args->args"
               ]
            ]
         },
         {
            "type": "func",
            "name": "func_bit_clear",
            "line_range": [
               196,
               262
            ],
            "source_code": "static ret_t func_bit_clear(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  uint32_t n = 0;\n  value_t* value = NULL;\n  ret_t ret = RET_OK;\n\n  result->type = VALUE_TYPE_INVALID;\n  FSCRIPT_FUNC_CHECK(args->size == 2, RET_BAD_PARAMS);\n  value = args->args;\n  n = value_uint32(args->args + 1);\n\n  switch (value->type) {\n    case VALUE_TYPE_INT8: {\n      int8_t vv = value_int8(value);\n      TK_CLEAR_BIT(vv, n);\n      value_set_int8(result, vv);\n      break;\n    }\n    case VALUE_TYPE_UINT8: {\n      uint8_t vv = value_uint8(value);\n      TK_CLEAR_BIT(vv, n);\n      value_set_uint8(result, vv);\n      break;\n    }\n    case VALUE_TYPE_INT16: {\n      int16_t vv = value_int16(value);\n      TK_CLEAR_BIT(vv, n);\n      value_set_int16(result, vv);\n      break;\n    }\n    case VALUE_TYPE_UINT16: {\n      uint16_t vv = value_uint16(value);\n      TK_CLEAR_BIT(vv, n);\n      value_set_uint16(result, vv);\n      break;\n    }\n    case VALUE_TYPE_INT32: {\n      int32_t vv = value_int32(value);\n      TK_CLEAR_BIT(vv, n);\n      value_set_int32(result, vv);\n      break;\n    }\n    case VALUE_TYPE_UINT32: {\n      uint32_t vv = value_uint32(value);\n      TK_CLEAR_BIT(vv, n);\n      value_set_uint32(result, vv);\n      break;\n    }\n    case VALUE_TYPE_INT64: {\n      int64_t vv = value_int64(value);\n      TK_CLEAR_BIT(vv, n);\n      value_set_int64(result, vv);\n      break;\n    }\n    case VALUE_TYPE_UINT64: {\n      uint64_t vv = value_uint64(value);\n      TK_CLEAR_BIT(vv, n);\n      value_set_uint64(result, vv);\n      break;\n    }\n    default: {\n      ret = RET_BAD_PARAMS;\n      break;\n    }\n  }\n\n  return ret;\n}",
            "key_variables": [
               [
                  272,
                  "args->args"
               ]
            ]
         },
         {
            "type": "func",
            "name": "func_bit_get",
            "line_range": [
               332,
               398
            ],
            "source_code": "static ret_t func_bit_get(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  uint32_t n = 0;\n  value_t* value = NULL;\n  ret_t ret = RET_OK;\n\n  result->type = VALUE_TYPE_INVALID;\n  FSCRIPT_FUNC_CHECK(args->size == 2, RET_BAD_PARAMS);\n  value = args->args;\n  n = value_uint32(args->args + 1);\n\n  switch (value->type) {\n    case VALUE_TYPE_INT8: {\n      int8_t vv = value_int8(value);\n      bool_t bit = TK_TEST_BIT(vv, n);\n      value_set_bool(result, bit);\n      break;\n    }\n    case VALUE_TYPE_UINT8: {\n      uint8_t vv = value_uint8(value);\n      bool_t bit = TK_TEST_BIT(vv, n);\n      value_set_bool(result, bit);\n      break;\n    }\n    case VALUE_TYPE_INT16: {\n      int16_t vv = value_int16(value);\n      bool_t bit = TK_TEST_BIT(vv, n);\n      value_set_bool(result, bit);\n      break;\n    }\n    case VALUE_TYPE_UINT16: {\n      uint16_t vv = value_uint16(value);\n      bool_t bit = TK_TEST_BIT(vv, n);\n      value_set_bool(result, bit);\n      break;\n    }\n    case VALUE_TYPE_INT32: {\n      int32_t vv = value_int32(value);\n      bool_t bit = TK_TEST_BIT(vv, n);\n      value_set_bool(result, bit);\n      break;\n    }\n    case VALUE_TYPE_UINT32: {\n      uint32_t vv = value_uint32(value);\n      bool_t bit = TK_TEST_BIT(vv, n);\n      value_set_bool(result, bit);\n      break;\n    }\n    case VALUE_TYPE_INT64: {\n      int64_t vv = value_int64(value);\n      bool_t bit = TK_TEST_BIT(vv, n);\n      value_set_bool(result, bit);\n      break;\n    }\n    case VALUE_TYPE_UINT64: {\n      uint64_t vv = value_uint64(value);\n      bool_t bit = TK_TEST_BIT(vv, n);\n      value_set_bool(result, bit);\n      break;\n    }\n    default: {\n      ret = RET_BAD_PARAMS;\n      break;\n    }\n  }\n\n  return ret;\n}",
            "key_variables": [
               [
                  340,
                  "args->args"
               ]
            ]
         }
      ],
      "src/fscript_ext/fscript_ext.c": [
         {
            "type": "func",
            "name": "func_char_at",
            "line_range": [
               155,
               182
            ],
            "source_code": "static ret_t func_char_at(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  wstr_t wstr;\n  int32_t index = 0;\n  ret_t ret = RET_OK;\n  const char* str = NULL;\n  FSCRIPT_FUNC_CHECK(args->size == 2, RET_BAD_PARAMS);\n  str = value_str(args->args);\n  return_value_if_fail(str != NULL && *str, RET_BAD_PARAMS);\n  index = value_int(args->args + 1);\n\n  wstr_init(&wstr, 0);\n  return_value_if_fail(wstr_set_utf8(&wstr, str) == RET_OK, RET_OOM);\n\n  if (index < 0) {\n    index += wstr.size;\n  }\n\n  if (index >= 0 && index < wstr.size) {\n    str_t* str = &(fscript->str);\n    str_from_wstr_with_len(str, wstr.str + index, 1);\n    value_set_str(result, str->str);\n  } else {\n    ret = RET_FAIL;\n  }\n  wstr_reset(&wstr);\n\n  return ret;\n}",
            "key_variables": [
               [
                  197,
                  "text[128]"
               ]
            ]
         }
      ],
      "src/fscript_ext/fscript_fs.c": [
         {
            "type": "func",
            "name": "func_file_write",
            "line_range": [
               55,
               83
            ],
            "source_code": "static ret_t func_file_write(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  value_t* v = NULL;\n  ret_t ret = RET_FAIL;\n  const char* filename = NULL;\n  FSCRIPT_FUNC_CHECK(args->size > 1, RET_BAD_PARAMS);\n  filename = value_str(args->args);\n  FSCRIPT_FUNC_CHECK(filename != NULL, RET_BAD_PARAMS);\n\n  v = args->args + 1;\n  if (args->size == 2) {\n    if (v->type == VALUE_TYPE_STRING) {\n      const char* content = value_str(v);\n      ret = file_write(filename, content, tk_strlen(content));\n    } else if (v->type == VALUE_TYPE_BINARY) {\n      binary_data_t* bin = value_binary_data(v);\n      FSCRIPT_FUNC_CHECK(bin != NULL, RET_BAD_PARAMS);\n      ret = file_write(filename, bin->data, bin->size);\n    }\n  } else {\n    const char* content = (const char*)value_pointer(v);\n    uint32_t size = args->size > 2 ? value_uint32(args->args + 2) : 0;\n    if (size > 0 && content != NULL) {\n      ret = file_write(filename, content, size);\n    }\n  }\n\n  value_set_bool(result, ret == RET_OK);\n  return ret;\n}",
            "key_variables": [
               [
                  108,
                  "bin->data"
               ],
               [
                  109,
                  "bin->size"
               ]
            ]
         },
         {
            "type": "func",
            "name": "func_path_remove",
            "line_range": [
               286,
               295
            ],
            "source_code": "static ret_t func_path_remove(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  const char* filename = NULL;\n  FSCRIPT_FUNC_CHECK(args->size == 1, RET_BAD_PARAMS);\n  filename = value_str(args->args);\n  FSCRIPT_FUNC_CHECK(filename != NULL, RET_BAD_PARAMS);\n\n  value_set_bool(result, fs_remove_dir_r(os_fs(), filename) == RET_OK);\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  310,
                  "path[MAX_PATH + 1]"
               ]
            ]
         },
         {
            "type": "func",
            "name": "func_path_create",
            "line_range": [
               297,
               306
            ],
            "source_code": "static ret_t func_path_create(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  const char* filename = NULL;\n  FSCRIPT_FUNC_CHECK(args->size == 1, RET_BAD_PARAMS);\n  filename = value_str(args->args);\n  FSCRIPT_FUNC_CHECK(filename != NULL, RET_BAD_PARAMS);\n\n  value_set_bool(result, fs_create_dir_r(os_fs(), filename) == RET_OK);\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  322,
                  "path[MAX_PATH + 1]"
               ]
            ]
         },
         {
            "type": "func",
            "name": "func_path_get_cwd",
            "line_range": [
               320,
               330
            ],
            "source_code": "static ret_t func_path_get_cwd(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  char path[MAX_PATH + 1];\n  FSCRIPT_FUNC_CHECK(path != NULL, RET_BAD_PARAMS);\n\n  if (fs_get_cwd(os_fs(), path) == RET_OK) {\n    value_dup_str(result, path);\n    return RET_OK;\n  }\n\n  return RET_FAIL;\n}",
            "key_variables": [
               [
                  334,
                  "path[MAX_PATH + 1]"
               ],
               [
                  347,
                  "path[MAX_PATH + 1]"
               ]
            ]
         },
         {
            "type": "func",
            "name": "func_path_get_temp",
            "line_range": [
               332,
               342
            ],
            "source_code": "static ret_t func_path_get_temp(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  char path[MAX_PATH + 1];\n  FSCRIPT_FUNC_CHECK(path != NULL, RET_BAD_PARAMS);\n\n  if (fs_get_temp_path(os_fs(), path) == RET_OK) {\n    value_dup_str(result, path);\n    return RET_OK;\n  }\n\n  return RET_FAIL;\n}",
            "key_variables": [
               [
                  359,
                  "path[MAX_PATH + 1]"
               ]
            ]
         }
      ],
      "src/fscript_ext/fscript_json.c": [
         {
            "type": "func",
            "name": "func_json_load_ex",
            "line_range": [
               28,
               63
            ],
            "source_code": "static ret_t func_json_load_ex(fscript_t* fscript, fscript_args_t* args, value_t* result,\n                               json_load_t load) {\n  value_t* v = NULL;\n  uint32_t size = 0;\n  object_t* obj = NULL;\n  const void* data = NULL;\n  char url[MAX_PATH + 1];\n  FSCRIPT_FUNC_CHECK(args->size >= 1, RET_BAD_PARAMS);\n\n  if (args->size == 1) {\n    v = args->args;\n    if (v->type == VALUE_TYPE_STRING) {\n      data = value_str(v);\n      FSCRIPT_FUNC_CHECK(data != NULL, RET_BAD_PARAMS);\n      size = strlen(data);\n    } else if (v->type == VALUE_TYPE_BINARY) {\n      binary_data_t* bin = value_binary_data(v);\n      FSCRIPT_FUNC_CHECK(bin != NULL, RET_BAD_PARAMS);\n      data = bin->data;\n      size = bin->size;\n    }\n  } else {\n    data = value_pointer(v);\n    size = value_uint32(args->args + 1);\n  }\n\n  if (data != NULL && size > 0) {\n    data_reader_mem_build_url(data, size, url);\n    obj = load(url, FALSE);\n    value_set_object(result, obj);\n    result->free_handle = TRUE;\n    return RET_OK;\n  }\n\n  return RET_FAIL;\n}",
            "key_variables": [
               [
                  35,
                  "url[MAX_PATH + 1]"
               ],
               [
                  39,
                  "args->args"
               ],
               [
                  47,
                  "bin->data"
               ],
               [
                  48,
                  "bin->size"
               ]
            ]
         },
         {
            "type": "func",
            "name": "func_json_save_ex",
            "line_range": [
               65,
               89
            ],
            "source_code": "static ret_t func_json_save_ex(fscript_t* fscript, fscript_args_t* args, value_t* result,\n                               json_save_t save, uint32_t result_type) {\n  wbuffer_t wb;\n  object_t* obj = NULL;\n  char url[MAX_PATH + 1];\n  wbuffer_init_extendable(&wb);\n  FSCRIPT_FUNC_CHECK(args->size == 1, RET_BAD_PARAMS);\n  obj = value_object(args->args);\n  FSCRIPT_FUNC_CHECK(obj != NULL, RET_BAD_PARAMS);\n  FSCRIPT_FUNC_CHECK(wbuffer_extend_capacity(&wb, 256) == RET_OK, RET_OOM);\n\n  data_writer_wbuffer_build_url(&wb, url);\n  if (save(obj, url) == RET_OK) {\n    if (result_type == VALUE_TYPE_BINARY) {\n      value_set_binary_data(result, wb.data, wb.cursor);\n    } else if (result_type == VALUE_TYPE_STRING) {\n      value_set_str(result, (const char*)wb.data);\n    }\n    result->free_handle = TRUE;\n    return RET_OK;\n  }\n  wbuffer_deinit(&wb);\n\n  return RET_FAIL;\n}",
            "key_variables": [
               [
                  70,
                  "url[MAX_PATH + 1]"
               ]
            ]
         }
      ],
      "src/fscript_ext/fscript_ostream.c": [
         {
            "type": "func",
            "name": "func_ostream_flush",
            "line_range": [
               48,
               57
            ],
            "source_code": "static ret_t func_ostream_flush(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  tk_ostream_t* ostream = NULL;\n  FSCRIPT_FUNC_CHECK(args->size == 1, RET_BAD_PARAMS);\n  ostream = TK_OSTREAM(value_object(args->args));\n  FSCRIPT_FUNC_CHECK(ostream != NULL, RET_BAD_PARAMS);\n\n  value_set_bool(result, tk_ostream_flush(ostream) == RET_OK);\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  69,
                  "args->size"
               ]
            ]
         },
         {
            "type": "func",
            "name": "func_ostream_write_uint8",
            "line_range": [
               59,
               76
            ],
            "source_code": "static ret_t func_ostream_write_uint8(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  uint32_t i = 0;\n  int32_t ret = 0;\n  tk_ostream_t* ostream = NULL;\n  value_set_uint32(result, 0);\n  FSCRIPT_FUNC_CHECK(args->size > 1, RET_BAD_PARAMS);\n  ostream = TK_OSTREAM(value_object(args->args));\n  FSCRIPT_FUNC_CHECK(ostream != NULL, RET_BAD_PARAMS);\n\n  for (i = 1; i < args->size; i++) {\n    value_t* iter = args->args + i;\n    uint8_t v = value_uint8(iter);\n    ret += my_ostream_write(ostream, &v, sizeof(v));\n  }\n  value_set_int32(result, ret);\n\n  return ret > 0 ? RET_OK : RET_FAIL;\n}",
            "key_variables": [
               [
                  88,
                  "args->size"
               ]
            ]
         },
         {
            "type": "func",
            "name": "func_ostream_write_uint32",
            "line_range": [
               97,
               114
            ],
            "source_code": "static ret_t func_ostream_write_uint32(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  uint32_t i = 0;\n  int32_t ret = 0;\n  tk_ostream_t* ostream = NULL;\n  value_set_uint32(result, 0);\n  FSCRIPT_FUNC_CHECK(args->size > 1, RET_BAD_PARAMS);\n  ostream = TK_OSTREAM(value_object(args->args));\n  FSCRIPT_FUNC_CHECK(ostream != NULL, RET_BAD_PARAMS);\n\n  for (i = 1; i < args->size; i++) {\n    value_t* iter = args->args + i;\n    uint32_t v = value_uint32(iter);\n    ret += my_ostream_write(ostream, &v, sizeof(v));\n  }\n  value_set_int32(result, ret);\n\n  return ret > 0 ? RET_OK : RET_FAIL;\n}",
            "key_variables": [
               [
                  107,
                  "args->size"
               ],
               [
                  126,
                  "args->size"
               ]
            ]
         },
         {
            "type": "func",
            "name": "func_ostream_write_uint64",
            "line_range": [
               116,
               133
            ],
            "source_code": "static ret_t func_ostream_write_uint64(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  uint32_t i = 0;\n  int32_t ret = 0;\n  tk_ostream_t* ostream = NULL;\n  value_set_uint32(result, 0);\n  FSCRIPT_FUNC_CHECK(args->size > 1, RET_BAD_PARAMS);\n  ostream = TK_OSTREAM(value_object(args->args));\n  FSCRIPT_FUNC_CHECK(ostream != NULL, RET_BAD_PARAMS);\n\n  for (i = 1; i < args->size; i++) {\n    value_t* iter = args->args + i;\n    uint64_t v = value_uint64(iter);\n    ret += my_ostream_write(ostream, &v, sizeof(v));\n  }\n  value_set_int32(result, ret);\n\n  return ret > 0 ? RET_OK : RET_FAIL;\n}",
            "key_variables": [
               [
                  145,
                  "args->size"
               ],
               [
                  164,
                  "args->size"
               ]
            ]
         },
         {
            "type": "func",
            "name": "func_ostream_write_double",
            "line_range": [
               154,
               171
            ],
            "source_code": "static ret_t func_ostream_write_double(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  uint32_t i = 0;\n  int32_t ret = 0;\n  tk_ostream_t* ostream = NULL;\n  value_set_uint32(result, 0);\n  FSCRIPT_FUNC_CHECK(args->size > 1, RET_BAD_PARAMS);\n  ostream = TK_OSTREAM(value_object(args->args));\n  FSCRIPT_FUNC_CHECK(ostream != NULL, RET_BAD_PARAMS);\n\n  for (i = 1; i < args->size; i++) {\n    value_t* iter = args->args + i;\n    double v = value_double(iter);\n    ret += my_ostream_write(ostream, &v, sizeof(v));\n  }\n  value_set_int32(result, ret);\n\n  return ret > 0 ? RET_OK : RET_FAIL;\n}",
            "key_variables": [
               [
                  175,
                  "str[64]"
               ],
               [
                  228,
                  "bin->data"
               ]
            ]
         }
      ],
      "src/fscript_ext/fscript_rbuffer.c": [
         {
            "type": "func",
            "name": "func_rbuffer_read_double",
            "line_range": [
               216,
               228
            ],
            "source_code": "static ret_t func_rbuffer_read_double(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  double v = 0;\n  ret_t ret = RET_OK;\n  object_rbuffer_t* obj = NULL;\n  FSCRIPT_FUNC_CHECK(args->size == 1, RET_BAD_PARAMS);\n  obj = OBJECT_RBUFFER(value_object(args->args));\n  FSCRIPT_FUNC_CHECK(obj != NULL && obj->rbuffer != NULL, RET_BAD_PARAMS);\n\n  ret = rbuffer_read_double(obj->rbuffer, &v);\n  value_set_double(result, v);\n\n  return ret;\n}",
            "key_variables": [
               [
                  256,
                  "rbuffer->cursor"
               ]
            ]
         }
      ],
      "src/fscript_ext/fscript_typed_array.c": [
         {
            "type": "func",
            "name": "func_typed_array_push",
            "line_range": [
               66,
               83
            ],
            "source_code": "static ret_t func_typed_array_push(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  uint32_t i = 0;\n  typed_array_t* arr = NULL;\n  FSCRIPT_FUNC_CHECK(args->size > 1, RET_BAD_PARAMS);\n  arr = get_typed_array(fscript, args);\n  return_value_if_fail(arr != NULL, RET_BAD_PARAMS);\n\n  for (i = 1; i < args->size; i++) {\n    ret_t ret = typed_array_push(arr, args->args + i);\n    if (ret != RET_OK) {\n      break;\n    }\n  }\n\n  value_set_uint32(result, i - 1);\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  74,
                  "args->size"
               ]
            ]
         },
         {
            "type": "func",
            "name": "func_typed_array_remove",
            "line_range": [
               129,
               138
            ],
            "source_code": "static ret_t func_typed_array_remove(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  typed_array_t* arr = NULL;\n  FSCRIPT_FUNC_CHECK(args->size == 2, RET_BAD_PARAMS);\n  arr = get_typed_array(fscript, args);\n  return_value_if_fail(arr != NULL, RET_BAD_PARAMS);\n\n  value_set_bool(result, typed_array_remove(arr, value_uint32(args->args + 1)) == RET_OK);\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  155,
                  "buff[64]"
               ],
               [
                  166,
                  "arr->size"
               ]
            ]
         }
      ],
      "src/fscript_ext/fscript_utils.c": [
         {
            "type": "func",
            "name": "fargs_get_data_and_size",
            "line_range": [
               19,
               44
            ],
            "source_code": "ret_t fargs_get_data_and_size(fscript_args_t* args, const uint8_t** ret_data, uint32_t* ret_size) {\n  uint32_t size = 0;\n  const uint8_t* data = NULL;\n  if (args->size == 1) {\n    value_t* v = args->args;\n    if (v->type == VALUE_TYPE_BINARY) {\n      binary_data_t* bin = value_binary_data(v);\n      return_value_if_fail(bin != NULL, RET_BAD_PARAMS);\n      data = bin->data;\n      size = bin->size;\n    } else if (v->type == VALUE_TYPE_STRING) {\n      data = (const uint8_t*)value_str(args->args);\n      return_value_if_fail(data != NULL, RET_BAD_PARAMS);\n      size = strlen((const char*)data);\n    }\n  } else {\n    data = (const uint8_t*)value_pointer(args->args);\n    return_value_if_fail(data != NULL, RET_BAD_PARAMS);\n    size = value_int(args->args + 1);\n  }\n\n  *ret_data = data;\n  *ret_size = size;\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  24,
                  "args->args"
               ],
               [
                  28,
                  "bin->data"
               ],
               [
                  29,
                  "bin->size"
               ]
            ]
         }
      ],
      "src/fscript_ext/fscript_wbuffer.c": [
         {
            "type": "func",
            "name": "func_wbuffer_get_cursor",
            "line_range": [
               75,
               84
            ],
            "source_code": "static ret_t func_wbuffer_get_cursor(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  object_wbuffer_t* obj = NULL;\n  FSCRIPT_FUNC_CHECK(args->size == 1, RET_BAD_PARAMS);\n  obj = OBJECT_WBUFFER(value_object(args->args));\n  FSCRIPT_FUNC_CHECK(obj != NULL && obj->wbuffer != NULL, RET_BAD_PARAMS);\n\n  value_set_uint32(result, obj->wbuffer->cursor);\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  105,
                  "args->size"
               ]
            ]
         },
         {
            "type": "func",
            "name": "func_wbuffer_write_uint16",
            "line_range": [
               115,
               131
            ],
            "source_code": "static ret_t func_wbuffer_write_uint16(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  uint32_t i = 0;\n  object_wbuffer_t* obj = NULL;\n  FSCRIPT_FUNC_CHECK(args->size > 1, RET_BAD_PARAMS);\n  obj = OBJECT_WBUFFER(value_object(args->args));\n  FSCRIPT_FUNC_CHECK(obj != NULL && obj->wbuffer != NULL, RET_BAD_PARAMS);\n\n  for (i = 1; i < args->size; i++) {\n    value_t* iter = args->args + i;\n    if (wbuffer_write_uint16(obj->wbuffer, value_uint16(iter)) != RET_OK) {\n      break;\n    }\n  }\n  value_set_int32(result, (i - 1) * sizeof(uint16_t));\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  123,
                  "args->size"
               ],
               [
                  141,
                  "args->size"
               ]
            ]
         },
         {
            "type": "func",
            "name": "func_wbuffer_write_uint32",
            "line_range": [
               133,
               149
            ],
            "source_code": "static ret_t func_wbuffer_write_uint32(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  uint32_t i = 0;\n  object_wbuffer_t* obj = NULL;\n  FSCRIPT_FUNC_CHECK(args->size > 1, RET_BAD_PARAMS);\n  obj = OBJECT_WBUFFER(value_object(args->args));\n  FSCRIPT_FUNC_CHECK(obj != NULL && obj->wbuffer != NULL, RET_BAD_PARAMS);\n\n  for (i = 1; i < args->size; i++) {\n    value_t* iter = args->args + i;\n    if (wbuffer_write_uint32(obj->wbuffer, value_uint32(iter)) != RET_OK) {\n      break;\n    }\n  }\n  value_set_int32(result, (i - 1) * sizeof(uint32_t));\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  159,
                  "args->size"
               ],
               [
                  177,
                  "args->size"
               ]
            ]
         },
         {
            "type": "func",
            "name": "func_wbuffer_write_float",
            "line_range": [
               169,
               185
            ],
            "source_code": "static ret_t func_wbuffer_write_float(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  uint32_t i = 0;\n  object_wbuffer_t* obj = NULL;\n  FSCRIPT_FUNC_CHECK(args->size > 1, RET_BAD_PARAMS);\n  obj = OBJECT_WBUFFER(value_object(args->args));\n  FSCRIPT_FUNC_CHECK(obj != NULL && obj->wbuffer != NULL, RET_BAD_PARAMS);\n\n  for (i = 1; i < args->size; i++) {\n    value_t* iter = args->args + i;\n    if (wbuffer_write_float(obj->wbuffer, value_float32(iter)) != RET_OK) {\n      break;\n    }\n  }\n  value_set_int32(result, (i - 1) * sizeof(float));\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  195,
                  "args->size"
               ],
               [
                  214,
                  "args->size"
               ]
            ]
         },
         {
            "type": "func",
            "name": "func_wbuffer_write_double",
            "line_range": [
               187,
               203
            ],
            "source_code": "static ret_t func_wbuffer_write_double(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  uint32_t i = 0;\n  object_wbuffer_t* obj = NULL;\n  FSCRIPT_FUNC_CHECK(args->size > 1, RET_BAD_PARAMS);\n  obj = OBJECT_WBUFFER(value_object(args->args));\n  FSCRIPT_FUNC_CHECK(obj != NULL && obj->wbuffer != NULL, RET_BAD_PARAMS);\n\n  for (i = 1; i < args->size; i++) {\n    value_t* iter = args->args + i;\n    if (wbuffer_write_double(obj->wbuffer, value_double(iter)) != RET_OK) {\n      break;\n    }\n  }\n  value_set_int32(result, (i - 1) * sizeof(double));\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  243,
                  "bin->data"
               ],
               [
                  244,
                  "bin->size"
               ]
            ]
         }
      ],
      "src/fscript_ext/fscript_widget.c": [
         {
            "type": "func",
            "name": "find_target_widget",
            "line_range": [
               29,
               60
            ],
            "source_code": "static widget_t* find_target_widget(widget_t* widget, const char* path, uint32_t len) {\n  bool_t is_first = TRUE;\n  tokenizer_t tokenizer;\n  widget_t* iter = widget;\n  tokenizer_t* t = NULL;\n  return_value_if_fail(widget != NULL && path != NULL, NULL);\n  t = tokenizer_init(&tokenizer, path, len, \".\");\n  return_value_if_fail(t != NULL, NULL);\n\n  while (tokenizer_has_more(t) && iter != NULL) {\n    const char* name = tokenizer_next(t);\n    if (is_first) {\n      if (tk_str_eq(name, STR_PROP_PARENT)) {\n        iter = widget->parent;\n      } else if (tk_str_eq(name, STR_PROP_SELF)) {\n        iter = widget;\n      } else if (tk_str_eq(name, STR_PROP_WINDOW)) {\n        iter = widget_get_window(widget);\n      } else if (tk_str_eq(name, STR_PROP_WINDOW_MANAGER)) {\n        iter = widget_get_window_manager(widget);\n      } else {\n        iter = widget_child(iter, name);\n      }\n      is_first = FALSE;\n    } else {\n      iter = widget_child(iter, name);\n    }\n  }\n  tokenizer_deinit(t);\n\n  return iter;\n}",
            "key_variables": [
               [
                  43,
                  "widget->parent"
               ]
            ]
         },
         {
            "type": "func",
            "name": "to_widget",
            "line_range": [
               62,
               78
            ],
            "source_code": "static widget_t* to_widget(fscript_t* fscript, const value_t* v) {\n  if (v->type == VALUE_TYPE_STRING) {\n    widget_t* self = WIDGET(object_get_prop_pointer(fscript->obj, STR_PROP_SELF));\n    const char* path = value_str(v);\n    return_value_if_fail(path != NULL, NULL);\n\n    return find_target_widget(self, path, strlen(path));\n  } else if (v->type == VALUE_TYPE_POINTER) {\n    return WIDGET(value_pointer(v));\n  } else if (v->type == VALUE_TYPE_OBJECT) {\n    object_widget_t* o = OBJECT_WIDGET(value_object(v));\n    return_value_if_fail(o != NULL, NULL);\n    return o->widget;\n  } else {\n    return NULL;\n  }\n}",
            "key_variables": [
               [
                  75,
                  "o->widget"
               ]
            ]
         },
         {
            "type": "func",
            "name": "func_window_open",
            "line_range": [
               87,
               124
            ],
            "source_code": "static ret_t func_window_open(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  widget_t* widget = NULL;\n  const char* name = NULL;\n  object_t* obj_widget = NULL;\n  bool_t close_current = FALSE;\n  bool_t switch_to_if_exist = FALSE;\n  widget_t* wm = window_manager();\n  widget_t* self = WIDGET(object_get_prop_pointer(fscript->obj, STR_PROP_SELF));\n  widget_t* curr_win = widget_get_window(self);\n  FSCRIPT_FUNC_CHECK(args->size >= 1, RET_BAD_PARAMS);\n  name = value_str(args->args);\n  close_current = args->size > 1 ? value_bool(args->args + 1) : FALSE;\n  switch_to_if_exist = args->size > 2 ? value_bool(args->args + 2) : FALSE;\n  FSCRIPT_FUNC_CHECK(name != NULL, RET_BAD_PARAMS);\n\n  if (switch_to_if_exist) {\n    widget_t* widget = widget_child(wm, name);\n    if (widget != NULL) {\n      window_manager_switch_to(wm, curr_win, widget, close_current);\n      obj_widget = object_widget_create(widget);\n      value_set_object(result, obj_widget);\n      result->free_handle = TRUE;\n      return RET_OK;\n    }\n  }\n\n  if (close_current) {\n    widget = window_open_and_close(value_str(args->args), curr_win);\n  } else {\n    widget = window_open(value_str(args->args));\n  }\n\n  obj_widget = object_widget_create(widget);\n  value_set_object(result, obj_widget);\n  result->free_handle = TRUE;\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  131,
                  "args->args"
               ]
            ]
         }
      ],
      "src/graphic_buffer/graphic_buffer_default.c": [
         {
            "type": "func",
            "name": "graphic_buffer_default_is_valid_for",
            "line_range": [
               42,
               47
            ],
            "source_code": "static bool_t graphic_buffer_default_is_valid_for(graphic_buffer_t* buffer, bitmap_t* bitmap) {\n  graphic_buffer_default_t* b = GRAPHIC_BUFFER_DEFAULT(buffer);\n  return_value_if_fail(b != NULL && bitmap != NULL, FALSE);\n\n  return b->w == bitmap->w && b->h == bitmap->h;\n}",
            "key_variables": [
               [
                  47,
                  "bitmap->h"
               ]
            ]
         },
         {
            "type": "func",
            "name": "graphic_buffer_default_lock_for_read",
            "line_range": [
               49,
               54
            ],
            "source_code": "static uint8_t* graphic_buffer_default_lock_for_read(graphic_buffer_t* buffer) {\n  graphic_buffer_default_t* b = GRAPHIC_BUFFER_DEFAULT(buffer);\n  return_value_if_fail(b != NULL, NULL);\n\n  return b->data;\n}",
            "key_variables": [
               [
                  54,
                  "b->data"
               ]
            ]
         },
         {
            "type": "func",
            "name": "graphic_buffer_default_lock_for_write",
            "line_range": [
               56,
               61
            ],
            "source_code": "static uint8_t* graphic_buffer_default_lock_for_write(graphic_buffer_t* buffer) {\n  graphic_buffer_default_t* b = GRAPHIC_BUFFER_DEFAULT(buffer);\n  return_value_if_fail(b != NULL, NULL);\n\n  return b->data;\n}",
            "key_variables": [
               [
                  61,
                  "b->data"
               ]
            ]
         }
      ],
      "src/hal/linux/network_interface_linux.c": [
         {
            "type": "func",
            "name": "network_interface_linux_enable",
            "line_range": [
               42,
               50
            ],
            "source_code": "static ret_t network_interface_linux_enable(network_interface_t* interface) {\n  char command[128];\n  int ret;\n  return_value_if_fail(interface != NULL, RET_FAIL);\n  snprintf(command, sizeof(command), \"ifconfig %s up\", interface->interface_name);\n  ret = system(command);\n  if (WEXITSTATUS(ret) != 0) return RET_FAIL;\n  return RET_OK;\n}",
            "key_variables": [
               [
                  44,
                  "command[128]"
               ]
            ]
         },
         {
            "type": "func",
            "name": "network_interface_linux_disable",
            "line_range": [
               52,
               60
            ],
            "source_code": "static ret_t network_interface_linux_disable(network_interface_t* interface) {\n  char command[128];\n  int ret;\n  return_value_if_fail(interface != NULL, RET_FAIL);\n  snprintf(command, sizeof(command), \"ifconfig %s down\", interface->interface_name);\n  ret = system(command);\n  if (WEXITSTATUS(ret) != 0) return RET_FAIL;\n  return RET_OK;\n}",
            "key_variables": [
               [
                  54,
                  "command[128]"
               ]
            ]
         },
         {
            "type": "func",
            "name": "network_interface_linux_get_ipaddr",
            "line_range": [
               62,
               83
            ],
            "source_code": "static char* network_interface_linux_get_ipaddr(network_interface_t* interface) {\n  char ipstr[16];\n  uint8_t ipaddr[4];\n  struct ifreq ifr;\n  struct sockaddr_in* addr = NULL;\n  network_interface_linux_t* linux_network_interface = (network_interface_linux_t*)interface;\n\n  int fd = socket(PF_INET, SOCK_DGRAM, 0);\n  return_value_if_fail(fd > 0, NULL);\n  strcpy(ifr.ifr_name, interface->interface_name);\n  if (ioctl(fd, SIOCGIFADDR, &ifr) < 0) {\n    close(fd);\n    return NULL;\n  }\n  addr = (struct sockaddr_in*)&ifr.ifr_addr;\n  *((u_int32_t*)ipaddr) = addr->sin_addr.s_addr;\n  snprintf(ipstr, sizeof(ipstr), \"%d.%d.%d.%d\", ipaddr[0], ipaddr[1], ipaddr[2], ipaddr[3]);\n  close(fd);\n  if (linux_network_interface->ipaddr != NULL) TKMEM_FREE(linux_network_interface->ipaddr);\n  linux_network_interface->ipaddr = tk_strdup(ipstr);\n  return linux_network_interface->ipaddr;\n}",
            "key_variables": [
               [
                  64,
                  "ipstr[16]"
               ],
               [
                  65,
                  "ipaddr[4]"
               ],
               [
                  83,
                  "linux_network_interface->ipaddr"
               ],
               [
                  89,
                  "m[6]"
               ],
               [
                  90,
                  "macstr[18]"
               ],
               [
                  106,
                  "linux_network_interface->macaddr"
               ]
            ]
         },
         {
            "type": "func",
            "name": "network_interface_linux_eth_get_status",
            "line_range": [
               108,
               125
            ],
            "source_code": "static int network_interface_linux_eth_get_status(network_interface_t* interface) {\n  char carrier_path[128];\n  char carrier;\n  int fd;\n  snprintf(carrier_path, sizeof(carrier_path), \"/sys/class/net/%s/carrier\",\n           interface->interface_name);\n  fd = open(carrier_path, O_RDONLY);\n  return_value_if_fail(fd > 0, -1);\n  if (read(fd, &carrier, 1) <= 0) {\n    close(fd);\n    return 0;\n  }\n  close(fd);\n  if (carrier == '1')\n    return 1;\n  else\n    return 0;\n}",
            "key_variables": [
               [
                  110,
                  "carrier_path[128]"
               ],
               [
                  129,
                  "speed_path[128]"
               ],
               [
                  131,
                  "speed[12]"
               ]
            ]
         },
         {
            "type": "func",
            "name": "network_interface_linux_eth_get_quality",
            "line_range": [
               127,
               142
            ],
            "source_code": "static int network_interface_linux_eth_get_quality(network_interface_t* interface) {\n  char speed_path[128];\n  int fd;\n  char speed[12];\n  int val;\n  snprintf(speed_path, sizeof(speed_path), \"/sys/class/net/%s/speed\", interface->interface_name);\n  fd = open(speed_path, O_RDONLY);\n  return_value_if_fail(fd > 0, -1);\n  if (read(fd, speed, sizeof(speed)) <= 0) {\n    close(fd);\n    return -1;\n  }\n  close(fd);\n  val = strtol(speed, NULL, 10);\n  return val;\n}",
            "key_variables": [
               [
                  147,
                  "command[128]"
               ]
            ]
         },
         {
            "type": "func",
            "name": "network_interface_linux_set_ipaddr",
            "line_range": [
               144,
               154
            ],
            "source_code": "static ret_t network_interface_linux_set_ipaddr(network_interface_t* interface, const char* ipaddr,\n                                                const char* netmask) {\n  char command[128];\n  int ret;\n  return_value_if_fail(interface != NULL, RET_FAIL);\n  snprintf(command, sizeof(command), \"ifconfig %s  %s netmask %s\", interface->interface_name,\n           ipaddr, netmask);\n  ret = system(command);\n  if (WEXITSTATUS(ret) != 0) return RET_FAIL;\n  return RET_OK;\n}",
            "key_variables": [
               [
                  158,
                  "command[128]"
               ],
               [
                  168,
                  "command[128]"
               ]
            ]
         }
      ],
      "src/hal/tools/network_shell/network_shell.c": [
         {
            "type": "block",
            "name": "block",
            "line_range": "",
            "source_code": "",
            "key_variables": [
               66,
               "s_line[1024]"
            ]
         }
      ],
      "src/hal/windows/network_interface_windows.c": [
         {
            "type": "func",
            "name": "wchar_to_char",
            "line_range": [
               79,
               91
            ],
            "source_code": "static char* wchar_to_char(const wchar_t* wc) {\n  int len = WideCharToMultiByte(CP_ACP, 0, wc, wcslen(wc), NULL, 0, NULL, NULL);\n  char* c = (char*)malloc(len + 1);\n\n  if (c == NULL) {\n    log_debug(\"wchar_to_char malloc failed.\");\n    return NULL;\n  }\n\n  WideCharToMultiByte(CP_ACP, 0, wc, wcslen(wc), c, len, NULL, NULL);\n  c[len] = '\\0';\n  return c;\n}",
            "key_variables": [
               [
                  82,
                  "malloc"
               ]
            ]
         },
         {
            "type": "func",
            "name": "get_ip_adapter_address_by_friendly_name",
            "line_range": [
               107,
               195
            ],
            "source_code": "static ret_t get_ip_adapter_address_by_friendly_name(\n    network_interface_windows_t* windows_network_interface, info_type_t info_type) {\n  PIP_ADAPTER_ADDRESSES current_addresses = NULL;\n  ULONG flags = GAA_FLAG_INCLUDE_PREFIX;\n  ULONG family = AF_INET;\n  ULONG out_buff_len = 0;\n  ret_t ret = RET_FAIL;\n  out_buff_len = sizeof(IP_ADAPTER_ADDRESSES);\n  PIP_ADAPTER_ADDRESSES adapter_addresses = NULL;\n  adapter_addresses = (IP_ADAPTER_ADDRESSES*)malloc(out_buff_len);\n  bool_t if_found = FALSE;\n  wchar_t* friendly_name = NULL;\n  wchar_t* adapter_name = NULL;\n  return_value_if_fail(windows_network_interface != NULL, RET_FAIL);\n\n  friendly_name = char_to_wchar(windows_network_interface->network_interface.interface_name);\n  if (friendly_name == NULL) {\n    return RET_FAIL;\n  }\n\n  // Make an initial call to GetAdaptersAddresses to get the\n  // size needed into the out_buff_len variable\n  if (GetAdaptersAddresses(family, flags, NULL, adapter_addresses, &out_buff_len) ==\n      ERROR_BUFFER_OVERFLOW) {\n    free(adapter_addresses);\n    adapter_addresses = (IP_ADAPTER_ADDRESSES*)malloc(out_buff_len);\n  }\n\n  if (adapter_addresses == NULL) {\n    log_debug(\"Memory allocation failed for IP_ADAPTER_ADDRESSES struct.\");\n    return RET_FAIL;\n  }\n\n  if (ERROR_SUCCESS ==\n      GetAdaptersAddresses(family, flags, NULL, adapter_addresses, &out_buff_len)) {\n    current_addresses = adapter_addresses;\n    while (current_addresses) {\n      if (wcscmp(current_addresses->FriendlyName, friendly_name) == 0) {\n        if_found = TRUE;\n        break;\n      }\n\n      current_addresses = current_addresses->Next;\n    }\n\n    if (if_found) {\n      switch (info_type) {\n        case LOCAL_IF_STATUS:\n          windows_network_interface->status =\n              current_addresses->OperStatus == IfOperStatusUp ? 1 : 0;\n          break;\n        case LOCAL_IF_SPEED:\n          windows_network_interface->speed =\n              current_addresses->TransmitLinkSpeed / 1000000;  //单位M\n          break;\n        case LOCAL_IF_DESC:\n          if (windows_network_interface->description_name != NULL) {\n            TKMEM_FREE(windows_network_interface->description_name)\n          }\n\n          windows_network_interface->description_name = tk_wstrdup(current_addresses->Description);\n\n          adapter_name = char_to_wchar(current_addresses->AdapterName);\n          if (adapter_name != NULL) {\n            if (windows_network_interface->adapter_name != NULL) {\n              TKMEM_FREE(windows_network_interface->adapter_name)\n            }\n\n            windows_network_interface->adapter_name = tk_wstrdup(adapter_name);\n            free(adapter_name);\n          }\n\n        default:\n          break;\n      }\n\n      ret = RET_OK;\n    } else {\n      ret = RET_FAIL;\n    }\n  } else {\n    ret = RET_FAIL;\n  }\n\n  free(adapter_addresses);\n  free(friendly_name);\n\n  return ret;\n}",
            "key_variables": [
               [
                  117,
                  "malloc"
               ],
               [
                  133,
                  "malloc"
               ],
               [
                  150,
                  "current_addresses->Next"
               ],
               [
                  200,
                  "m[6]"
               ],
               [
                  201,
                  "macstr[18]"
               ],
               [
                  220,
                  "malloc"
               ],
               [
                  234,
                  "current_ip_adapter_info->Next"
               ]
            ]
         },
         {
            "type": "func",
            "name": "get_adapter_info_by_dev_desc",
            "line_range": [
               197,
               275
            ],
            "source_code": "static ret_t get_adapter_info_by_dev_desc(network_interface_windows_t* windows_network_interface,\n                                          info_type_t info_type) {\n  uint8_t m[6];\n  char macstr[18];\n  ret_t ret = RET_FAIL;\n  PIP_ADAPTER_INFO current_ip_adapter_info = NULL;\n  PIP_ADAPTER_INFO ip_adapter_info = NULL;\n  unsigned long stSize = sizeof(IP_ADAPTER_INFO);\n  int nRel = 0;\n  bool_t if_found = FALSE;\n  return_value_if_fail(\n      windows_network_interface != NULL && windows_network_interface->description_name != NULL,\n      RET_FAIL);\n\n  ip_adapter_info = (PIP_ADAPTER_INFO)malloc(sizeof(IP_ADAPTER_INFO));\n  if (ip_adapter_info == NULL) {\n    return RET_FAIL;\n  }\n\n  nRel = GetAdaptersInfo(ip_adapter_info, &stSize);\n  if (ERROR_BUFFER_OVERFLOW == nRel) {\n    free(ip_adapter_info);\n    ip_adapter_info = (PIP_ADAPTER_INFO)malloc(stSize);\n    nRel = GetAdaptersInfo(ip_adapter_info, &stSize);\n  }\n\n  if (ERROR_SUCCESS == nRel) {\n    char* dev_name = wchar_to_char(windows_network_interface->description_name);\n    current_ip_adapter_info = ip_adapter_info;\n\n    while (current_ip_adapter_info) {\n      if (strcmp(current_ip_adapter_info->Description, dev_name) == 0) {\n        if_found = TRUE;\n        break;\n      }\n\n      current_ip_adapter_info = current_ip_adapter_info->Next;\n    }\n\n    if (if_found) {\n      switch (info_type) {\n        case LOCAL_IF_IP:\n          if (windows_network_interface->ipaddr != NULL) {\n            TKMEM_FREE(windows_network_interface->ipaddr);\n          }\n          windows_network_interface->ipaddr =\n              tk_strdup(current_ip_adapter_info->IpAddressList.IpAddress.String);\n          break;\n        case LOCAL_IF_MAC:\n          if (windows_network_interface->macaddr != NULL) {\n            TKMEM_FREE(windows_network_interface->macaddr);\n          }\n\n          memcpy(m, current_ip_adapter_info->Address, 6);\n          snprintf(macstr, sizeof(macstr), \"%02x:%02x:%02x:%02x:%02x:%02x\", m[0], m[1], m[2], m[3],\n                   m[4], m[5]);\n          windows_network_interface->macaddr = tk_strdup(macstr);\n          break;\n        default:\n          break;\n      }\n\n      ret = RET_OK;\n    } else {\n      ret = RET_FAIL;\n    }\n\n    free(dev_name);\n  } else {\n    ret = RET_FAIL;\n  }\n\n  //释放内存空间\n  if (ip_adapter_info) {\n    free(ip_adapter_info);\n  }\n\n  return ret;\n}",
            "key_variables": [
               [
                  287,
                  "dev_des_name[255]"
               ]
            ]
         },
         {
            "type": "func",
            "name": "network_interface_windows_disable",
            "line_range": [
               383,
               396
            ],
            "source_code": "static ret_t network_interface_windows_disable(network_interface_t* network_interface) {\n  bool_t ret = FALSE;\n  network_interface_windows_t* windows_network_interface =\n      (network_interface_windows_t*)network_interface;\n  return_value_if_fail(\n      windows_network_interface != NULL && windows_network_interface->description_name != NULL,\n      RET_FAIL);\n\n  if (wcslen(windows_network_interface->description_name) != 0) {\n    ret = NetCardStateChange(windows_network_interface->description_name, FALSE);\n  }\n\n  return ret ? RET_OK : RET_FAIL;\n}",
            "key_variables": [
               [
                  407,
                  "windows_network_interface->ipaddr"
               ]
            ]
         },
         {
            "type": "func",
            "name": "network_interface_windows_get_ipaddr",
            "line_range": [
               398,
               410
            ],
            "source_code": "static char* network_interface_windows_get_ipaddr(network_interface_t* network_interface) {\n  ret_t ret = RET_FAIL;\n  network_interface_windows_t* windows_network_interface =\n      (network_interface_windows_t*)network_interface;\n  return_value_if_fail(windows_network_interface != NULL, NULL);\n\n  ret = get_adapter_info_by_dev_desc(windows_network_interface, LOCAL_IF_IP);\n  if (ret == RET_OK) {\n    return windows_network_interface->ipaddr;\n  } else {\n    return NULL;\n  }\n}",
            "key_variables": [
               [
                  421,
                  "windows_network_interface->macaddr"
               ],
               [
                  434,
                  "windows_network_interface->status"
               ]
            ]
         },
         {
            "type": "func",
            "name": "network_interface_windows_eth_get_status",
            "line_range": [
               426,
               437
            ],
            "source_code": "static int network_interface_windows_eth_get_status(network_interface_t* network_interface) {\n  network_interface_windows_t* windows_network_interface =\n      (network_interface_windows_t*)network_interface;\n  return_value_if_fail(windows_network_interface != NULL, 0);\n\n  if (RET_OK ==\n      get_ip_adapter_address_by_friendly_name(windows_network_interface, LOCAL_IF_STATUS)) {\n    return windows_network_interface->status;\n  } else {\n    return 0;\n  }\n}",
            "key_variables": [
               [
                  447,
                  "windows_network_interface->speed"
               ]
            ]
         },
         {
            "type": "func",
            "name": "network_interface_windows_set_dhcp",
            "line_range": [
               611,
               620
            ],
            "source_code": "static ret_t network_interface_windows_set_dhcp(network_interface_t* network_interface) {\n  network_interface_windows_t* windows_network_interface =\n      (network_interface_windows_t*)(network_interface);\n\n  if (!init_com_for_service(windows_network_interface)) {\n    return RET_FAIL;\n  }\n\n  return local_exec_method(windows_network_interface, L\"EnableDHCP\", NULL) ? RET_OK : RET_FAIL;\n}",
            "key_variables": [
               [
                  630,
                  "arg->size"
               ]
            ]
         }
      ],
      "src/image_loader/image_loader_stb.c": [
         {
            "type": "func",
            "name": "convert_2_to_4",
            "line_range": [
               31,
               54
            ],
            "source_code": "static uint8_t* convert_2_to_4(uint8_t* src, uint32_t w, uint32_t h) {\n  uint32_t i = 0;\n  uint8_t* s = src;\n  uint8_t* d = NULL;\n  uint8_t* data = NULL;\n  uint32_t size = w * h;\n  return_value_if_fail(src != NULL, NULL);\n\n  data = TKMEM_ALLOC(size * 4);\n  return_value_if_fail(data != NULL, NULL);\n\n  d = data;\n  for (i = 0; i < size; i++) {\n    d[0] = s[0];\n    d[1] = s[0];\n    d[2] = s[0];\n    d[3] = s[1];\n\n    d += 4;\n    s += 2;\n  }\n\n  return data;\n}",
            "key_variables": [
               [
                  45,
                  "s[0]"
               ],
               [
                  46,
                  "s[0]"
               ],
               [
                  47,
                  "s[0]"
               ],
               [
                  48,
                  "s[1]"
               ]
            ]
         }
      ],
      "src/input_engines/ime_utils.c": [
         {
            "type": "func",
            "name": "ime_utils_table_search",
            "line_range": [
               68,
               149
            ],
            "source_code": "uint32_t ime_utils_table_search(const table_entry_t* items, uint32_t items_nr, const char* key,\n                                wbuffer_t* result, bool_t exact, bool_t result_extendable) {\n  uint32_t i = 0;\n  uint32_t nr = 0;\n  int32_t found = 0;\n  uint32_t key_len = 0;\n  const table_entry_t* iter = NULL;\n  return_value_if_fail(items != NULL && key != NULL && result != NULL, 0);\n\n  key_len = strlen(key);\n  if (key_len == 0) {\n    return 0;\n  }\n\n  /*match exact*/\n  found = ime_utils_table_search_index(items, items_nr, key, key_len, TRUE);\n  if (found >= 0) {\n    iter = items + found;\n\n    if (key_len > 1 && iter->memo != NULL) {\n      if (ime_utils_add_candidate(result, iter->memo, result_extendable) == RET_OK) {\n        nr++;\n      }\n    }\n\n    while (iter->words[i] != NULL) {\n      if (!tk_str_eq(iter->memo, iter->words[i]) &&\n          ime_utils_add_candidate(result, iter->words[i], result_extendable) != RET_OK) {\n        break;\n      }\n      i++;\n      nr++;\n    }\n\n    return nr;\n  }\n\n  if (exact) {\n    return nr;\n  }\n\n  /*match prefix*/\n  found = ime_utils_table_search_index(items, items_nr, key, key_len, FALSE);\n  if (found >= 0) {\n    uint32_t k = 0;\n    uint32_t key_len = strlen(key);\n\n    iter = items + found;\n    if (key_len > 1 && iter->memo != NULL) {\n      if (ime_utils_add_candidate(result, iter->memo, result_extendable) == RET_OK) {\n        nr++;\n      }\n    }\n\n    while (found > 0) {\n      iter = items + found - 1;\n      if (strncmp(iter->key, key, key_len) == 0) {\n        found--;\n      } else {\n        break;\n      }\n    }\n\n    for (i = 0; i < 5; i++) {\n      for (k = found; k < items_nr; k++) {\n        iter = items + k;\n        if (strncmp(iter->key, key, key_len) == 0) {\n          if (ime_utils_count_words(iter->words) > i) {\n            if (ime_utils_add_candidate(result, iter->words[i], result_extendable) != RET_OK) {\n              return nr;\n            }\n            nr++;\n          }\n        } else {\n          break;\n        }\n      }\n    }\n  }\n\n  return nr;\n}",
            "key_variables": [
               [
                  153,
                  "str[8]"
               ],
               [
                  159,
                  "table[index]"
               ]
            ]
         }
      ],
      "src/input_engines/input_engine_pinyin.cpp": [
         {
            "type": "func",
            "name": "input_engine_pinyin_reset_input",
            "line_range": [
               39,
               44
            ],
            "source_code": "static ret_t input_engine_pinyin_reset_input(input_engine_t* engine) {\n  (void)engine;\n  im_reset_search();\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  49,
                  "str[MAX_WORD_LEN * 2 + 1]"
               ],
               [
                  50,
                  "str16[MAX_WORD_LEN + 1]"
               ],
               [
                  51,
                  "wstr[MAX_WORD_LEN + 1]"
               ],
               [
                  56,
                  "str16[i]"
               ]
            ]
         }
      ],
      "src/input_engines/input_engine_t9.c": [
         {
            "type": "block",
            "name": "block",
            "line_range": "",
            "source_code": "",
            "key_variables": [
               40,
               "lang[TK_NAME_LEN + 1]"
            ]
         },
         {
            "type": "func",
            "name": "input_engine_t9_get_lang",
            "line_range": [
               42,
               46
            ],
            "source_code": "static const char* input_engine_t9_get_lang(input_engine_t* engine) {\n  input_engine_t9_t* t9 = (input_engine_t9_t*)engine;\n\n  return t9->lang;\n}",
            "key_variables": [
               [
                  46,
                  "t9->lang"
               ]
            ]
         }
      ],
      "src/layouters/children_layouter_default.c": [
         {
            "type": "func",
            "name": "children_layouter_default_to_string",
            "line_range": [
               29,
               82
            ],
            "source_code": "static const char* children_layouter_default_to_string(children_layouter_t* layouter) {\n  char temp[32];\n  str_t* str = &(layouter->params);\n  children_layouter_default_t* layout = (children_layouter_default_t*)layouter;\n  return_value_if_fail(layout != NULL, NULL);\n  str_set(str, \"default(\");\n  if (layout->cols_is_width) {\n    tk_snprintf(temp, sizeof(temp) - 1, \"w=%d,\", (int)(layout->cols));\n  } else {\n    tk_snprintf(temp, sizeof(temp) - 1, \"c=%d,\", (int)(layout->cols));\n  }\n  str_append(str, temp);\n\n  if (layout->rows_is_height) {\n    tk_snprintf(temp, sizeof(temp) - 1, \"h=%d,\", (int)(layout->rows));\n  } else {\n    tk_snprintf(temp, sizeof(temp) - 1, \"r=%d,\", (int)(layout->rows));\n  }\n  str_append(str, temp);\n\n  if (layout->x_margin) {\n    tk_snprintf(temp, sizeof(temp) - 1, \"x=%d,\", (int)(layout->x_margin));\n    str_append(str, temp);\n  }\n\n  if (layout->y_margin) {\n    tk_snprintf(temp, sizeof(temp) - 1, \"y=%d,\", (int)(layout->y_margin));\n    str_append(str, temp);\n  }\n\n  if (layout->spacing) {\n    tk_snprintf(temp, sizeof(temp) - 1, \"s=%d,\", (int)(layout->spacing));\n    str_append(str, temp);\n  }\n\n  if (!(layout->keep_disable)) {\n    str_append(str, \"keep_disable=false,\");\n  }\n\n  if (layout->keep_invisible) {\n    str_append(str, \"keep_invisible=true,\");\n  }\n\n  if (layout->align_h == ALIGN_H_CENTER) {\n    str_append(str, \"align_h=center,\");\n  } else if (layout->align_h == ALIGN_H_RIGHT) {\n    str_append(str, \"align_h=right,\");\n  }\n\n  str_trim_right(str, \",\");\n  str_append(str, \")\");\n\n  return str->str;\n}",
            "key_variables": [
               [
                  31,
                  "temp[32]"
               ],
               [
                  82,
                  "str->str"
               ]
            ]
         },
         {
            "type": "func",
            "name": "children_layouter_default_get_param",
            "line_range": [
               154,
               228
            ],
            "source_code": "static ret_t children_layouter_default_get_param(children_layouter_t* layouter, const char* name,\n                                                 value_t* v) {\n  children_layouter_default_t* l = (children_layouter_default_t*)layouter;\n  return_value_if_fail(l != NULL, RET_BAD_PARAMS);\n  switch (*name) {\n    case 'w': {\n      if (l->cols_is_width) {\n        value_set_int(v, l->cols);\n        return RET_OK;\n      } else {\n        return RET_FAIL;\n      }\n    }\n    case 'h': {\n      if (l->rows_is_height) {\n        value_set_int(v, l->rows);\n        return RET_OK;\n      } else {\n        return RET_FAIL;\n      }\n    }\n    case 'c': {\n      if (!l->cols_is_width) {\n        value_set_int(v, l->cols);\n        return RET_OK;\n      } else {\n        return RET_FAIL;\n      }\n    }\n    case 'r': {\n      if (!l->rows_is_height) {\n        value_set_int(v, l->rows);\n        return RET_OK;\n      } else {\n        return RET_FAIL;\n      }\n    }\n    case 'x': {\n      value_set_int(v, l->x_margin);\n      return RET_OK;\n    }\n    case 'y': {\n      value_set_int(v, l->y_margin);\n      return RET_OK;\n    }\n    case 'm': {\n      value_set_int(v, l->x_margin);\n      return RET_OK;\n    }\n    case 's': {\n      value_set_int(v, l->spacing);\n      return RET_OK;\n    }\n    case 'a': {\n      value_set_int(v, l->align_h);\n      return RET_OK;\n    }\n    case 'k': {\n      if (strstr(name, \"invisible\") != NULL || name[1] == 'i') {\n        value_set_bool(v, l->keep_invisible);\n        return RET_OK;\n      } else if (strstr(name, \"disable\") != NULL || name[1] == 'd') {\n        value_set_bool(v, l->keep_disable);\n        return RET_OK;\n      }\n      break;\n    }\n    default: {\n      assert(!\"not support param\");\n      break;\n    }\n  }\n\n  return RET_FAIL;\n}",
            "key_variables": [
               [
                  272,
                  "layout->x_margin"
               ],
               [
                  273,
                  "layout->y_margin"
               ],
               [
                  274,
                  "layout->x_margin"
               ],
               [
                  275,
                  "layout->y_margin"
               ],
               [
                  276,
                  "layout->spacing"
               ],
               [
                  281,
                  "layout->rows"
               ],
               [
                  287,
                  "layout->cols"
               ],
               [
                  300,
                  "children[i]"
               ],
               [
                  311,
                  "children[i]"
               ],
               [
                  331,
                  "children[i]"
               ],
               [
                  346,
                  "children[i]"
               ],
               [
                  357,
                  "children[i]"
               ],
               [
                  383,
                  "children[i]"
               ]
            ]
         }
      ],
      "src/layouters/children_layouter_parser.c": [
         {
            "type": "func",
            "name": "children_layouter_create_new",
            "line_range": [
               53,
               70
            ],
            "source_code": "children_layouter_t* children_layouter_create_new(const char* params) {\n  children_layouter_t* layouter = NULL;\n  children_layouter_parser_t parser;\n  return_value_if_fail(params != NULL, NULL);\n\n  memset(&parser, 0x00, sizeof(parser));\n  return_value_if_fail(func_call_parser_init(&(parser.base), params, strlen(params)) != NULL, NULL);\n\n  parser.base.on_name = children_layouter_parser_on_name;\n  parser.base.on_param = children_layouter_parser_on_param;\n\n  parser.layouter = NULL;\n  func_call_parser_parse(&(parser.base));\n  layouter = parser.layouter;\n  func_call_parser_deinit(&(parser.base));\n\n  return layouter;\n}",
            "key_variables": [
               [
                  75,
                  "name[2]"
               ]
            ]
         }
      ],
      "src/layouters/self_layouter_default.c": [
         {
            "type": "func",
            "name": "self_layouter_default_to_string",
            "line_range": [
               37,
               154
            ],
            "source_code": "const char* self_layouter_default_to_string(self_layouter_t* layouter) {\n  char value[32];\n  str_t* str = &(layouter->params);\n  self_layouter_default_t* layout = (self_layouter_default_t*)layouter;\n  return_value_if_fail(layout != NULL, NULL);\n  str_set(str, \"default(\");\n  memset(value, 0x00, sizeof(value));\n\n  switch (layout->x_attr) {\n    case X_ATTR_UNDEF: {\n      *value = '\\0';\n      break;\n    }\n    case X_ATTR_PERCENT: {\n      percent_to_string(value, sizeof(value), \"\", layout->x);\n      break;\n    }\n    case X_ATTR_CENTER: {\n      tk_snprintf(value, sizeof(value) - 1, \"c:%d\", (int)layout->x);\n      break;\n    }\n    case X_ATTR_CENTER_PERCENT: {\n      percent_to_string(value, sizeof(value), \"c:\", layout->x);\n      break;\n    }\n    case X_ATTR_RIGHT: {\n      tk_snprintf(value, sizeof(value) - 1, \"r:%d\", (int)layout->x);\n      break;\n    }\n    case X_ATTR_RIGHT_PERCENT: {\n      percent_to_string(value, sizeof(value), \"r:\", layout->x);\n      break;\n    }\n    default: {\n      tk_snprintf(value, sizeof(value) - 1, \"%d\", (int)layout->x);\n      break;\n    }\n  }\n  if (*value) {\n    str_append_more(str, \"x=\", value, \",\", NULL);\n  }\n\n  switch (layout->y_attr) {\n    case Y_ATTR_UNDEF: {\n      *value = '\\0';\n      break;\n    }\n    case Y_ATTR_PERCENT: {\n      percent_to_string(value, sizeof(value), \"\", layout->y);\n      break;\n    }\n    case Y_ATTR_MIDDLE: {\n      tk_snprintf(value, sizeof(value) - 1, \"m:%d\", (int)layout->y);\n      break;\n    }\n    case Y_ATTR_MIDDLE_PERCENT: {\n      percent_to_string(value, sizeof(value), \"m:\", layout->y);\n      break;\n    }\n    case Y_ATTR_BOTTOM: {\n      tk_snprintf(value, sizeof(value) - 1, \"b:%d\", (int)layout->y);\n      break;\n    }\n    case Y_ATTR_BOTTOM_PERCENT: {\n      percent_to_string(value, sizeof(value), \"b:\", layout->y);\n      break;\n    }\n    default: {\n      tk_snprintf(value, sizeof(value) - 1, \"%d\", (int)layout->y);\n      break;\n    }\n  }\n  if (*value) {\n    str_append_more(str, \"y=\", value, \",\", NULL);\n  }\n\n  switch (layout->w_attr) {\n    case W_ATTR_UNDEF: {\n      *value = '\\0';\n      break;\n    }\n    case W_ATTR_PERCENT: {\n      percent_to_string(value, sizeof(value), \"\", layout->w);\n      break;\n    }\n    default: {\n      tk_snprintf(value, sizeof(value) - 1, \"%d\", (int)layout->w);\n      break;\n    }\n  }\n\n  if (*value) {\n    str_append_more(str, \"w=\", value, \",\", NULL);\n  }\n\n  switch (layout->h_attr) {\n    case H_ATTR_UNDEF: {\n      *value = '\\0';\n      break;\n    }\n    case H_ATTR_PERCENT: {\n      percent_to_string(value, sizeof(value), \"\", layout->h);\n      break;\n    }\n    default: {\n      tk_snprintf(value, sizeof(value) - 1, \"%d\", (int)layout->h);\n      break;\n    }\n  }\n\n  if (*value) {\n    str_append_more(str, \"h=\", value, \")\", NULL);\n  } else {\n    str_append_char(str, ')');\n  }\n\n  return str->str;\n}",
            "key_variables": [
               [
                  39,
                  "value[32]"
               ],
               [
                  154,
                  "str->str"
               ]
            ]
         },
         {
            "type": "func",
            "name": "self_layouter_default_set_param",
            "line_range": [
               203,
               307
            ],
            "source_code": "ret_t self_layouter_default_set_param(self_layouter_t* layouter, const char* name,\n                                      const value_t* v) {\n  const char* value = value_str(v);\n  self_layouter_default_t* layout = (self_layouter_default_t*)layouter;\n  return_value_if_fail(layout != NULL, RET_BAD_PARAMS);\n\n  switch (*name) {\n    case 'x': {\n      const char* x = value;\n      if (x[0] == 'c') {\n        const char* v = strchr(x, ':');\n        if (v != NULL) {\n          layout->x = tk_atof(v + 1);\n        }\n        if (strchr(x, '%') != NULL) {\n          layout->x_attr = X_ATTR_CENTER_PERCENT;\n        } else {\n          layout->x_attr = X_ATTR_CENTER;\n        }\n      } else if (x[0] == 'r') {\n        const char* v = strchr(x, ':');\n        if (v != NULL) {\n          layout->x = tk_atof(v + 1);\n        }\n        if (strchr(x, '%') != NULL) {\n          layout->x_attr = X_ATTR_RIGHT_PERCENT;\n        } else {\n          layout->x_attr = X_ATTR_RIGHT;\n        }\n      } else if (strchr(x, '%') != NULL) {\n        layout->x = tk_atof(x);\n        layout->x_attr = X_ATTR_PERCENT;\n      } else if (strchr(x, 'n') != NULL) {\n        layout->x_attr = X_ATTR_UNDEF;\n      } else {\n        layout->x = tk_atof(x);\n        layout->x_attr = X_ATTR_DEFAULT;\n      }\n      break;\n    }\n    case 'y': {\n      const char* y = value;\n      if (y[0] == 'm') {\n        const char* v = strchr(y, ':');\n        if (v != NULL) {\n          layout->y = tk_atof(v + 1);\n        }\n        if (strchr(y, '%') != NULL) {\n          layout->y_attr = Y_ATTR_MIDDLE_PERCENT;\n        } else {\n          layout->y_attr = Y_ATTR_MIDDLE;\n        }\n      } else if (y[0] == 'b') {\n        const char* v = strchr(y, ':');\n        if (v != NULL) {\n          layout->y = tk_atof(v + 1);\n        }\n        if (strchr(y, '%') != NULL) {\n          layout->y_attr = Y_ATTR_BOTTOM_PERCENT;\n        } else {\n          layout->y_attr = Y_ATTR_BOTTOM;\n        }\n      } else if (strchr(y, '%') != NULL) {\n        layout->y = tk_atof(y);\n        layout->y_attr = Y_ATTR_PERCENT;\n      } else if (strchr(y, 'n') != NULL) {\n        layout->y_attr = X_ATTR_UNDEF;\n      } else {\n        layout->y = tk_atof(y);\n        layout->y_attr = Y_ATTR_DEFAULT;\n      }\n      break;\n    }\n    case 'w': {\n      const char* w = value;\n      layout->w = tk_atof(w);\n      layout->w_attr = W_ATTR_PIXEL;\n      if (w != NULL) {\n        if (strchr(w, '%') != NULL) {\n          layout->w_attr = W_ATTR_PERCENT;\n        } else if (strchr(w, 'n') != NULL) {\n          layout->w_attr = W_ATTR_UNDEF;\n        }\n      }\n      break;\n    }\n    case 'h': {\n      const char* h = value;\n      layout->h = tk_atof(h);\n      layout->h_attr = H_ATTR_PIXEL;\n      if (h != NULL) {\n        if (strchr(h, '%') != NULL) {\n          layout->h_attr = H_ATTR_PERCENT;\n        } else if (strchr(h, 'n') != NULL) {\n          layout->h_attr = H_ATTR_UNDEF;\n        }\n      }\n      break;\n    }\n    default:\n      break;\n  }\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  312,
                  "layout->x_attr"
               ],
               [
                  313,
                  "layout->y_attr"
               ],
               [
                  314,
                  "layout->w_attr"
               ],
               [
                  315,
                  "layout->h_attr"
               ],
               [
                  316,
                  "layout->x"
               ],
               [
                  317,
                  "layout->y"
               ],
               [
                  318,
                  "layout->w"
               ],
               [
                  319,
                  "layout->h"
               ]
            ]
         },
         {
            "type": "func",
            "name": "widget_layout_self_with_rect",
            "line_range": [
               386,
               422
            ],
            "source_code": "ret_t widget_layout_self_with_rect(self_layouter_t* layouter, widget_t* widget, rect_t* area) {\n  rect_t r = rect_init(widget->x, widget->y, widget->w, widget->h);\n  self_layouter_default_t* l = (self_layouter_default_t*)layouter;\n\n  return_value_if_fail(widget != NULL && area != NULL, RET_BAD_PARAMS);\n\n  if (self_layouter_default_is_valid(layouter)) {\n    bool_t has_max_w =\n        (widget->auto_adjust_size && widget_get_prop_int(widget, WIDGET_PROP_MAX_W, 0) != 0);\n\n    /*如果有指定max_w，需要在layout之前，先计算需要的高宽。*/\n    if (has_max_w && widget->vt->auto_adjust_size != NULL) {\n      widget->vt->auto_adjust_size(widget);\n      r.w = widget->w;\n      r.h = widget->h;\n      l->w_attr = W_ATTR_UNDEF;\n      l->h_attr = H_ATTR_UNDEF;\n    }\n\n    widget_layout_calc(l, &r, area->w, area->h);\n\n    /*如果没有指定max_w，需要在layout之后，根据layout的高宽计算实际需要的高宽。*/\n    if (!has_max_w && widget->vt->auto_adjust_size != NULL) {\n      widget->w = r.w;\n      widget->h = r.h;\n      widget->vt->auto_adjust_size(widget);\n      r.w = widget->w;\n      r.h = widget->h;\n    }\n\n    widget_move_resize_ex(widget, r.x + area->x, r.y + area->y, r.w, r.h, FALSE);\n\n    return RET_OK;\n  }\n\n  return RET_FAIL;\n}",
            "key_variables": [
               [
                  400,
                  "widget->w"
               ],
               [
                  401,
                  "widget->h"
               ],
               [
                  413,
                  "widget->w"
               ],
               [
                  414,
                  "widget->h"
               ]
            ]
         }
      ],
      "src/layouters/self_layouter_menu.c": [
         {
            "type": "func",
            "name": "widget_layout_calc",
            "line_range": [
               157,
               290
            ],
            "source_code": "static ret_t widget_layout_calc(self_layouter_menu_t* layout, rect_t* r, wh_t parent_w,\n                                wh_t parent_h) {\n  xy_t x = r->x;\n  xy_t y = r->y;\n  uint8_t w_attr = layout->w_attr;\n  uint8_t h_attr = layout->h_attr;\n  wh_t w = w_attr == W_ATTR_UNDEF ? r->w : layout->w;\n  wh_t h = h_attr == H_ATTR_UNDEF ? r->h : layout->h;\n\n  if (parent_w > 0 && parent_h > 0) {\n    if (w_attr == W_ATTR_PERCENT) {\n      w = (parent_w * w) / 100;\n    }\n\n    if (w < 0) {\n      w = parent_w + w;\n    }\n\n    if (h_attr == H_ATTR_PERCENT) {\n      h = (parent_h * h) / 100;\n    }\n\n    if (h < 0) {\n      h = parent_h + h;\n    }\n\n    r->w = w;\n    r->h = h;\n\n    switch (layout->position) {\n      case POSITION_POINT: {\n        int32_t px = layout->pressed.x;\n        int32_t py = layout->pressed.y;\n\n        if ((px + r->w) <= parent_w) {\n          x = px;\n        } else if (px >= r->w) {\n          x = px - r->w;\n        } else {\n          x = parent_w - r->w;\n        }\n\n        if ((py + r->h) <= parent_h) {\n          y = py;\n        } else if (py >= r->h) {\n          y = py - r->h;\n        } else {\n          y = parent_h - r->h;\n        }\n        break;\n      }\n      case POSITION_LEFT:\n      case POSITION_RIGHT: {\n        int32_t px = layout->trigger_widget_rect.x;\n        int32_t py = layout->trigger_widget_rect.y;\n        int32_t pw = layout->trigger_widget_rect.w;\n        int32_t ph = layout->trigger_widget_rect.h;\n\n        if (layout->position == POSITION_LEFT) {\n          x = px - r->w;\n          x -= layout->x_attr;\n        } else {\n          x = px + pw;\n          x += layout->x_attr;\n        }\n\n        switch (layout->y_attr) {\n          case Y_ATTR_MIDDLE: {\n            y = py + (ph - r->h) / 2;\n            if ((y + r->h) > parent_h) {\n              y = parent_h - r->h;\n            } else if (y < 0) {\n              y = 0;\n            }\n            break;\n          }\n          case Y_ATTR_BOTTOM: {\n            y = py + ph - r->h;\n            break;\n          }\n          default: {\n            y = py;\n            break;\n          }\n        }\n        break;\n      }\n      case POSITION_UP:\n      case POSITION_DOWN: {\n        int32_t px = layout->trigger_widget_rect.x;\n        int32_t py = layout->trigger_widget_rect.y;\n        int32_t pw = layout->trigger_widget_rect.w;\n        int32_t ph = layout->trigger_widget_rect.h;\n\n        if (layout->position == POSITION_DOWN) {\n          y = py + ph;\n          y -= layout->y_attr;\n        } else {\n          y = py - r->h;\n          y += layout->y_attr;\n        }\n\n        switch (layout->x_attr) {\n          case X_ATTR_CENTER: {\n            x = px + (pw - r->w) / 2;\n            if ((x + r->w) > parent_w) {\n              x = parent_w - r->w;\n            } else if (x < 0) {\n              x = 0;\n            }\n            break;\n          }\n          case X_ATTR_RIGHT: {\n            x = px + pw - r->w;\n            break;\n          }\n          default: {\n            x = px;\n            break;\n          }\n        }\n\n        break;\n      }\n      default:\n        break;\n    }\n  }\n\n  r->x = x;\n  r->y = y;\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  160,
                  "r->x"
               ],
               [
                  161,
                  "r->y"
               ],
               [
                  162,
                  "layout->w_attr"
               ],
               [
                  163,
                  "layout->h_attr"
               ],
               [
                  164,
                  "layout->w"
               ],
               [
                  165,
                  "layout->h"
               ],
               [
                  195,
                  "r->w"
               ],
               [
                  197,
                  "r->w"
               ],
               [
                  203,
                  "r->h"
               ],
               [
                  205,
                  "r->h"
               ],
               [
                  217,
                  "r->w"
               ],
               [
                  218,
                  "layout->x_attr"
               ],
               [
                  221,
                  "layout->x_attr"
               ],
               [
                  228,
                  "r->h"
               ],
               [
                  235,
                  "r->h"
               ],
               [
                  254,
                  "layout->y_attr"
               ],
               [
                  256,
                  "r->h"
               ],
               [
                  257,
                  "layout->y_attr"
               ],
               [
                  264,
                  "r->w"
               ],
               [
                  271,
                  "r->w"
               ]
            ]
         },
         {
            "type": "func",
            "name": "widget_layout_self_menu_with_rect",
            "line_range": [
               292,
               306
            ],
            "source_code": "ret_t widget_layout_self_menu_with_rect(self_layouter_t* layouter, widget_t* widget, rect_t* area) {\n  rect_t r = rect_init(widget->x, widget->y, widget->w, widget->h);\n  self_layouter_menu_t* l = (self_layouter_menu_t*)layouter;\n\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  if (self_layouter_menu_is_valid(layouter)) {\n    widget_layout_calc(l, &r, area->w, area->h);\n    widget_move_resize_ex(widget, r.x + area->x, r.y + area->y, r.w, r.h, FALSE);\n\n    return RET_OK;\n  }\n\n  return RET_FAIL;\n}",
            "key_variables": [
               [
                  320,
                  "iter->key_target"
               ],
               [
                  329,
                  "iter->w"
               ],
               [
                  330,
                  "iter->h"
               ]
            ]
         }
      ],
      "src/lcd/lcd_mono.c": [
         {
            "type": "func",
            "name": "lcd_mono_begin_frame",
            "line_range": [
               102,
               122
            ],
            "source_code": "static ret_t lcd_mono_begin_frame(lcd_t* lcd, const dirty_rects_t* dirty_rects) {\n\n  const rect_t* dirty_rect = dirty_rects != NULL ? &(dirty_rects->max) : NULL;\n\n\n\n  if (dirty_rect != NULL) {\n\n    lcd->dirty_rect = *dirty_rect;\n\n  } else {\n\n    lcd->dirty_rect = rect_init(0, 0, lcd->w, lcd->h);\n\n  }\n\n\n\n  return RET_OK;\n\n}",
            "key_variables": [
               [
                  116,
                  "src->x"
               ],
               [
                  117,
                  "src->y"
               ],
               [
                  118,
                  "src->w"
               ],
               [
                  119,
                  "src->h"
               ]
            ]
         }
      ],
      "src/lcd/lcd_sdl2.c": [
         {
            "type": "func",
            "name": "special_info_create_texture",
            "line_range": [
               84,
               114
            ],
            "source_code": "static ret_t special_info_create_texture(special_info_t* info, wh_t w, wh_t h) {\n\n  int flags = SDL_TEXTUREACCESS_STREAMING;\n\n\n\n#ifdef WITH_FB_BGRA8888\n\n  /*SDL ABGR is rgba from low address to high address*/\n\n  info->format = BITMAP_FMT_BGRA8888;\n\n  info->texture = SDL_CreateTexture(info->render, SDL_PIXELFORMAT_ARGB8888, flags, w, h);\n\n  log_debug(\"WITH_FB_BGRA8888\\n\");\n\n#else\n\n  /*SDL ABGR is rgba from low address to high address*/\n\n  info->format = BITMAP_FMT_BGR565;\n\n  info->texture = SDL_CreateTexture(info->render, SDL_PIXELFORMAT_RGB565, flags, w, h);\n\n  log_debug(\"WITH_FB_BGR565\\n\");\n\n#endif\n\n  return info->texture != NULL ? RET_OK : RET_FAIL;\n\n}",
            "key_variables": [
               [
                  89,
                  "lcd->h"
               ],
               [
                  90,
                  "lcd->w"
               ],
               [
                  106,
                  "dirty_rects->nr"
               ]
            ]
         }
      ],
      "src/lcd/lcd_sdl2_mono.c": [
         {
            "type": "func",
            "name": "mono_info_create_texture",
            "line_range": [
               78,
               94
            ],
            "source_code": "static ret_t mono_info_create_texture(mono_info_t* info, wh_t w, wh_t h) {\n\n  int flags = SDL_TEXTUREACCESS_STREAMING;\n\n\n\n  /*SDL ABGR is rgba from low address to high address*/\n\n  info->texture = SDL_CreateTexture(info->render, SDL_PIXELFORMAT_ARGB8888, flags, w, h);\n\n  log_debug(\"WITH_FB_BGRA8888\\n\");\n\n\n\n  return info->texture != NULL ? RET_OK : RET_FAIL;\n\n}",
            "key_variables": [
               [
                  82,
                  "lcd->h"
               ],
               [
                  83,
                  "lcd->w"
               ]
            ]
         }
      ],
      "src/main_loop/main_loop_sdl.c": [
         {
            "type": "block",
            "name": "block",
            "line_range": "",
            "source_code": "",
            "key_variables": [
               45,
               "text_input_event->text"
            ]
         },
         {
            "type": "block",
            "name": "block",
            "line_range": "",
            "source_code": "",
            "key_variables": [
               56,
               "sdl_event->type"
            ]
         },
         {
            "type": "func",
            "name": "main_loop_sdl2_dispatch_text_editing",
            "line_range": [
               98,
               102
            ],
            "source_code": "static ret_t main_loop_sdl2_dispatch_text_editing(main_loop_simple_t* loop, SDL_Event* sdl_event) {\n\n  return RET_OK;\n\n}",
            "key_variables": [
               [
                  101,
                  "widget->w"
               ],
               [
                  102,
                  "widget->h"
               ]
            ]
         },
         {
            "type": "func",
            "name": "main_loop_sdl2_dispatch_key_event",
            "line_range": [
               106,
               152
            ],
            "source_code": "static ret_t main_loop_sdl2_dispatch_key_event(main_loop_simple_t* loop, SDL_Event* sdl_event) {\n\n  key_event_t event;\n\n  int type = sdl_event->type;\n\n  widget_t* widget = loop->base.wm;\n\n\n\n  switch (type) {\n\n    case SDL_KEYDOWN: {\n\n      key_event_init(&event, EVT_KEY_DOWN, widget, sdl_event->key.keysym.sym);\n\n      event.e.native_window_handle = SDL_GetWindowFromID(sdl_event->key.windowID);\n\n      window_manager_dispatch_input_event(widget, (event_t*)&event);\n\n      break;\n\n    }\n\n    case SDL_KEYUP: {\n\n      key_event_init(&event, EVT_KEY_UP, widget, sdl_event->key.keysym.sym);\n\n      event.e.native_window_handle = SDL_GetWindowFromID(sdl_event->key.windowID);\n\n      window_manager_dispatch_input_event(widget, (event_t*)&event);\n\n      break;\n\n    }\n\n    default:\n\n      break;\n\n  }\n\n\n\n  return RET_OK;\n\n}",
            "key_variables": [
               [
                  116,
                  "sdl_event->type"
               ],
               [
                  127,
                  "loop->pressed"
               ],
               [
                  144,
                  "loop->pressed"
               ],
               [
                  165,
                  "loop->pressed"
               ]
            ]
         }
      ],
      "src/main_loop/main_loop_simple.c": [
         {
            "type": "func",
            "name": "main_loop_post_pointer_event",
            "line_range": [
               68,
               113
            ],
            "source_code": "ret_t main_loop_post_pointer_event(main_loop_t* l, bool_t pressed, xy_t x, xy_t y) {\n  event_queue_req_t r;\n  pointer_event_t event;\n  main_loop_simple_t* loop = (main_loop_simple_t*)l;\n\n  memset(&r, 0x00, sizeof(r));\n  memset(&event, 0x00, sizeof(event));\n  return_value_if_fail(loop != NULL, RET_BAD_PARAMS);\n\n  event.x = x;\n  event.y = y;\n  event.button = 0;\n  event.e.time = time_now_ms();\n  event.e.size = sizeof(pointer_event_t);\n\n  if (pressed) {\n    loop->last_x = x;\n    loop->last_y = y;\n\n    if (loop->pressed) {\n      event.e.type = EVT_POINTER_MOVE;\n    } else {\n      event.e.type = EVT_POINTER_DOWN;\n    }\n    loop->pressed = TRUE;\n    event.pressed = loop->pressed;\n\n    r.pointer_event = event;\n\n    return main_loop_queue_event(l, &r);\n  } else {\n    if (loop->pressed) {\n      event.e.type = EVT_POINTER_UP;\n      event.pressed = loop->pressed;\n      event.x = loop->last_x;\n      event.y = loop->last_y;\n      r.pointer_event = event;\n\n      loop->pressed = FALSE;\n\n      return main_loop_queue_event(l, &r);\n    }\n  }\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  94,
                  "loop->pressed"
               ],
               [
                  102,
                  "loop->pressed"
               ],
               [
                  103,
                  "loop->last_x"
               ],
               [
                  104,
                  "loop->last_y"
               ]
            ]
         },
         {
            "type": "func",
            "name": "main_loop_simple_step",
            "line_range": [
               211,
               226
            ],
            "source_code": "static ret_t main_loop_simple_step(main_loop_t* l) {\n  uint32_t curr_expected_sleep_time = 0xFFFFFFFF;\n  main_loop_simple_t* loop = (main_loop_simple_t*)l;\n\n  main_loop_dispatch_input(loop);\n  main_loop_dispatch_events(loop);\n  event_source_manager_dispatch(loop->event_source_manager);\n\n  window_manager_check_and_layout(loop->base.wm);\n  window_manager_paint(loop->base.wm);\n\n  curr_expected_sleep_time = window_manager_get_curr_expected_sleep_time(loop->base.wm);\n  main_loop_set_curr_expected_sleep_time(l, curr_expected_sleep_time);\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  235,
                  "l->quit_num"
               ],
               [
                  236,
                  "l->running"
               ]
            ]
         },
         {
            "type": "func",
            "name": "main_loop_simple_run",
            "line_range": [
               228,
               243
            ],
            "source_code": "static ret_t main_loop_simple_run(main_loop_t* l) {\n  main_loop_simple_t* loop = (main_loop_simple_t*)l;\n\n  loop->pressed = FALSE;\n  while (l->running) {\n    if (l->quit_num) {\n      --l->quit_num;\n      --l->running;\n      break;\n    }\n    main_loop_step(l);\n    main_loop_sleep(l);\n  }\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  249,
                  "loop->event_source_manager"
               ]
            ]
         }
      ],
      "src/native_window/native_window_fb_gl.c": [
         {
            "type": "func",
            "name": "native_window_fb_gl_get_info",
            "line_range": [
               140,
               152
            ],
            "source_code": "static ret_t native_window_fb_gl_get_info(native_window_t* win, native_window_info_t* info) {\n  native_window_fb_gl_t* fb_gl = NATIVE_WINDOW_FB_GL(win);\n\n  info->x = 0;\n  info->y = 0;\n  info->ratio = fb_gl->ratio;\n  info->w = fb_gl->w;\n  info->h = fb_gl->h;\n\n  //  log_debug(\"ratio=%f %d %d\\n\", info->ratio, info->w, info->h);\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  146,
                  "fb_gl->ratio"
               ],
               [
                  147,
                  "fb_gl->w"
               ],
               [
                  148,
                  "fb_gl->h"
               ]
            ]
         }
      ],
      "src/native_window/native_window_raw.c": [
         {
            "type": "func",
            "name": "native_window_raw_get_canvas",
            "line_range": [
               92,
               96
            ],
            "source_code": "static canvas_t* native_window_raw_get_canvas(native_window_t* win) {\n  native_window_raw_t* raw = NATIVE_WINDOW_RAW(win);\n\n  return &(raw->canvas);\n}",
            "key_variables": [
               [
                  104,
                  "s_info->lcd_w"
               ],
               [
                  105,
                  "s_info->lcd_h"
               ],
               [
                  106,
                  "s_info->device_pixel_ratio"
               ]
            ]
         }
      ],
      "src/native_window/native_window_sdl.c": [
         {
            "type": "func",
            "name": "native_window_sdl_resize",
            "line_range": [
               79,
               106
            ],
            "source_code": "static ret_t native_window_sdl_resize(native_window_t* win, wh_t w, wh_t h) {\n  lcd_t* lcd = NULL;\n  ret_t ret = RET_OK;\n  native_window_info_t info;\n  native_window_sdl_t* sdl = NATIVE_WINDOW_SDL(win);\n  return_value_if_fail(sdl != NULL, RET_BAD_PARAMS);\n  lcd = sdl->canvas.lcd;\n  native_window_get_info(win, &info);\n\n  win->rect.w = w;\n  win->rect.h = h;\n\n#if !defined(ANDROID) && !defined(IOS)\n  if (w != info.w || h != info.h) {\n#ifdef WIN32\n    w = w * win->ratio;\n    h = h * win->ratio;\n#endif /*WIN32*/\n\n    SDL_SetWindowSize(sdl->window, w, h);\n  }\n#endif /*ANDROID*/\n  if (lcd != NULL && (lcd->w != w || lcd->h != h)) {\n    ret = lcd_resize(lcd, w, h, 0);\n  }\n\n  return ret;\n}",
            "key_variables": [
               [
                  95,
                  "win->ratio"
               ],
               [
                  96,
                  "win->ratio"
               ]
            ]
         },
         {
            "type": "func",
            "name": "native_window_sdl_close",
            "line_range": [
               180,
               200
            ],
            "source_code": "static ret_t native_window_sdl_close(native_window_t* win) {\n  native_window_sdl_t* sdl = NATIVE_WINDOW_SDL(win);\n  lcd_t* lcd = sdl->canvas.lcd;\n\n  canvas_reset(&(sdl->canvas));\n  lcd_destroy(lcd);\n\n  if (sdl->render != NULL) {\n    SDL_DestroyRenderer(sdl->render);\n  }\n\n  if (sdl->context != NULL) {\n    SDL_GL_DeleteContext(sdl->context);\n  }\n\n  sdl->render = NULL;\n  sdl->window = NULL;\n  sdl->context = NULL;\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  214,
                  "sdl->window"
               ]
            ]
         },
         {
            "type": "func",
            "name": "native_window_sdl_preprocess_event",
            "line_range": [
               237,
               256
            ],
            "source_code": "static ret_t native_window_sdl_preprocess_event(native_window_t* win, event_t* e) {\n#if defined(ANDROID)\n  if (e->type == EVT_POINTER_DOWN || e->type == EVT_POINTER_MOVE || e->type == EVT_CLICK ||\n      e->type == EVT_POINTER_UP || e->type == EVT_CONTEXT_MENU) {\n    pointer_event_t* evt = pointer_event_cast(e);\n    evt->x /= win->ratio;\n    evt->y /= win->ratio;\n  } else if (e->type == EVT_KEY_DOWN) {\n    key_event_t* evt = key_event_cast(e);\n    if (evt->key == TK_KEY_AC_BACK) {\n      window_manager_back(window_manager());\n      if (widget_count_children(window_manager()) == 0) {\n        tk_quit();\n      }\n    }\n  }\n#endif /*ANDROID*/\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  243,
                  "win->ratio"
               ],
               [
                  244,
                  "win->ratio"
               ],
               [
                  267,
                  "sdl->window"
               ],
               [
                  295,
                  "info->x"
               ],
               [
                  296,
                  "info->y"
               ],
               [
                  297,
                  "info->w"
               ],
               [
                  298,
                  "info->h"
               ],
               [
                  299,
                  "info->ratio"
               ]
            ]
         },
         {
            "type": "func",
            "name": "native_window_sdl_get_info",
            "line_range": [
               258,
               301
            ],
            "source_code": "static ret_t native_window_sdl_get_info(native_window_t* win, native_window_info_t* info) {\n  int ww = 0;\n  int wh = 0;\n  int fw = 0;\n  int fh = 0;\n  int x = 0;\n  int y = 0;\n  native_window_sdl_t* sdl = NATIVE_WINDOW_SDL(win);\n  SDL_Window* window = sdl->window;\n\n  SDL_GetWindowPosition(window, &x, &y);\n  SDL_GetWindowSize(window, &ww, &wh);\n  SDL_GL_GetDrawableSize(window, &fw, &fh);\n\n  memset(info, 0x00, sizeof(*info));\n  info->x = x;\n  info->y = y;\n\n#if defined(ANDROID)\n  float dpi = 1;\n  SDL_GetDisplayDPI(0, &dpi, NULL, NULL);\n  float_t ratio = dpi / 160;\n\n  info->w = ww / ratio;\n  info->h = wh / ratio;\n  info->ratio = ratio;\n#elif defined(IOS)\n  info->w = ww;\n  info->h = wh;\n  info->ratio = (float_t)fw / (float_t)ww;\n#else\n  info->w = ww;\n  info->h = wh;\n  info->ratio = (float_t)fw / (float_t)ww;\n#endif /**/\n\n  win->rect.x = info->x;\n  win->rect.y = info->y;\n  win->rect.w = info->w;\n  win->rect.h = info->h;\n  win->ratio = info->ratio;\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  307,
                  "img->w"
               ],
               [
                  308,
                  "img->h"
               ]
            ]
         },
         {
            "type": "func",
            "name": "native_window_sdl_on_destroy",
            "line_range": [
               458,
               463
            ],
            "source_code": "static ret_t native_window_sdl_on_destroy(object_t* obj) {\n  log_debug(\"Close native window.\\n\");\n  native_window_sdl_close(NATIVE_WINDOW(obj));\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  524,
                  "sdl->window"
               ],
               [
                  560,
                  "widget->x"
               ],
               [
                  561,
                  "widget->y"
               ],
               [
                  562,
                  "widget->w"
               ],
               [
                  563,
                  "widget->h"
               ]
            ]
         }
      ],
      "src/platforms/cmsis_os/thread.c": [
         {
            "type": "func",
            "name": "tk_thread_set_priority",
            "line_range": [
               58,
               68
            ],
            "source_code": "ret_t tk_thread_set_priority(tk_thread_t* thread, uint32_t priority) {\n  return_value_if_fail(thread != NULL, RET_BAD_PARAMS);\n\n  thread->priority = priority;\n\n  if (thread->id) {\n    osThreadSetPriority(thread->id, (osPriority)priority);\n  }\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  74,
                  "thread->args"
               ]
            ]
         },
         {
            "type": "func",
            "name": "tk_thread_create",
            "line_range": [
               86,
               98
            ],
            "source_code": "tk_thread_t* tk_thread_create(tk_thread_entry_t entry, void* args) {\n  tk_thread_t* thread = NULL;\n  return_value_if_fail(entry != NULL, NULL);\n\n  thread = (tk_thread_t*)TKMEM_ZALLOC(tk_thread_t);\n  return_value_if_fail(thread != NULL, NULL);\n\n  thread->args = args;\n  thread->entry = entry;\n  thread->mutex = tk_mutex_create();\n\n  return thread;\n}",
            "key_variables": [
               [
                  112,
                  "thread->stack_size"
               ],
               [
                  117,
                  "def->stackbase"
               ]
            ]
         }
      ],
      "src/platforms/freertos/thread.c": [
         {
            "type": "func",
            "name": "tk_thread_set_priority",
            "line_range": [
               61,
               70
            ],
            "source_code": "ret_t tk_thread_set_priority(tk_thread_t* thread, tk_thread_priority_t priority) {\n  return_value_if_fail(thread != NULL, RET_BAD_PARAMS);\n\n  thread->priority = (UBaseType_t)tk_thread_get_priority_from_platform(priority);\n  if (thread->running) {\n    vTaskPrioritySet(thread->task, thread->priority);\n  }\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  76,
                  "thread->args"
               ]
            ]
         }
      ],
      "src/platforms/pc/fs_os.c": [
         {
            "type": "func",
            "name": "fs_stat_info_from_stat",
            "line_range": [
               41,
               66
            ],
            "source_code": "static ret_t fs_stat_info_from_stat(fs_stat_info_t* fst, struct stat* st) {\n#endif /*WIN32*/\n  return_value_if_fail(fst != NULL && st != NULL, RET_BAD_PARAMS);\n\n  memset(fst, 0x00, sizeof(fs_stat_info_t));\n  fst->dev = st->st_dev;\n  fst->ino = st->st_ino;\n  fst->mode = st->st_mode;\n  fst->nlink = st->st_nlink;\n  fst->uid = st->st_uid;\n  fst->gid = st->st_gid;\n  fst->rdev = st->st_rdev;\n  fst->size = st->st_size;\n  fst->atime = st->st_atime;\n  fst->mtime = st->st_mtime;\n  fst->ctime = st->st_ctime;\n  fst->is_dir = (st->st_mode & S_IFDIR) != 0;\n#ifdef S_IFLNK\n  fst->is_link = (st->st_mode & S_IFLNK) != 0;\n#else\n  fst->is_link = FALSE;\n#endif /*S_IFLNK*/\n  fst->is_reg_file = (st->st_mode & S_IFREG) != 0;\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  47,
                  "st->st_dev"
               ],
               [
                  48,
                  "st->st_ino"
               ],
               [
                  49,
                  "st->st_mode"
               ],
               [
                  50,
                  "st->st_nlink"
               ],
               [
                  51,
                  "st->st_uid"
               ],
               [
                  52,
                  "st->st_gid"
               ],
               [
                  53,
                  "st->st_rdev"
               ],
               [
                  54,
                  "st->st_size"
               ],
               [
                  55,
                  "st->st_atime"
               ],
               [
                  56,
                  "st->st_mtime"
               ],
               [
                  57,
                  "st->st_ctime"
               ]
            ]
         },
         {
            "type": "func",
            "name": "fs_os_file_close",
            "line_range": [
               149,
               155
            ],
            "source_code": "static ret_t fs_os_file_close(fs_file_t* file) {\n  FILE* fp = (FILE*)(file->data);\n  fclose(fp);\n  TKMEM_FREE(file);\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  172,
                  "ent->d_type"
               ]
            ]
         },
         {
            "type": "func",
            "name": "fs_os_dir_rewind",
            "line_range": [
               157,
               163
            ],
            "source_code": "static ret_t fs_os_dir_rewind(fs_dir_t* dir) {\n  DIR* d = (DIR*)(dir->data);\n\n  rewinddir(d);\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  192,
                  "dir->data"
               ]
            ]
         },
         {
            "type": "func",
            "name": "fs_os_get_file_size",
            "line_range": [
               382,
               391
            ],
            "source_code": "static int32_t fs_os_get_file_size(fs_t* fs, const char* name) {\n  fs_stat_info_t st;\n  return_value_if_fail(name != NULL, FALSE);\n\n  if (fs_stat(fs, name, &st) == RET_OK && st.is_reg_file) {\n    return st.size;\n  } else {\n    return -1;\n  }\n}",
            "key_variables": [
               [
                  452,
                  "tempdir[MAX_PATH + 1]"
               ]
            ]
         },
         {
            "type": "func",
            "name": "fs_os_get_exe",
            "line_range": [
               404,
               427
            ],
            "source_code": "static ret_t fs_os_get_exe(fs_t* fs, char path[MAX_PATH + 1]) {\n  uint32_t size = MAX_PATH;\n  (void)fs;\n\n#if defined(LINUX)\n  size = readlink(\"/proc/self/exe\", path, MAX_PATH);\n  if (size >= 0) {\n    path[size] = '\\0';\n    return RET_OK;\n  } else {\n    *path = '\\0';\n    return RET_FAIL;\n  }\n#elif defined(WIN32)\n  (void)size;\n  GetModuleFileNameA(GetModuleHandle(NULL), path, MAX_PATH);\n#elif defined(__APPLE__)\n  _NSGetExecutablePath(path, &size);\n  assert(size <= MAX_PATH);\n  path[size] = '\\0';\n#endif\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  488,
                  "homedir[MAX_PATH]"
               ],
               [
                  509,
                  "wpath[MAX_PATH + 1]"
               ]
            ]
         },
         {
            "type": "func",
            "name": "fs_os_get_temp_path",
            "line_range": [
               429,
               463
            ],
            "source_code": "static ret_t fs_os_get_temp_path(fs_t* fs, char path[MAX_PATH + 1]) {\n#if defined(ANDROID)\n  const char* tempdir = SDL_AndroidGetInternalStoragePath();\n  memset(path, 0x00, MAX_PATH + 1);\n\n  return_value_if_fail(tempdir != NULL, RET_FAIL);\n  tk_strncpy(path, tempdir, MAX_PATH);\n\n  return RET_OK;\n#elif defined(LINUX) || defined(__APPLE__) || defined(IOS)\n  const char* tempdir = NULL;\n  memset(path, 0x00, MAX_PATH + 1);\n\n  if ((tempdir = getenv(\"TMPDIR\")) == NULL) {\n    tempdir = \"/tmp\";\n  }\n\n  return_value_if_fail(tempdir != NULL, RET_FAIL);\n  tk_strncpy(path, tempdir, MAX_PATH);\n\n  return RET_OK;\n#elif defined(WIN32)\n  WCHAR tempdir[MAX_PATH + 1];\n  DWORD ret = GetTempPathW(MAX_PATH, tempdir);\n  str_t str;\n  str_init(&str, MAX_PATH);\n  str_from_wstr(&str, tempdir);\n  tk_strncpy(path, str.str, MAX_PATH);\n  str_reset(&str);\n\n  return RET_OK;\n#endif\n\n  return RET_FAIL;\n}",
            "key_variables": [
               [
                  530,
                  "wname[4]"
               ],
               [
                  531,
                  "name[0]"
               ],
               [
                  532,
                  "name[1]"
               ]
            ]
         }
      ],
      "src/platforms/pc/mmap.c": [
         {
            "type": "func",
            "name": "mmap_create",
            "line_range": [
               32,
               104
            ],
            "source_code": "mmap_t* mmap_create(const char* filename, bool_t writable, bool_t shared) {\n#ifdef WIN32\n  DWORD err = 0;\n  mmap_t* map = NULL;\n  wchar_t wfilename[MAX_PATH + 1];\n  HANDLE hFile = INVALID_HANDLE_VALUE;\n  HANDLE handle = INVALID_HANDLE_VALUE;\n  DWORD flProtect = writable ? PAGE_READWRITE : PAGE_READONLY;\n  DWORD dwDesiredAccess = writable ? GENERIC_WRITE | GENERIC_READ : GENERIC_READ;\n  uint32_t size = file_get_size(filename);\n  return_value_if_fail(filename != NULL && size > 0, NULL);\n\n  map = TKMEM_ZALLOC(mmap_t);\n  goto_error_if_fail(map != NULL);\n  tk_utf8_to_utf16(filename, wfilename, MAX_PATH);\n  hFile =\n      CreateFileW(wfilename, dwDesiredAccess, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);\n  goto_error_if_fail(hFile != INVALID_HANDLE_VALUE);\n  handle = CreateFileMapping(hFile, NULL, flProtect, 0, size, NULL);\n  goto_error_if_fail(handle != NULL);\n  dwDesiredAccess = writable ? FILE_MAP_ALL_ACCESS : FILE_MAP_READ;\n\n  map->size = size;\n  map->fd = (void*)hFile;\n  map->handle = (void*)handle;\n  map->data = MapViewOfFile(handle, dwDesiredAccess, 0, 0, size);\n\n  return map;\nerror:\n  err = GetLastError();\n  log_debug(\"err=%u\\n\", err);\n  if (hFile != INVALID_HANDLE_VALUE) {\n    CloseHandle(hFile);\n  }\n  if (map != NULL) {\n    TKMEM_FREE(map);\n  }\n  return NULL;\n#else\n  int fd = 0;\n  int size = 0;\n  int flags = 0;\n  int protect = 0;\n  mmap_t* map = NULL;\n  return_value_if_fail(filename != NULL, NULL);\n  size = file_get_size(filename);\n  return_value_if_fail(size > 0, NULL);\n\n  flags = writable ? O_RDWR : O_RDONLY;\n  protect = writable ? PROT_WRITE | PROT_READ : PROT_READ;\n  fd = open(filename, flags);\n  return_value_if_fail(fd >= 0, NULL);\n\n  map = TKMEM_ZALLOC(mmap_t);\n  goto_error_if_fail(map != NULL);\n\n  flags = MAP_FILE | (shared ? MAP_SHARED : MAP_PRIVATE);\n  map->data = mmap(NULL, size, protect, flags, fd, 0);\n  goto_error_if_fail(map->handle != MAP_FAILED);\n\n  map->size = size;\n  map->fd = tk_pointer_from_int(fd);\n  return map;\nerror:\n  if (fd > 0) {\n    close(fd);\n  }\n  if (map != NULL) {\n    TKMEM_FREE(map);\n  }\n  return NULL;\n#endif /*WIN32*/\n}",
            "key_variables": [
               [
                  37,
                  "wfilename[MAX_PATH + 1]"
               ]
            ]
         }
      ],
      "src/platforms/pc/platform.c": [
         {
            "type": "func",
            "name": "date_time_set_now_impl",
            "line_range": [
               65,
               84
            ],
            "source_code": "static ret_t date_time_set_now_impl(date_time_t* dt) {\n  SYSTEMTIME wtm;\n  memset(&wtm, 0x00, sizeof(wtm));\n\n  wtm.wMinute = dt->minute;\n  wtm.wSecond = dt->second;\n  wtm.wHour = dt->hour;\n  wtm.wDay = dt->day;\n  wtm.wMonth = dt->month;\n  wtm.wYear = dt->year;\n\n  if (SetLocalTime(&wtm)) {\n    return RET_OK;\n  } else {\n    uint32_t last_error = (uint32_t)GetLastError();\n    log_debug(\"SetLocalTime(%d-%d-%d %d:%d:%d) failed: %u\\n\", (int)wtm.wYear, (int)wtm.wMonth,\n              (int)wtm.wDay, (int)wtm.wHour, (int)wtm.wMinute, (int)wtm.wSecond, last_error);\n    return RET_FAIL;\n  }\n}",
            "key_variables": [
               [
                  70,
                  "dt->minute"
               ],
               [
                  71,
                  "dt->second"
               ],
               [
                  72,
                  "dt->hour"
               ],
               [
                  73,
                  "dt->day"
               ],
               [
                  74,
                  "dt->month"
               ],
               [
                  75,
                  "dt->year"
               ],
               [
                  94,
                  "t->tm_sec"
               ],
               [
                  95,
                  "t->tm_min"
               ],
               [
                  96,
                  "t->tm_hour"
               ],
               [
                  97,
                  "t->tm_mday"
               ],
               [
                  100,
                  "t->tm_wday"
               ]
            ]
         },
         {
            "type": "func",
            "name": "date_time_get_now_impl",
            "line_range": [
               89,
               102
            ],
            "source_code": "static ret_t date_time_get_now_impl(date_time_t* dt) {\n  time_t now = time(0);\n  struct tm* t = localtime(&now);\n\n  dt->second = t->tm_sec;\n  dt->minute = t->tm_min;\n  dt->hour = t->tm_hour;\n  dt->day = t->tm_mday;\n  dt->month = t->tm_mon + 1;\n  dt->year = t->tm_year + 1900;\n  dt->wday = t->tm_wday;\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  112,
                  "dt->day"
               ],
               [
                  113,
                  "dt->hour"
               ],
               [
                  114,
                  "dt->minute"
               ],
               [
                  115,
                  "dt->second"
               ]
            ]
         },
         {
            "type": "func",
            "name": "date_time_from_time_impl",
            "line_range": [
               134,
               150
            ],
            "source_code": "static ret_t date_time_from_time_impl(date_time_t* dt, uint64_t timeval) {\n  time_t tm = timeval;\n  struct tm* t = localtime(&tm);\n  return_value_if_fail(dt != NULL, RET_BAD_PARAMS);\n\n  memset(dt, 0x00, sizeof(date_time_t));\n\n  dt->second = t->tm_sec;\n  dt->minute = t->tm_min;\n  dt->hour = t->tm_hour;\n  dt->day = t->tm_mday;\n  dt->month = t->tm_mon + 1;\n  dt->year = t->tm_year + 1900;\n  dt->wday = t->tm_wday;\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  142,
                  "t->tm_sec"
               ],
               [
                  143,
                  "t->tm_min"
               ],
               [
                  144,
                  "t->tm_hour"
               ],
               [
                  145,
                  "t->tm_mday"
               ],
               [
                  148,
                  "t->tm_wday"
               ],
               [
                  158,
                  "dt->second"
               ],
               [
                  159,
                  "dt->minute"
               ],
               [
                  160,
                  "dt->hour"
               ],
               [
                  161,
                  "dt->day"
               ],
               [
                  164,
                  "dt->wday"
               ]
            ]
         },
         {
            "type": "func",
            "name": "get_time_us64",
            "line_range": [
               176,
               178
            ],
            "source_code": "uint64_t get_time_us64() {\n  return stm_now_us();\n}",
            "key_variables": [
               [
                  204,
                  "s_heap_mem[TK_HEAP_MEM_SIZE / 4]"
               ]
            ]
         }
      ],
      "src/platforms/pc/thread_with_pthread.c": [
         {
            "type": "func",
            "name": "tk_cond_broadcast",
            "line_range": [
               125,
               135
            ],
            "source_code": "ret_t tk_cond_broadcast(tk_cond_t* cond) {\n  ret_t ret = RET_OK;\n  return_value_if_fail(cond != NULL, RET_BAD_PARAMS);\n\n  if (pthread_cond_broadcast(&cond->cond) != 0) {\n    ret = RET_FAIL;\n    log_error(\"pthread_cond_broadcast() failed\");\n  }\n\n  return ret;\n}",
            "key_variables": [
               [
                  212,
                  "name[TK_NAME_LEN + 1]"
               ]
            ]
         },
         {
            "type": "func",
            "name": "tk_semaphore_wait",
            "line_range": [
               238,
               303
            ],
            "source_code": "ret_t tk_semaphore_wait(tk_semaphore_t* semaphore, uint32_t timeout_ms) {\n#ifdef HAVE_SEM_TIMEDWAIT\n  struct timespec abstime;\n  struct timeval delta;\n#endif /*HAVE_SEM_TIMEDWAIT*/\n  return_value_if_fail(semaphore != NULL, RET_BAD_PARAMS);\n\n  if (timeout_ms == -1) {\n    int retval;\n    do {\n      retval = sem_wait(semaphore->sem);\n    } while (retval < 0 && errno == EINTR);\n\n    return_value_if_fail(retval == 0, RET_FAIL);\n    return RET_OK;\n  }\n\n#ifdef HAVE_SEM_TIMEDWAIT\n\n#ifdef HAVE_CLOCK_GETTIME\n  clock_gettime(CLOCK_REALTIME, &abstime);\n  abstime.tv_nsec += (timeout_ms % 1000) * 1000000;\n  abstime.tv_sec += timeout_ms / 1000;\n#else\n  gettimeofday(&delta, NULL);\n  abstime.tv_sec = delta.tv_sec + (timeout_ms / 1000);\n  abstime.tv_nsec = (delta.tv_usec + (timeout_ms % 1000) * 1000) * 1000;\n#endif\n\n  if (abstime.tv_nsec > 1000000000) {\n    abstime.tv_sec += 1;\n    abstime.tv_nsec -= 1000000000;\n  }\n\ntryagain:\n  if (sem_timedwait(semaphore->sem, &abstime) == 0) {\n    return RET_OK;\n  } else {\n    switch (errno) {\n      case EINTR:\n        goto tryagain;\n      case ETIMEDOUT:\n        return RET_TIMEOUT;\n    }\n    return RET_FAIL;\n  }\n#else  // HAVE_SEM_TIMEDWAIT\n\n  uint32_t start = time_now_ms();\n  return_value_if_fail(semaphore != NULL, RET_BAD_PARAMS);\n\n  do {\n    if (sem_trywait(semaphore->sem) == 0) {\n      return RET_OK;\n    }\n\n    if ((time_now_ms() - start) >= timeout_ms) {\n      return RET_TIMEOUT;\n    }\n\n    sleep_ms(1);\n  } while (TRUE);\n\n  return RET_FAIL;\n#endif  // HAVE_SEM_TIMEDWAIT\n}",
            "key_variables": [
               [
                  337,
                  "name[TK_NAME_LEN + 1]"
               ]
            ]
         },
         {
            "type": "func",
            "name": "tk_thread_get_priority_from_platform",
            "line_range": [
               357,
               359
            ],
            "source_code": "int32_t tk_thread_get_priority_from_platform(tk_thread_priority_t priority) {\n  return 0;\n}",
            "key_variables": [
               [
                  373,
                  "thread->args"
               ]
            ]
         }
      ],
      "src/platforms/pc/thread_with_sdl.c": [
         {
            "type": "func",
            "name": "tk_semaphore_wait",
            "line_range": [
               165,
               177
            ],
            "source_code": "ret_t tk_semaphore_wait(tk_semaphore_t* semaphore, uint32_t timeout_ms) {\n  int ret = 0;\n  return_value_if_fail(semaphore != NULL, RET_BAD_PARAMS);\n\n  ret = SDL_SemWaitTimeout(semaphore->sem, timeout_ms);\n  if (ret == SDL_MUTEX_TIMEDOUT) {\n    return RET_TIMEOUT;\n  } else if (ret == 0) {\n    return RET_OK;\n  }\n\n  return RET_FAIL;\n}",
            "key_variables": [
               [
                  203,
                  "name[TK_NAME_LEN + 1]"
               ]
            ]
         },
         {
            "type": "func",
            "name": "tk_thread_get_priority_from_platform",
            "line_range": [
               223,
               235
            ],
            "source_code": "int32_t tk_thread_get_priority_from_platform(tk_thread_priority_t priority) {\n  switch (priority) {\n    case TK_THREAD_PRIORITY_LOWEST:\n      return SDL_THREAD_PRIORITY_LOW;\n    case TK_THREAD_PRIORITY_HIGHEST:\n      return SDL_THREAD_PRIORITY_HIGH;\n    case TK_THREAD_PRIORITY_TIME_CRITICAL:\n      return SDL_THREAD_PRIORITY_TIME_CRITICAL;\n    case TK_THREAD_PRIORITY_NORMAL:\n    default:\n      return SDL_THREAD_PRIORITY_NORMAL;\n  }\n}",
            "key_variables": [
               [
                  249,
                  "thread->args"
               ]
            ]
         }
      ],
      "src/platforms/raw/thread_null.c": [
         {
            "type": "func",
            "name": "tk_thread_get_args",
            "line_range": [
               47,
               49
            ],
            "source_code": "void* tk_thread_get_args(tk_thread_t* thread) {\n  return thread->args;\n}",
            "key_variables": [
               [
                  49,
                  "thread->args"
               ]
            ]
         }
      ],
      "src/platforms/rtt/rtos.c": [
         {
            "type": "block",
            "name": "block",
            "line_range": "",
            "source_code": "",
            "key_variables": [
               36,
               "s_heap[4 * 1024]"
            ]
         }
      ],
      "src/platforms/rtt/thread.c": [
         {
            "type": "func",
            "name": "tk_thread_set_priority",
            "line_range": [
               60,
               68
            ],
            "source_code": "ret_t tk_thread_set_priority(tk_thread_t* thread, tk_thread_priority_t priority) {\n  return_value_if_fail(thread != NULL, RET_BAD_PARAMS);\n  thread->priority = tk_thread_get_priority_from_platform(priority);\n  if (thread->running) {\n    rt_thread_control(thread->task, RT_THREAD_CTRL_CHANGE_PRIORITY, &thread->priority);\n  }\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  74,
                  "thread->args"
               ]
            ]
         }
      ],
      "src/platforms/tos/thread.c": [
         {
            "type": "func",
            "name": "tk_thread_set_priority",
            "line_range": [
               61,
               71
            ],
            "source_code": "ret_t tk_thread_set_priority(tk_thread_t* thread, tk_thread_priority_t priority) {\n  return_value_if_fail(thread != NULL, RET_BAD_PARAMS);\n\n  /*FIXME*/\n  thread->priority = (k_prio_t)tk_thread_get_priority_from_platform(priority);\n  if (thread->running) {\n    tos_task_prio_change(&(thread->task), thread->priority);\n  }\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  77,
                  "thread->args"
               ]
            ]
         }
      ],
      "src/streams/buffered/istream_buffered.c": [
         {
            "type": "func",
            "name": "tk_istream_buffered_read",
            "line_range": [
               24,
               40
            ],
            "source_code": "static int32_t tk_istream_buffered_read(tk_istream_t* stream, uint8_t* buff, uint32_t max_size) {\n  tk_istream_buffered_t* istream_buffered = TK_ISTREAM_BUFFERED(stream);\n  tk_istream_t* real_istream = istream_buffered->real_istream;\n  ring_buffer_t* rb = istream_buffered->rb;\n\n  if (ring_buffer_is_empty(rb)) {\n    int32_t ret = tk_istream_read(real_istream, rb->data, rb->capacity);\n    if (ret <= 0) {\n      return ret;\n    }\n\n    ring_buffer_set_read_cursor(rb, 0);\n    ring_buffer_set_write_cursor(rb, ret);\n  }\n\n  return ring_buffer_read(rb, buff, max_size);\n}",
            "key_variables": [
               [
                  27,
                  "istream_buffered->real_istream"
               ],
               [
                  28,
                  "istream_buffered->rb"
               ]
            ]
         },
         {
            "type": "func",
            "name": "tk_istream_buffered_wait_for_data",
            "line_range": [
               42,
               52
            ],
            "source_code": "static ret_t tk_istream_buffered_wait_for_data(tk_istream_t* stream, uint32_t timeout_ms) {\n  tk_istream_buffered_t* istream_buffered = TK_ISTREAM_BUFFERED(stream);\n  tk_istream_t* real_istream = istream_buffered->real_istream;\n  ring_buffer_t* rb = istream_buffered->rb;\n\n  if (!ring_buffer_is_empty(rb)) {\n    return RET_OK;\n  } else {\n    return tk_istream_wait_for_data(real_istream, timeout_ms);\n  }\n}",
            "key_variables": [
               [
                  45,
                  "istream_buffered->real_istream"
               ],
               [
                  46,
                  "istream_buffered->rb"
               ],
               [
                  57,
                  "istream_buffered->real_istream"
               ]
            ]
         },
         {
            "type": "func",
            "name": "tk_istream_buffered_get_prop",
            "line_range": [
               61,
               73
            ],
            "source_code": "static ret_t tk_istream_buffered_get_prop(object_t* obj, const char* name, value_t* v) {\n  tk_istream_buffered_t* istream_buffered = TK_ISTREAM_BUFFERED(obj);\n  tk_istream_t* real_istream = istream_buffered->real_istream;\n\n  if (tk_str_eq(name, TK_STREAM_PROP_HAS_BUFFERED_DATA)) {\n    ring_buffer_t* rb = istream_buffered->rb;\n\n    value_set_bool(v, !ring_buffer_is_empty(rb));\n    return RET_OK;\n  }\n\n  return object_get_prop(OBJECT(real_istream), name, v);\n}",
            "key_variables": [
               [
                  64,
                  "istream_buffered->real_istream"
               ],
               [
                  67,
                  "istream_buffered->rb"
               ]
            ]
         }
      ],
      "src/streams/buffered/ostream_buffered.c": [
         {
            "type": "func",
            "name": "tk_ostream_buffered_write",
            "line_range": [
               24,
               33
            ],
            "source_code": "static int32_t tk_ostream_buffered_write(tk_ostream_t* stream, const uint8_t* buff,\n                                         uint32_t max_size) {\n  tk_ostream_buffered_t* ostream_buffered = TK_OSTREAM_BUFFERED(stream);\n  wbuffer_t* wb = &(ostream_buffered->wb);\n  uint32_t old_size = wb->cursor;\n\n  ENSURE(wbuffer_write_binary(wb, buff, max_size) == RET_OK);\n\n  return wb->cursor - old_size;\n}",
            "key_variables": [
               [
                  29,
                  "wb->cursor"
               ]
            ]
         },
         {
            "type": "func",
            "name": "tk_ostream_buffered_flush",
            "line_range": [
               35,
               57
            ],
            "source_code": "static ret_t tk_ostream_buffered_flush(tk_ostream_t* stream) {\n  tk_ostream_buffered_t* ostream_buffered = TK_OSTREAM_BUFFERED(stream);\n\n  if (ostream_buffered->wb.cursor > 0) {\n    wbuffer_t* wb = &(ostream_buffered->wb);\n    tk_ostream_t* ostream = ostream_buffered->real_ostream;\n    int32_t size = tk_ostream_write(ostream, wb->data, wb->cursor);\n\n    if (size < 0) {\n      return RET_FAIL;\n    } else if (size == wb->cursor) {\n      wb->cursor = 0;\n    } else {\n      void* d = wb->data;\n      void* s = wb->data + size;\n      size = wb->cursor - size;\n      memmove(d, s, size);\n      wb->cursor = size;\n    }\n  }\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  41,
                  "ostream_buffered->real_ostream"
               ],
               [
                  49,
                  "wb->data"
               ],
               [
                  62,
                  "ostream_buffered->real_ostream"
               ]
            ]
         },
         {
            "type": "func",
            "name": "tk_ostream_buffered_get_prop",
            "line_range": [
               66,
               71
            ],
            "source_code": "static ret_t tk_ostream_buffered_get_prop(object_t* obj, const char* name, value_t* v) {\n  tk_ostream_buffered_t* ostream_buffered = TK_OSTREAM_BUFFERED(obj);\n  tk_ostream_t* real_ostream = ostream_buffered->real_ostream;\n\n  return object_get_prop(OBJECT(real_ostream), name, v);\n}",
            "key_variables": [
               [
                  69,
                  "ostream_buffered->real_ostream"
               ]
            ]
         }
      ],
      "src/streams/inet/iostream_mbedtls.c": [
         {
            "type": "func",
            "name": "tk_iostream_mbedtls_get_istream",
            "line_range": [
               73,
               77
            ],
            "source_code": "static tk_istream_t* tk_iostream_mbedtls_get_istream(tk_iostream_t* stream) {\n  tk_iostream_mbedtls_t* iostream_mbedtls = TK_IOSTREAM_MBEDTLS(stream);\n\n  return iostream_mbedtls->istream;\n}",
            "key_variables": [
               [
                  77,
                  "iostream_mbedtls->istream"
               ],
               [
                  83,
                  "iostream_mbedtls->ostream"
               ]
            ]
         }
      ],
      "src/streams/inet/iostream_tcp.c": [
         {
            "type": "func",
            "name": "tk_iostream_tcp_get_istream",
            "line_range": [
               65,
               69
            ],
            "source_code": "static tk_istream_t* tk_iostream_tcp_get_istream(tk_iostream_t* stream) {\n  tk_iostream_tcp_t* iostream_tcp = TK_IOSTREAM_TCP(stream);\n\n  return iostream_tcp->istream;\n}",
            "key_variables": [
               [
                  69,
                  "iostream_tcp->istream"
               ],
               [
                  75,
                  "iostream_tcp->ostream"
               ]
            ]
         }
      ],
      "src/streams/inet/iostream_udp.c": [
         {
            "type": "func",
            "name": "tk_iostream_udp_on_destroy",
            "line_range": [
               49,
               57
            ],
            "source_code": "static ret_t tk_iostream_udp_on_destroy(object_t* obj) {\n  tk_iostream_udp_t* iostream_udp = TK_IOSTREAM_UDP(obj);\n\n  socket_close(iostream_udp->sock);\n  object_unref(OBJECT(iostream_udp->istream));\n  object_unref(OBJECT(iostream_udp->ostream));\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  69,
                  "iostream_udp->istream"
               ]
            ]
         },
         {
            "type": "func",
            "name": "tk_iostream_udp_get_ostream",
            "line_range": [
               71,
               75
            ],
            "source_code": "static tk_ostream_t* tk_iostream_udp_get_ostream(tk_iostream_t* stream) {\n  tk_iostream_udp_t* iostream_udp = TK_IOSTREAM_UDP(stream);\n\n  return iostream_udp->ostream;\n}",
            "key_variables": [
               [
                  75,
                  "iostream_udp->ostream"
               ]
            ]
         }
      ],
      "src/streams/inet/istream_mbedtls.c": [
         {
            "type": "func",
            "name": "tk_istream_mbedtls_get_prop",
            "line_range": [
               52,
               64
            ],
            "source_code": "static ret_t tk_istream_mbedtls_get_prop(object_t* obj, const char* name, value_t* v) {\n  tk_istream_mbedtls_t* istream_mbedtls = TK_ISTREAM_MBEDTLS(obj);\n  if (tk_str_eq(name, TK_STREAM_PROP_FD)) {\n    value_set_int(v, istream_mbedtls->sock);\n    return RET_OK;\n  } else if (tk_str_eq(name, TK_STREAM_PROP_IS_OK)) {\n    bool_t is_ok = istream_mbedtls->sock >= 0 && istream_mbedtls->is_broken == FALSE;\n    value_set_bool(v, is_ok);\n    return RET_OK;\n  }\n\n  return RET_NOT_FOUND;\n}",
            "key_variables": [
               [
                  85,
                  "bio->fd"
               ]
            ]
         }
      ],
      "src/streams/inet/mbedtls_client.c": [
         {
            "type": "func",
            "name": "mbedtls_conn_client_create",
            "line_range": [
               20,
               150
            ],
            "source_code": "mbedtls_conn_t* mbedtls_conn_client_create(const char* host, const char* port,\n                                           const uint8_t* cas_pem, uint32_t cas_pem_len) {\n  int ret = 0;\n  int flags = 0;\n  mbedtls_conn_t* conn = NULL;\n  const char* pers = TK_MBEDTLS_PERS;\n  mbedtls_conn_client_t* client = NULL;\n  return_value_if_fail(host != NULL && port != NULL, NULL);\n  client = TKMEM_ZALLOC(mbedtls_conn_client_t);\n  return_value_if_fail(client != NULL, NULL);\n  conn = (mbedtls_conn_t*)client;\n\n  conn->destroy = mbedtls_conn_client_destroy;\n\n#if defined(MBEDTLS_DEBUG_C)\n  mbedtls_debug_set_threshold(DEBUG_LEVEL);\n#endif\n\n  /*\n   * 0. Initialize the RNG and the session data\n   */\n  mbedtls_net_init(&(client->server_fd));\n  mbedtls_ssl_init(&(conn->ssl));\n  mbedtls_ssl_config_init(&(client->conf));\n  mbedtls_x509_crt_init(&(client->cacert));\n  mbedtls_ctr_drbg_init(&(client->ctr_drbg));\n\n  log_debug(\"\\n  . Seeding the random number generator...\");\n\n  mbedtls_entropy_init(&(client->entropy));\n  if ((ret = mbedtls_ctr_drbg_seed(&(client->ctr_drbg), mbedtls_entropy_func, &(client->entropy),\n                                   (const unsigned char*)pers, strlen(pers))) != 0) {\n    log_debug(\" failed\\n  ! mbedtls_ctr_drbg_seed returned %d\\n\", ret);\n    goto error;\n  }\n\n  log_debug(\" ok\\n\");\n\n  /*\n   * 0. Initialize certificates\n   */\n  if (cas_pem != NULL) {\n    log_debug(\"  . Loading the CA root certificate ...\");\n    ret = mbedtls_x509_crt_parse(&(client->cacert), (const unsigned char*)cas_pem, cas_pem_len);\n    if (ret < 0) {\n      log_debug(\" failed\\n  !  mbedtls_x509_crt_parse returned -0x%x\\n\\n\", (unsigned int)-ret);\n      goto error;\n    }\n  }\n  log_debug(\" ok (%d skipped)\\n\", ret);\n\n  /*\n   * 1. Start the connection\n   */\n  log_debug(\"  . Connecting to tcp/%s/%s...\", host, port);\n  if ((ret = mbedtls_net_connect(&(client->server_fd), host, port, MBEDTLS_NET_PROTO_TCP)) != 0) {\n    log_debug(\" failed\\n  ! mbedtls_net_connect returned %d\\n\\n\", ret);\n    goto error;\n  }\n\n  log_debug(\" ok\\n\");\n\n  /*\n   * 2. Setup stuff\n   */\n  log_debug(\"  . Setting up the SSL/TLS structure...\");\n\n  if ((ret = mbedtls_ssl_config_defaults(&(client->conf), MBEDTLS_SSL_IS_CLIENT,\n                                         MBEDTLS_SSL_TRANSPORT_STREAM,\n                                         MBEDTLS_SSL_PRESET_DEFAULT)) != 0) {\n    log_debug(\" failed\\n  ! mbedtls_ssl_config_defaults returned %d\\n\\n\", ret);\n    goto error;\n  }\n\n  log_debug(\" ok\\n\");\n\n  /*\n   * OPTIONAL is not optimal for security,\n   * but makes interop easier in this simplified example \n   */\n  mbedtls_ssl_conf_authmode(&(client->conf), MBEDTLS_SSL_VERIFY_OPTIONAL);\n  mbedtls_ssl_conf_ca_chain(&(client->conf), &(client->cacert), NULL);\n  mbedtls_ssl_conf_rng(&(client->conf), mbedtls_ctr_drbg_random, &(client->ctr_drbg));\n  mbedtls_ssl_conf_dbg(&(client->conf), mbedtls_awtk_debug, NULL);\n\n  if ((ret = mbedtls_ssl_setup(&(conn->ssl), &(client->conf))) != 0) {\n    log_debug(\" failed\\n  ! mbedtls_ssl_setup returned %d\\n\\n\", ret);\n    goto error;\n  }\n\n  if ((ret = mbedtls_ssl_set_hostname(&(conn->ssl), host)) != 0) {\n    log_debug(\" failed\\n  ! mbedtls_ssl_set_hostname returned %d\\n\\n\", ret);\n    goto error;\n  }\n\n  mbedtls_ssl_set_bio(&(conn->ssl), &(client->server_fd), mbedtls_net_send, mbedtls_net_recv, NULL);\n\n  /*\n   * 4. Handshake\n   */\n  log_debug(\"  . Performing the SSL/TLS handshake...\");\n\n  while ((ret = mbedtls_ssl_handshake(&(conn->ssl))) != 0) {\n    if (ret != MBEDTLS_ERR_SSL_WANT_READ && ret != MBEDTLS_ERR_SSL_WANT_WRITE) {\n      log_debug(\" failed\\n  ! mbedtls_ssl_handshake returned -0x%x\\n\\n\", (unsigned int)-ret);\n      goto error;\n    }\n  }\n\n  log_debug(\" ok\\n\");\n\n  /*\n   * 5. Verify the server certificate\n   */\n  log_debug(\"  . Verifying peer X.509 certificate...\");\n\n  /* In real life, we probably want to bail out when ret != 0 */\n  if ((flags = mbedtls_ssl_get_verify_result(&(conn->ssl))) != 0) {\n    char vrfy_buf[512];\n    log_debug(\" failed\\n\");\n    mbedtls_x509_crt_verify_info(vrfy_buf, sizeof(vrfy_buf), \"  ! \", flags);\n    log_debug(\"%s\\n\", vrfy_buf);\n  } else {\n    log_debug(\" ok\\n\");\n  }\n  return conn;\nerror:\n  mbedtls_conn_client_destroy(conn);\n\n  return NULL;\n}",
            "key_variables": [
               [
                  139,
                  "vrfy_buf[512]"
               ]
            ]
         }
      ],
      "src/streams/inet/ostream_mbedtls.c": [
         {
            "type": "func",
            "name": "tk_ostream_mbedtls_create",
            "line_range": [
               65,
               81
            ],
            "source_code": "tk_ostream_t* tk_ostream_mbedtls_create(mbedtls_ssl_context* ssl) {\n  object_t* obj = NULL;\n  mbedtls_net_context* bio = NULL;\n  tk_ostream_mbedtls_t* ostream_mbedtls = NULL;\n  return_value_if_fail(ssl != NULL, NULL);\n  bio = (mbedtls_net_context*)(ssl->p_bio);\n\n  obj = object_create(&s_tk_ostream_mbedtls_vtable);\n  ostream_mbedtls = TK_OSTREAM_MBEDTLS(obj);\n  return_value_if_fail(ostream_mbedtls != NULL, NULL);\n\n  ostream_mbedtls->ssl = ssl;\n  ostream_mbedtls->sock = bio->fd;\n  TK_OSTREAM(obj)->write = tk_ostream_mbedtls_write;\n\n  return TK_OSTREAM(obj);\n}",
            "key_variables": [
               [
                  78,
                  "bio->fd"
               ]
            ]
         }
      ],
      "src/streams/mem/iostream_mem.c": [
         {
            "type": "func",
            "name": "tk_iostream_mem_get_istream",
            "line_range": [
               40,
               44
            ],
            "source_code": "static tk_istream_t* tk_iostream_mem_get_istream(tk_iostream_t* stream) {\n  tk_iostream_mem_t* iostream_mem = TK_IOSTREAM_MEM(stream);\n\n  return iostream_mem->istream;\n}",
            "key_variables": [
               [
                  44,
                  "iostream_mem->istream"
               ]
            ]
         },
         {
            "type": "func",
            "name": "tk_iostream_mem_get_ostream",
            "line_range": [
               46,
               50
            ],
            "source_code": "static tk_ostream_t* tk_iostream_mem_get_ostream(tk_iostream_t* stream) {\n  tk_iostream_mem_t* iostream_mem = TK_IOSTREAM_MEM(stream);\n\n  return iostream_mem->ostream;\n}",
            "key_variables": [
               [
                  50,
                  "iostream_mem->ostream"
               ]
            ]
         }
      ],
      "src/streams/mem/istream_mem.c": [
         {
            "type": "func",
            "name": "tk_istream_mem_read",
            "line_range": [
               24,
               44
            ],
            "source_code": "static int32_t tk_istream_mem_read(tk_istream_t* stream, uint8_t* buff, uint32_t max_size) {\n  int32_t size = max_size;\n  tk_istream_mem_t* istream_mem = TK_ISTREAM_MEM(stream);\n\n  if (istream_mem->packet_size && istream_mem->packet_size < max_size) {\n    size = istream_mem->packet_size;\n  }\n\n  if (size > (istream_mem->size - istream_mem->cursor)) {\n    size = istream_mem->size - istream_mem->cursor;\n  }\n\n  if (size > 0) {\n    memcpy(buff, istream_mem->buff + istream_mem->cursor, size);\n    istream_mem->cursor += size;\n  } else {\n    errno = EIO;\n  }\n\n  return size;\n}",
            "key_variables": [
               [
                  30,
                  "istream_mem->packet_size"
               ],
               [
                  34,
                  "istream_mem->cursor"
               ]
            ]
         },
         {
            "type": "func",
            "name": "tk_istream_mem_seek",
            "line_range": [
               55,
               62
            ],
            "source_code": "static ret_t tk_istream_mem_seek(tk_istream_t* stream, uint32_t offset) {\n  tk_istream_mem_t* istream_mem = TK_ISTREAM_MEM(stream);\n  return_value_if_fail(offset <= istream_mem->size, RET_BAD_PARAMS);\n\n  istream_mem->cursor = offset;\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  68,
                  "istream_mem->cursor"
               ]
            ]
         },
         {
            "type": "func",
            "name": "tk_istream_mem_eos",
            "line_range": [
               70,
               74
            ],
            "source_code": "static bool_t tk_istream_mem_eos(tk_istream_t* stream) {\n  tk_istream_mem_t* istream_mem = TK_ISTREAM_MEM(stream);\n\n  return istream_mem->cursor >= istream_mem->size;\n}",
            "key_variables": [
               [
                  74,
                  "istream_mem->size"
               ]
            ]
         }
      ],
      "src/streams/mem/ostream_mem.c": [
         {
            "type": "func",
            "name": "tk_ostream_mem_write",
            "line_range": [
               24,
               42
            ],
            "source_code": "static int32_t tk_ostream_mem_write(tk_ostream_t* stream, const uint8_t* buff, uint32_t max_size) {\n  int32_t size = max_size;\n  tk_ostream_mem_t* ostream_mem = TK_OSTREAM_MEM(stream);\n\n  if (ostream_mem->packet_size && ostream_mem->packet_size < max_size) {\n    size = ostream_mem->packet_size;\n  }\n\n  if (size > (ostream_mem->size - ostream_mem->cursor)) {\n    size = ostream_mem->size - ostream_mem->cursor;\n  }\n\n  if (size > 0) {\n    memcpy(ostream_mem->buff + ostream_mem->cursor, buff, size);\n    ostream_mem->cursor += size;\n  }\n\n  return size;\n}",
            "key_variables": [
               [
                  30,
                  "ostream_mem->packet_size"
               ],
               [
                  34,
                  "ostream_mem->cursor"
               ]
            ]
         },
         {
            "type": "func",
            "name": "tk_ostream_mem_seek",
            "line_range": [
               44,
               51
            ],
            "source_code": "static ret_t tk_ostream_mem_seek(tk_ostream_t* stream, uint32_t offset) {\n  tk_ostream_mem_t* ostream_mem = TK_OSTREAM_MEM(stream);\n  return_value_if_fail(offset <= ostream_mem->size, RET_BAD_PARAMS);\n\n  ostream_mem->cursor = offset;\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  57,
                  "ostream_mem->cursor"
               ]
            ]
         }
      ],
      "src/streams/misc/ostream_retry.c": [
         {
            "type": "func",
            "name": "tk_ostream_retry_write_to_buffer",
            "line_range": [
               24,
               46
            ],
            "source_code": "static ret_t tk_ostream_retry_write_to_buffer(tk_ostream_retry_t* ostream_retry,\n                                              const uint8_t* buff, uint32_t max_size) {\n  ring_buffer_t* rb = ostream_retry->rb;\n  uint32_t size = max_size + sizeof(max_size);\n  data_discard_policy_t policy = ostream_retry->discard_policy;\n\n  if (ring_buffer_ensure_write_space(rb, size) != RET_OK) {\n    if (policy == DATA_DISCARD_NEW) {\n      ostream_retry->discard_packets++;\n      ostream_retry->discard_bytes += max_size;\n      return RET_OK;\n    } else {\n      tk_ostream_retry_clear_buffer(TK_OSTREAM(ostream_retry));\n    }\n  }\n\n  return_value_if_fail(ring_buffer_write_len(rb, &max_size, sizeof(max_size)) == RET_OK, RET_FAIL);\n  return_value_if_fail(ring_buffer_write_len(rb, buff, max_size) == RET_OK, RET_FAIL);\n  ostream_retry->pending_bytes += max_size;\n  ostream_retry->pending_packets++;\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  27,
                  "ostream_retry->rb"
               ],
               [
                  29,
                  "ostream_retry->discard_policy"
               ]
            ]
         },
         {
            "type": "func",
            "name": "tk_ostream_retry_write",
            "line_range": [
               48,
               72
            ],
            "source_code": "static int32_t tk_ostream_retry_write(tk_ostream_t* stream, const uint8_t* buff,\n                                      uint32_t max_size) {\n  tk_ostream_retry_t* ostream_retry = TK_OSTREAM_RETRY(stream);\n  tk_ostream_t* ostream = ostream_retry->real_ostream;\n  uint32_t timeout = ostream_retry->timeout;\n  ring_buffer_t* rb = ostream_retry->rb;\n\n  if (ring_buffer_size(rb) > 0) {\n    tk_ostream_flush(stream);\n  }\n\n  if (ring_buffer_size(rb) > 0) {\n    tk_ostream_retry_write_to_buffer(ostream_retry, buff, max_size);\n    tk_ostream_flush(stream);\n  } else {\n    int32_t ret = tk_ostream_write_len(ostream, buff, max_size, timeout);\n    if (ret <= 0) {\n      tk_ostream_retry_write_to_buffer(ostream_retry, buff, max_size);\n    } else if (ret < max_size) {\n      tk_ostream_retry_write_to_buffer(ostream_retry, buff + ret, max_size - ret);\n    }\n  }\n\n  return max_size;\n}",
            "key_variables": [
               [
                  52,
                  "ostream_retry->real_ostream"
               ],
               [
                  53,
                  "ostream_retry->timeout"
               ],
               [
                  54,
                  "ostream_retry->rb"
               ]
            ]
         },
         {
            "type": "func",
            "name": "tk_ostream_retry_flush",
            "line_range": [
               74,
               113
            ],
            "source_code": "static ret_t tk_ostream_retry_flush(tk_ostream_t* stream) {\n  uint32_t size = 0;\n  tk_ostream_retry_t* ostream_retry = TK_OSTREAM_RETRY(stream);\n  uint32_t timeout = ostream_retry->timeout;\n  ring_buffer_t* rb = ostream_retry->rb;\n\n  if (!ring_buffer_is_empty(rb)) {\n    wbuffer_t* wb = &(ostream_retry->wb);\n    tk_ostream_t* ostream = ostream_retry->real_ostream;\n\n    do {\n      uint32_t packet_size = 0;\n      ostream_retry->retried_times++;\n      if (ring_buffer_peek(rb, &size, sizeof(size)) != sizeof(size)) {\n        break;\n      }\n      wb->cursor = 0;\n      packet_size = size + sizeof(size);\n\n      return_value_if_fail(wbuffer_extend_capacity(wb, packet_size) == RET_OK, RET_OOM);\n      if (ring_buffer_peek(rb, wb->data, packet_size) != packet_size) {\n        break;\n      }\n\n      if (tk_ostream_write_len(ostream, wb->data + sizeof(size), size, timeout) == size) {\n        ostream_retry->retried_times = 0;\n        ostream_retry->pending_packets--;\n        ostream_retry->pending_bytes -= size;\n        ring_buffer_skip(rb, packet_size);\n      } else {\n        if (ostream_retry->retried_times == ostream_retry->max_retry_times) {\n          tk_ostream_retry_clear_buffer(stream);\n        }\n        break;\n      }\n    } while (TRUE);\n  }\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  78,
                  "ostream_retry->timeout"
               ],
               [
                  79,
                  "ostream_retry->rb"
               ],
               [
                  83,
                  "ostream_retry->real_ostream"
               ],
               [
                  118,
                  "ostream_retry->real_ostream"
               ]
            ]
         },
         {
            "type": "func",
            "name": "tk_ostream_retry_set_prop",
            "line_range": [
               115,
               120
            ],
            "source_code": "static ret_t tk_ostream_retry_set_prop(object_t* obj, const char* name, const value_t* v) {\n  tk_ostream_retry_t* ostream_retry = TK_OSTREAM_RETRY(obj);\n  tk_ostream_t* real_ostream = ostream_retry->real_ostream;\n\n  return object_set_prop(OBJECT(real_ostream), name, v);\n}",
            "key_variables": [
               [
                  125,
                  "ostream_retry->real_ostream"
               ]
            ]
         },
         {
            "type": "func",
            "name": "tk_ostream_retry_set_max_retry_times",
            "line_range": [
               167,
               174
            ],
            "source_code": "ret_t tk_ostream_retry_set_max_retry_times(tk_ostream_t* ostream, uint32_t max_retry_times) {\n  tk_ostream_retry_t* ostream_retry = TK_OSTREAM_RETRY(ostream);\n  return_value_if_fail(ostream_retry != NULL, RET_BAD_PARAMS);\n\n  ostream_retry->max_retry_times = max_retry_times;\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  179,
                  "ostream_retry->rb"
               ],
               [
                  189,
                  "ostream_retry->rb"
               ],
               [
                  193,
                  "ostream_retry->pending_bytes"
               ],
               [
                  194,
                  "ostream_retry->pending_packets"
               ]
            ]
         }
      ],
      "src/streams/noisy/iostream_noisy.c": [
         {
            "type": "func",
            "name": "tk_iostream_noisy_get_istream",
            "line_range": [
               39,
               43
            ],
            "source_code": "static tk_istream_t* tk_iostream_noisy_get_istream(tk_iostream_t* stream) {\n  tk_iostream_noisy_t* iostream_noisy = TK_IOSTREAM_NOISY(stream);\n\n  return iostream_noisy->istream;\n}",
            "key_variables": [
               [
                  43,
                  "iostream_noisy->istream"
               ]
            ]
         },
         {
            "type": "func",
            "name": "tk_iostream_noisy_get_ostream",
            "line_range": [
               45,
               49
            ],
            "source_code": "static tk_ostream_t* tk_iostream_noisy_get_ostream(tk_iostream_t* stream) {\n  tk_iostream_noisy_t* iostream_noisy = TK_IOSTREAM_NOISY(stream);\n\n  return iostream_noisy->ostream;\n}",
            "key_variables": [
               [
                  49,
                  "iostream_noisy->ostream"
               ]
            ]
         }
      ],
      "src/streams/noisy/ostream_noisy.c": [
         {
            "type": "func",
            "name": "tk_ostream_noisy_write",
            "line_range": [
               24,
               47
            ],
            "source_code": "static int32_t tk_ostream_noisy_write(tk_ostream_t* stream, const uint8_t* buff, uint32_t size) {\n  tk_ostream_noisy_t* ostream_noisy = TK_OSTREAM_NOISY(stream);\n\n  if (ostream_noisy->error_level && size > 0) {\n    wbuffer_t* wb = &(ostream_noisy->wb);\n    bool_t should_inject = ostream_noisy->write_count % ostream_noisy->error_level == 0;\n\n    wb->cursor = 0;\n    if (should_inject) {\n      uint32_t i = random() % size;\n      wbuffer_write_binary(wb, buff, size);\n\n      wb->data[i] = ~buff[i];\n      log_debug(\"inject at %u(%u) %02x => %02x\\n\", i, size, buff[i], wb->data[i]);\n      ostream_noisy->error_count++;\n      ostream_noisy->write_count++;\n\n      return tk_ostream_write(ostream_noisy->real_ostream, wb->data, size);\n    }\n  }\n\n  ostream_noisy->write_count++;\n  return tk_ostream_write(ostream_noisy->real_ostream, buff, size);\n}",
            "key_variables": [
               [
                  37,
                  "buff[i]"
               ]
            ]
         },
         {
            "type": "func",
            "name": "tk_ostream_noisy_set_prop",
            "line_range": [
               49,
               65
            ],
            "source_code": "static ret_t tk_ostream_noisy_set_prop(object_t* obj, const char* name, const value_t* v) {\n  tk_ostream_noisy_t* ostream_noisy = TK_OSTREAM_NOISY(obj);\n  tk_ostream_t* real_ostream = ostream_noisy->real_ostream;\n\n  if (tk_str_eq(name, TK_OSTREAM_NOISY_PROP_ERROR_LEVEL)) {\n    ostream_noisy->error_level = value_uint32(v);\n    return RET_OK;\n  } else if (tk_str_eq(name, TK_OSTREAM_NOISY_PROP_ERROR_COUNT)) {\n    ostream_noisy->error_count = value_uint32(v);\n    return RET_OK;\n  } else if (tk_str_eq(name, TK_OSTREAM_NOISY_PROP_WRITE_COUNT)) {\n    ostream_noisy->write_count = value_uint32(v);\n    return RET_OK;\n  }\n\n  return object_set_prop(OBJECT(real_ostream), name, v);\n}",
            "key_variables": [
               [
                  52,
                  "ostream_noisy->real_ostream"
               ]
            ]
         },
         {
            "type": "func",
            "name": "tk_ostream_noisy_get_prop",
            "line_range": [
               67,
               83
            ],
            "source_code": "static ret_t tk_ostream_noisy_get_prop(object_t* obj, const char* name, value_t* v) {\n  tk_ostream_noisy_t* ostream_noisy = TK_OSTREAM_NOISY(obj);\n  tk_ostream_t* real_ostream = ostream_noisy->real_ostream;\n\n  if (tk_str_eq(name, TK_OSTREAM_NOISY_PROP_ERROR_LEVEL)) {\n    value_set_uint32(v, ostream_noisy->error_level);\n    return RET_OK;\n  } else if (tk_str_eq(name, TK_OSTREAM_NOISY_PROP_ERROR_COUNT)) {\n    value_set_uint32(v, ostream_noisy->error_count);\n    return RET_OK;\n  } else if (tk_str_eq(name, TK_OSTREAM_NOISY_PROP_WRITE_COUNT)) {\n    value_set_uint32(v, ostream_noisy->write_count);\n    return RET_OK;\n  }\n\n  return object_get_prop(OBJECT(real_ostream), name, v);\n}",
            "key_variables": [
               [
                  70,
                  "ostream_noisy->real_ostream"
               ]
            ]
         }
      ],
      "src/streams/serial/iostream_serial.c": [
         {
            "type": "func",
            "name": "tk_iostream_serial_get_istream",
            "line_range": [
               124,
               128
            ],
            "source_code": "static tk_istream_t* tk_iostream_serial_get_istream(tk_iostream_t* stream) {\n  tk_iostream_serial_t* iostream_serial = TK_IOSTREAM_SERIAL(stream);\n\n  return iostream_serial->istream;\n}",
            "key_variables": [
               [
                  128,
                  "iostream_serial->istream"
               ],
               [
                  134,
                  "iostream_serial->ostream"
               ]
            ]
         }
      ],
      "src/streams/serial/serial_helper.c": [
         {
            "type": "func",
            "name": "serial_handle_get_fd",
            "line_range": [
               44,
               46
            ],
            "source_code": "int serial_handle_get_fd(serial_handle_t handle) {\n  return handle->client_fd;\n}",
            "key_variables": [
               [
                  46,
                  "handle->client_fd"
               ]
            ]
         },
         {
            "type": "func",
            "name": "serial_handle_get_dev",
            "line_range": [
               48,
               50
            ],
            "source_code": "serial_dev_t serial_handle_get_dev(serial_handle_t handle) {\n  return handle->dev;\n}",
            "key_variables": [
               [
                  50,
                  "handle->dev"
               ]
            ]
         },
         {
            "type": "func",
            "name": "serial_thread_entry",
            "line_range": [
               52,
               86
            ],
            "source_code": "static void* serial_thread_entry(void* args) {\n  int ret = 0;\n  DWORD err = 0;\n  BOOL b = FALSE;\n  char buff[1024];\n  DWORD bytes = 0;\n  serial_handle_t handle = (serial_handle_t)args;\n\n  int fd = handle->server_fd;\n  serial_dev_t dev = serial_handle_get_dev(handle);\n\n  handle->quited = FALSE;\n  while (!handle->closed) {\n    if (socket_wait_for_data(fd, 100) == RET_OK) {\n      ret = recv(fd, buff, sizeof(buff), 0);\n      if (ret > 0) {\n        bytes = 0;\n        b = WriteFile(dev, buff, (DWORD)(ret), &bytes, NULL);\n        if (!b) {\n          err = GetLastError();\n        }\n      }\n    }\n\n    bytes = 0;\n    b = ReadFile(dev, buff, sizeof(buff), &bytes, NULL);\n    if (b && bytes > 0) {\n      ret = send(fd, buff, bytes, 0);\n    }\n  }\n\n  handle->quited = TRUE;\n\n  return NULL;\n}",
            "key_variables": [
               [
                  57,
                  "buff[1024]"
               ],
               [
                  61,
                  "handle->server_fd"
               ],
               [
                  111,
                  "socks[0]"
               ],
               [
                  112,
                  "socks[1]"
               ]
            ]
         },
         {
            "type": "func",
            "name": "serial_close",
            "line_range": [
               840,
               850
            ],
            "source_code": "int serial_close(serial_handle_t handle) {\n  serial_dev_t dev = serial_handle_get_dev(handle);\n\n  serial_iflush(handle);\n  serial_oflush(handle);\n\n  close(dev);\n  TKMEM_FREE(handle);\n\n  return 0;\n}",
            "key_variables": [
               [
                  854,
                  "handle->dev"
               ],
               [
                  858,
                  "handle->dev"
               ]
            ]
         }
      ],
      "src/streams/shdlc/iostream_shdlc.c": [
         {
            "type": "func",
            "name": "tk_iostream_shdlc_get_istream",
            "line_range": [
               44,
               48
            ],
            "source_code": "static tk_istream_t* tk_iostream_shdlc_get_istream(tk_iostream_t* stream) {\n  tk_iostream_shdlc_t* iostream_shdlc = TK_IOSTREAM_SHDLC(stream);\n\n  return iostream_shdlc->istream;\n}",
            "key_variables": [
               [
                  48,
                  "iostream_shdlc->istream"
               ]
            ]
         },
         {
            "type": "func",
            "name": "tk_iostream_shdlc_get_ostream",
            "line_range": [
               50,
               54
            ],
            "source_code": "static tk_ostream_t* tk_iostream_shdlc_get_ostream(tk_iostream_t* stream) {\n  tk_iostream_shdlc_t* iostream_shdlc = TK_IOSTREAM_SHDLC(stream);\n\n  return iostream_shdlc->ostream;\n}",
            "key_variables": [
               [
                  54,
                  "iostream_shdlc->ostream"
               ]
            ]
         }
      ],
      "src/streams/shdlc/istream_shdlc.c": [
         {
            "type": "func",
            "name": "tk_istream_shdlc_send_ack",
            "line_range": [
               26,
               43
            ],
            "source_code": "static ret_t tk_istream_shdlc_send_ack(tk_istream_t* stream, bool_t ok, uint8_t seqno) {\n  wbuffer_t wb;\n  uint8_t buff[32];\n  tk_istream_shdlc_t* istream_shdlc = TK_ISTREAM_SHDLC(stream);\n\n  uint32_t timeout = istream_shdlc->timeout;\n  tk_ostream_t* real_ostream = istream_shdlc->iostream->real_ostream;\n\n  wbuffer_init(&wb, buff, sizeof(buff));\n  if (ok) {\n    shdlc_write_ack(&wb, seqno);\n  } else {\n    shdlc_write_nack(&wb, seqno);\n  }\n\n  return tk_ostream_write_len(real_ostream, wb.data, wb.cursor, timeout) == wb.cursor ? RET_OK\n                                                                                      : RET_IO;\n}",
            "key_variables": [
               [
                  29,
                  "buff[32]"
               ],
               [
                  32,
                  "istream_shdlc->timeout"
               ],
               [
                  33,
                  "iostream->real_ostream"
               ]
            ]
         },
         {
            "type": "func",
            "name": "tk_istream_shdlc_read_frame",
            "line_range": [
               45,
               88
            ],
            "source_code": "ret_t tk_istream_shdlc_read_frame(tk_istream_t* stream, wbuffer_t* wb, bool_t expect_data) {\n  ret_t ret = RET_OK;\n  shdlc_header_t header = {0};\n  tk_istream_shdlc_t* istream_shdlc = TK_ISTREAM_SHDLC(stream);\n\n  uint8_t seqno = 0;\n  uint32_t retry_times = 0;\n  uint32_t timeout = istream_shdlc->timeout;\n  tk_istream_t* real_istream = istream_shdlc->iostream->real_istream;\n\n  if (!object_get_prop_bool(OBJECT(real_istream), TK_STREAM_PROP_IS_OK, TRUE)) {\n    return RET_IO;\n  }\n\n  for (retry_times = 0; retry_times < istream_shdlc->retry_times; retry_times++) {\n    if (!object_get_prop_bool(OBJECT(real_istream), TK_STREAM_PROP_IS_OK, TRUE)) {\n      return RET_IO;\n    }\n\n    ret = shdlc_read_data(real_istream, wb, timeout);\n    return_value_if_fail(ret != RET_IO, RET_IO);\n\n    header.data = wb->data != NULL ? wb->data[0] : 0;\n    seqno = header.s.seqno;\n\n    if (ret == RET_CRC || ret == RET_TIMEOUT) {\n      log_debug(\"retry_times=%u\\n\", (retry_times + 1));\n      if (expect_data) {\n        return_value_if_fail(tk_istream_shdlc_send_ack(stream, FALSE, seqno) == RET_OK, RET_IO);\n        continue;\n      } else {\n        break;\n      }\n    } else if (ret == RET_OK) {\n      if (header.s.type == SHDLC_DATA) {\n        return_value_if_fail(tk_istream_shdlc_send_ack(stream, TRUE, seqno) == RET_OK, RET_IO);\n      }\n    }\n\n    break;\n  }\n\n  return ret;\n}",
            "key_variables": [
               [
                  53,
                  "istream_shdlc->timeout"
               ],
               [
                  54,
                  "iostream->real_istream"
               ],
               [
                  60,
                  "istream_shdlc->retry_times"
               ]
            ]
         },
         {
            "type": "func",
            "name": "tk_istream_shdlc_save_data_frame",
            "line_range": [
               90,
               120
            ],
            "source_code": "static ret_t tk_istream_shdlc_save_data_frame(tk_istream_t* stream, wbuffer_t* wb) {\n  shdlc_header_t header = {0};\n  tk_istream_shdlc_t* istream_shdlc = TK_ISTREAM_SHDLC(stream);\n  ring_buffer_t* rb = (istream_shdlc->rb);\n\n  header.data = wb->data[0];\n  return_value_if_fail(header.s.type == SHDLC_DATA, RET_FAIL);\n\n  if (istream_shdlc->last_seqno != header.s.seqno) {\n    const uint8_t* data = wb->data + 1;\n    uint32_t size = wb->cursor - 1;\n\n    if (header.s.compressed) {\n      compressor_t* c = istream_shdlc->compressor;\n      wbuffer_t* wb_c = &(istream_shdlc->wb_compress);\n      return_value_if_fail(compressor_uncompress(c, data, size, wb_c) == RET_OK, 0);\n      log_debug(\"compressed data: %u => %u\\n\", size, wb_c->cursor);\n\n      data = wb_c->data;\n      size = wb_c->cursor;\n    }\n\n    return_value_if_fail(ring_buffer_write_len(rb, data, size) == RET_OK, RET_OOM);\n    istream_shdlc->last_seqno = header.s.seqno;\n  } else {\n    log_debug(\"discard duplicated packet: %d\\n\", (int)(header.s.seqno));\n    tk_istream_shdlc_send_ack(stream, TRUE, header.s.seqno);\n  }\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  96,
                  "data[0]"
               ],
               [
                  104,
                  "istream_shdlc->compressor"
               ],
               [
                  109,
                  "wb_c->data"
               ],
               [
                  110,
                  "wb_c->cursor"
               ],
               [
                  133,
                  "data[0]"
               ]
            ]
         },
         {
            "type": "func",
            "name": "tk_istream_shdlc_read_ack",
            "line_range": [
               122,
               141
            ],
            "source_code": "ret_t tk_istream_shdlc_read_ack(tk_istream_t* stream, uint8_t seqno) {\n  ret_t ret = RET_OK;\n  shdlc_header_t header = {0};\n  tk_istream_shdlc_t* istream_shdlc = TK_ISTREAM_SHDLC(stream);\n  wbuffer_t* wb = &(istream_shdlc->wb);\n\n  do {\n    ret = tk_istream_shdlc_read_frame(stream, wb, FALSE);\n    return_value_if_fail(ret == RET_OK, ret);\n\n    header.data = wb->data[0];\n    if (header.s.type != SHDLC_DATA) {\n      break;\n    }\n\n    return_value_if_fail(tk_istream_shdlc_save_data_frame(stream, wb) == RET_OK, RET_OOM);\n  } while (TRUE);\n\n  return header.s.type == SHDLC_ACK ? RET_OK : RET_FAIL;\n}",
            "key_variables": [
               [
                  157,
                  "data[0]"
               ]
            ]
         },
         {
            "type": "func",
            "name": "tk_istream_shdlc_wait_for_data",
            "line_range": [
               168,
               178
            ],
            "source_code": "static ret_t tk_istream_shdlc_wait_for_data(tk_istream_t* stream, uint32_t timeout_ms) {\n  tk_istream_shdlc_t* istream_shdlc = TK_ISTREAM_SHDLC(stream);\n  tk_istream_t* real_istream = tk_iostream_get_istream(istream_shdlc->iostream->real_iostream);\n  ring_buffer_t* rb = istream_shdlc->rb;\n\n  if (!ring_buffer_is_empty(rb)) {\n    return RET_OK;\n  } else {\n    return tk_istream_wait_for_data(real_istream, timeout_ms);\n  }\n}",
            "key_variables": [
               [
                  172,
                  "istream_shdlc->rb"
               ]
            ]
         }
      ],
      "src/streams/shdlc/ostream_shdlc.c": [
         {
            "type": "func",
            "name": "tk_ostream_shdlc_write",
            "line_range": [
               27,
               70
            ],
            "source_code": "static int32_t tk_ostream_shdlc_write(tk_ostream_t* stream, const uint8_t* buff, uint32_t size) {\n  ret_t ret = 0;\n  tk_ostream_shdlc_t* ostream_shdlc = TK_OSTREAM_SHDLC(stream);\n  uint8_t seqno = ostream_shdlc->seqno;\n  uint32_t timeout = ostream_shdlc->timeout;\n  uint32_t retry_times = 0;\n  tk_istream_t* istream = ostream_shdlc->iostream->istream;\n  tk_ostream_t* real_ostream = ostream_shdlc->iostream->real_ostream;\n\n  wbuffer_t* wb = &(ostream_shdlc->wb);\n  if (ostream_shdlc->compress_threshold <= size) {\n    compressor_t* c = ostream_shdlc->compressor;\n    wbuffer_t* wb_c = &(ostream_shdlc->wb_compress);\n    return_value_if_fail(compressor_compress(c, buff, size, wb_c) == RET_OK, 0);\n    return_value_if_fail(shdlc_write_data(wb, seqno, TRUE, wb_c->data, wb_c->cursor) == RET_OK, 0);\n  } else {\n    return_value_if_fail(shdlc_write_data(wb, seqno, FALSE, buff, size) == RET_OK, 0);\n  }\n\n  while (retry_times < ostream_shdlc->retry_times) {\n    if (!object_get_prop_bool(OBJECT(real_ostream), TK_STREAM_PROP_IS_OK, TRUE)) {\n      return RET_IO;\n    }\n\n    return_value_if_fail(\n        tk_ostream_write_len(real_ostream, wb->data, wb->cursor, timeout) == wb->cursor, RET_IO);\n\n    ret = tk_istream_shdlc_read_ack(istream, seqno);\n    if (ret == RET_IO) {\n      return 0;\n    } else if (ret == RET_OK) {\n      ostream_shdlc->seqno = shdlc_seqno_inc(ostream_shdlc->seqno);\n\n      return size;\n    }\n\n    retry_times++;\n    log_debug(\"retry_times=%u\\n\", retry_times);\n  }\n\n  log_debug(\"shdlc write failed\\n\");\n\n  return 0;\n}",
            "key_variables": [
               [
                  31,
                  "ostream_shdlc->seqno"
               ],
               [
                  32,
                  "ostream_shdlc->timeout"
               ],
               [
                  34,
                  "iostream->istream"
               ],
               [
                  35,
                  "iostream->real_ostream"
               ],
               [
                  39,
                  "ostream_shdlc->compressor"
               ]
            ]
         }
      ],
      "src/streams/shdlc/shdlc_helper.c": [
         {
            "type": "func",
            "name": "shdlc_write_data",
            "line_range": [
               93,
               104
            ],
            "source_code": "ret_t shdlc_write_data(wbuffer_t* wb, uint8_t seqno, bool_t compressed, const void* data,\n                       uint32_t len) {\n  shdlc_header_t header = {0};\n  return_value_if_fail(data != NULL && len > 0, RET_BAD_PARAMS);\n\n  header.s.reserve = 0;\n  header.s.seqno = seqno;\n  header.s.type = SHDLC_DATA;\n  header.s.compressed = compressed;\n\n  return shdlc_write(wb, header, (const uint8_t*)data, len);\n}",
            "key_variables": [
               [
                  152,
                  "data[wb->cursor]"
               ],
               [
                  153,
                  "data[wb->cursor + 1]"
               ]
            ]
         }
      ],
      "src/streams/tools/https_server.c": [
         {
            "type": "func",
            "name": "main",
            "line_range": [
               4,
               28
            ],
            "source_code": "int main(int argc, char* argv[]) {\n  int32_t ret = 0;\n  mbedtls_server_t* server = NULL;\n\n  platform_prepare();\n  server =\n      mbedtls_server_create(\"4433\", (const uint8_t*)mbedtls_test_srv_crt, mbedtls_test_srv_crt_len,\n                            (const uint8_t*)mbedtls_test_srv_key, mbedtls_test_srv_key_len,\n                            (const uint8_t*)mbedtls_test_cas_pem, mbedtls_test_cas_pem_len);\n\n  if (server != NULL) {\n    char buff[1024];\n    mbedtls_conn_t* conn = mbedtls_server_accept(server);\n    tk_iostream_t* io = tk_iostream_mbedtls_create(conn);\n    tk_istream_t* in = tk_iostream_get_istream(io);\n    tk_ostream_t* out = tk_iostream_get_ostream(io);\n    ret = tk_istream_read(in, buff, sizeof(buff));\n    ret = tk_ostream_write(out, \"hello\\r\\n\", 7);\n\n    OBJECT_UNREF(io);\n    mbedtls_server_destroy(server);\n  }\n\n  return ret;\n}",
            "key_variables": [
               [
                  16,
                  "buff[1024]"
               ]
            ]
         }
      ],
      "src/streams/tools/serial_at.c": [
         {
            "type": "func",
            "name": "do_send",
            "line_range": [
               5,
               33
            ],
            "source_code": "void do_send(tk_iostream_t* iostream, const char* msg) {\n  char buff[128];\n  int32_t ret = 0;\n  tk_istream_t* istream = tk_iostream_get_istream(iostream);\n  tk_ostream_t* ostream = tk_iostream_get_ostream(iostream);\n\n  tk_snprintf(buff, sizeof(buff), \"%s\\r\\n\", msg);\n\n  ret = tk_ostream_write(ostream, (uint8_t*)buff, strlen(buff));\n  log_debug(\"send ret=%d %s\\n\", ret, buff);\n\n  ret = tk_istream_read_line(istream, (uint8_t*)buff, sizeof(buff), 5000);\n  while (ret > 0) {\n    ret = tk_istream_read_line(istream, (uint8_t*)buff, sizeof(buff), 5000);\n    sleep_ms(100);\n  }\n  tk_istream_flush(istream);\n\n  if (ret >= 0) {\n    buff[ret] = '\\0';\n    log_debug(\"read: %d %s\\n\", ret, buff);\n  } else {\n    log_debug(\"read failed\\n\");\n  }\n\n  object_unref(OBJECT(iostream));\n\n  return;\n}",
            "key_variables": [
               [
                  7,
                  "buff[128]"
               ]
            ]
         }
      ],
      "src/streams/tools/shdlc_recv.c": [
         {
            "type": "func",
            "name": "do_recv",
            "line_range": [
               10,
               46
            ],
            "source_code": "void do_recv(int port) {\n  uint8_t buff[1024];\n  int slisten = tcp_listen(port);\n  log_debug(\"listen: %d\\n\", port);\n  return_if_fail(slisten > 0);\n\n  do {\n    int ret = 0;\n    int sock = tcp_accept(slisten);\n    tk_iostream_t* tcp = tk_iostream_tcp_create(sock);\n    tk_iostream_t* shdlc = tk_iostream_shdlc_create(tcp);\n    tk_istream_t* is = tk_iostream_get_istream(shdlc);\n    tk_ostream_t* os = tk_iostream_get_ostream(shdlc);\n\n    memset(buff, 0x00, sizeof(buff));\n\n    do {\n      ret = tk_istream_read(is, buff, sizeof(buff));\n      if (ret > 0) {\n        log_debug(\"read: %s\\n\", (char*)buff);\n        ret = tk_ostream_write(os, buff, ret);\n      } else {\n        break;\n      }\n\n      if (!object_get_prop_bool(OBJECT(is), TK_STREAM_PROP_IS_OK, FALSE)) {\n        log_debug(\"client disconnected\\n\");\n        break;\n      }\n    } while (TRUE);\n\n    OBJECT_UNREF(tcp);\n    OBJECT_UNREF(shdlc);\n  } while (1);\n\n  return;\n}",
            "key_variables": [
               [
                  12,
                  "buff[1024]"
               ]
            ]
         }
      ],
      "src/streams/tools/shdlc_send.c": [
         {
            "type": "func",
            "name": "do_send",
            "line_range": [
               12,
               35
            ],
            "source_code": "void do_send(tk_iostream_t* tcp, const char* msg, uint32_t times) {\n  uint32_t i = 0;\n  int32_t s_ret = 0;\n  int32_t r_ret = 0;\n  char buff[1024 * 50];\n  tk_iostream_t* noisy = tk_iostream_noisy_create(tcp);\n  tk_iostream_t* iostream = tk_iostream_shdlc_create(noisy);\n  tk_istream_t* istream = tk_iostream_get_istream(iostream);\n  tk_ostream_t* ostream = tk_iostream_get_ostream(iostream);\n\n  for (i = 0; i < times; i++) {\n    tk_snprintf(buff, sizeof(buff), \"(%u) %s\", i, msg);\n\n    s_ret = tk_ostream_write(ostream, (uint8_t*)buff, strlen(buff));\n    memset(buff, 0x00, sizeof(buff));\n    r_ret = tk_istream_read(istream, (uint8_t*)buff, sizeof(buff));\n\n    log_debug(\"send=%d recv=%d data: %s\\n\", s_ret, r_ret, buff);\n  }\n\n  object_unref(OBJECT(iostream));\n\n  return;\n}",
            "key_variables": [
               [
                  17,
                  "buff[1024 * 50]"
               ]
            ]
         },
         {
            "type": "func",
            "name": "main",
            "line_range": [
               37,
               75
            ],
            "source_code": "int main(int argc, char* argv[]) {\n  int port = 0;\n  int sock = 0;\n  uint32_t times = 10;\n  char* content = NULL;\n  const char* msg = NULL;\n  const char* host = NULL;\n\n  if (argc != 5) {\n    printf(\"Usage: %s host port msg|@filename times\\n\", argv[0]);\n    return 0;\n  }\n\n  socket_init();\n  platform_prepare();\n  TK_ENABLE_CONSOLE();\n\n  host = argv[1];\n  port = tk_atoi(argv[2]);\n  msg = argv[3];\n  times = tk_atoi(argv[4]);\n\n  if (msg[0] == '@') {\n    uint32_t size = 0;\n    const char* filename = msg + 1;\n    content = file_read(filename, &size);\n    msg = content;\n  }\n\n  sock = tcp_connect(host, port);\n  socket_set_blocking(sock, FALSE);\n  do_send(tk_iostream_tcp_create(sock), msg, times);\n\n  TKMEM_FREE(content);\n\n  socket_deinit();\n\n  return 0;\n}",
            "key_variables": [
               [
                  55,
                  "argv[1]"
               ],
               [
                  57,
                  "argv[3]"
               ]
            ]
         }
      ],
      "src/streams/tools/udp_recv.c": [
         {
            "type": "func",
            "name": "do_recv",
            "line_range": [
               9,
               39
            ],
            "source_code": "void do_recv(int port) {\n  int32_t n = 10;\n  int32_t ret = 0;\n  char buff[1024];\n  socklen_t len = 0;\n  struct sockaddr_in addr;\n  int sock = socket(AF_INET, SOCK_DGRAM, 0);\n\n  socket_bind(sock, port);\n\n  while (n > 0) {\n    memset(buff, 0x00, sizeof(buff));\n    memset(&addr, 0x00, sizeof(addr));\n\n    len = sizeof(addr);\n    ret = recvfrom(sock, (uint8_t*)buff, sizeof(buff), 0, (struct sockaddr*)&addr, &len);\n    log_debug(\"read ret=%d %s\\n\", ret, buff);\n\n    if (ret > 0) {\n      ret = sendto(sock, (uint8_t*)buff, ret, 0, (struct sockaddr*)&addr, len);\n      log_debug(\"write %d: %s\\n\", ret, buff);\n    }\n\n    n--;\n    log_debug(\"remain %d times\\n\", n);\n  }\n\n  socket_close(sock);\n\n  return;\n}",
            "key_variables": [
               [
                  13,
                  "buff[1024]"
               ]
            ]
         }
      ],
      "src/streams/tools/udp_send.c": [
         {
            "type": "func",
            "name": "do_send",
            "line_range": [
               9,
               26
            ],
            "source_code": "void do_send(tk_iostream_t* iostream, const char* msg) {\n  char buff[1024];\n  int32_t ret = 0;\n  uint32_t size = strlen(msg) + 1;\n  tk_istream_t* istream = tk_iostream_get_istream(iostream);\n  tk_ostream_t* ostream = tk_iostream_get_ostream(iostream);\n\n  memset(buff, 0x00, sizeof(buff));\n  ret = tk_ostream_write(ostream, (uint8_t*)msg, size);\n  log_debug(\"send ret=%d %s\\n\", ret, msg);\n\n  ret = tk_istream_read(istream, (uint8_t*)buff, sizeof(buff));\n  log_debug(\"%d: %s\\n\", ret, buff);\n\n  object_unref(OBJECT(iostream));\n\n  return;\n}",
            "key_variables": [
               [
                  11,
                  "buff[1024]"
               ]
            ]
         },
         {
            "type": "func",
            "name": "main",
            "line_range": [
               28,
               51
            ],
            "source_code": "int main(int argc, char* argv[]) {\n  int port = 0;\n  const char* msg = NULL;\n  const char* host = NULL;\n\n  if (argc != 4) {\n    printf(\"Usage: %s host port msg\\n\", argv[0]);\n    return 0;\n  }\n\n  socket_init();\n  platform_prepare();\n  TK_ENABLE_CONSOLE();\n\n  host = argv[1];\n  port = tk_atoi(argv[2]);\n  msg = argv[3];\n\n  do_send(tk_iostream_udp_create_client(host, port), msg);\n\n  socket_deinit();\n\n  return 0;\n}",
            "key_variables": [
               [
                  43,
                  "argv[1]"
               ],
               [
                  45,
                  "argv[3]"
               ]
            ]
         }
      ],
      "src/svg/bsvg_draw.c": [
         {
            "type": "func",
            "name": "bsvg_draw_path",
            "line_range": [
               44,
               249
            ],
            "source_code": "ret_t bsvg_draw_path(draw_ctx_t* ctx, const svg_path_t* path) {\n  vgcanvas_t* canvas = ctx->canvas;\n\n  switch (path->type) {\n    case SVG_PATH_M: {\n      const svg_path_move_t* p = (const svg_path_move_t*)path;\n\n      ctx->x = p->x;\n      ctx->y = p->y;\n      vgcanvas_move_to(canvas, ctx->x, ctx->y);\n      /* 屏蔽了 vg 的路径镂空函数，修复 gles 和 agge 的 svg 效果同步的问题，会导致 svg 没有了路径消除的逻辑 */\n      // vgcanvas_path_winding(canvas, 0);\n      break;\n    }\n    case SVG_PATH_M_REL: {\n      const svg_path_move_t* p = (const svg_path_move_t*)path;\n\n      ctx->x += p->x;\n      ctx->y += p->y;\n      vgcanvas_move_to(canvas, ctx->x, ctx->y);\n      /* 屏蔽了 vg 的路径镂空函数，修复 gles 和 agge 的 svg 效果同步的问题，会导致 svg 没有了路径消除的逻辑 */\n      // vgcanvas_path_winding(canvas, 0);\n      break;\n    }\n    case SVG_PATH_L: {\n      const svg_path_line_t* p = (const svg_path_line_t*)path;\n\n      ctx->x = p->x;\n      ctx->y = p->y;\n      vgcanvas_line_to(canvas, ctx->x, ctx->y);\n      break;\n    }\n    case SVG_PATH_L_REL: {\n      const svg_path_line_t* p = (const svg_path_line_t*)path;\n\n      ctx->x += p->x;\n      ctx->y += p->y;\n      vgcanvas_line_to(canvas, ctx->x, ctx->y);\n      break;\n    }\n    case SVG_PATH_H: {\n      const svg_path_hline_t* p = (const svg_path_hline_t*)path;\n\n      ctx->x = p->x;\n      vgcanvas_line_to(canvas, ctx->x, ctx->y);\n      break;\n    }\n    case SVG_PATH_H_REL: {\n      const svg_path_hline_t* p = (const svg_path_hline_t*)path;\n\n      ctx->x += p->x;\n      vgcanvas_line_to(canvas, ctx->x, ctx->y);\n      break;\n    }\n    case SVG_PATH_V: {\n      const svg_path_vline_t* p = (const svg_path_vline_t*)path;\n\n      ctx->y = p->y;\n      vgcanvas_line_to(canvas, ctx->x, ctx->y);\n      break;\n    }\n    case SVG_PATH_V_REL: {\n      const svg_path_vline_t* p = (const svg_path_vline_t*)path;\n\n      ctx->y += p->y;\n      vgcanvas_line_to(canvas, ctx->x, ctx->y);\n      break;\n    }\n    case SVG_PATH_C: {\n      const svg_path_curve_to_t* p = (const svg_path_curve_to_t*)path;\n\n      vgcanvas_bezier_to(canvas, p->x1, p->y1, p->x2, p->y2, p->x, p->y);\n      ctx->x = p->x;\n      ctx->y = p->y;\n      ctx->last_x2 = p->x2;\n      ctx->last_y2 = p->y2;\n      break;\n    }\n    case SVG_PATH_C_REL: {\n      const svg_path_curve_to_t* p = (const svg_path_curve_to_t*)path;\n      float x1 = ctx->x + p->x1;\n      float y1 = ctx->y + p->y1;\n      float x2 = ctx->x + p->x2;\n      float y2 = ctx->y + p->y2;\n      float x = ctx->x + p->x;\n      float y = ctx->y + p->y;\n\n      vgcanvas_bezier_to(canvas, x1, y1, x2, y2, x, y);\n      ctx->x = x;\n      ctx->y = y;\n      ctx->last_x2 = x2;\n      ctx->last_y2 = y2;\n      break;\n    }\n    case SVG_PATH_S: {\n      const svg_path_scurve_to_t* p = (const svg_path_scurve_to_t*)path;\n      float x1 = ctx->x;\n      float y1 = ctx->y;\n      if (ctx->last_type == SVG_PATH_C_REL || ctx->last_type == SVG_PATH_C ||\n          ctx->last_type == SVG_PATH_S_REL || ctx->last_type == SVG_PATH_S) {\n        x1 = 2 * ctx->x - ctx->last_x2;\n        y1 = 2 * ctx->y - ctx->last_y2;\n      }\n      vgcanvas_bezier_to(canvas, x1, y1, p->x2, p->y2, p->x, p->y);\n\n      ctx->x = p->x;\n      ctx->y = p->y;\n      ctx->last_x2 = p->x2;\n      ctx->last_y2 = p->y2;\n      break;\n    }\n    case SVG_PATH_S_REL: {\n      const svg_path_scurve_to_t* p = (const svg_path_scurve_to_t*)path;\n      float x1 = ctx->x;\n      float y1 = ctx->y;\n      float x2 = ctx->x + p->x2;\n      float y2 = ctx->y + p->y2;\n      float x = ctx->x + p->x;\n      float y = ctx->y + p->y;\n      if (ctx->last_type == SVG_PATH_C_REL || ctx->last_type == SVG_PATH_C ||\n          ctx->last_type == SVG_PATH_S_REL || ctx->last_type == SVG_PATH_S) {\n        x1 = 2 * ctx->x - ctx->last_x2;\n        y1 = 2 * ctx->y - ctx->last_y2;\n      }\n      vgcanvas_bezier_to(canvas, x1, y1, x2, y2, x, y);\n\n      ctx->x = x;\n      ctx->y = y;\n      ctx->last_x2 = x2;\n      ctx->last_y2 = y2;\n      break;\n    }\n    case SVG_PATH_Q: {\n      const svg_path_qcurve_to_t* p = (const svg_path_qcurve_to_t*)path;\n      vgcanvas_quad_to(canvas, p->x1, p->y1, p->x, p->y);\n      ctx->x = p->x;\n      ctx->y = p->y;\n      ctx->last_x1 = p->x1;\n      ctx->last_y1 = p->y1;\n      break;\n    }\n    case SVG_PATH_Q_REL: {\n      const svg_path_qcurve_to_t* p = (const svg_path_qcurve_to_t*)path;\n      float x1 = ctx->x + p->x1;\n      float y1 = ctx->y + p->y1;\n      float x = ctx->x + p->x;\n      float y = ctx->y + p->y;\n\n      vgcanvas_quad_to(canvas, x1, y1, x, y);\n      ctx->x = x;\n      ctx->y = y;\n      ctx->last_x1 = x1;\n      ctx->last_y1 = y1;\n      break;\n    }\n    case SVG_PATH_T: {\n      const svg_path_tcurve_to_t* p = (const svg_path_tcurve_to_t*)path;\n      float x1 = 2 * ctx->x - ctx->last_x1;\n      float y1 = 2 * ctx->y - ctx->last_y1;\n\n      vgcanvas_quad_to(canvas, x1, y1, p->x, p->y);\n\n      ctx->x = p->x;\n      ctx->y = p->y;\n      ctx->last_x1 = x1;\n      ctx->last_y1 = y1;\n      break;\n    }\n    case SVG_PATH_T_REL: {\n      const svg_path_tcurve_to_t* p = (const svg_path_tcurve_to_t*)path;\n      float x1 = 2 * ctx->x - ctx->last_x1;\n      float y1 = 2 * ctx->y - ctx->last_y1;\n      float x = ctx->x + p->x;\n      float y = ctx->y + p->y;\n\n      vgcanvas_quad_to(canvas, x1, y1, x, y);\n\n      ctx->x = x;\n      ctx->y = y;\n      ctx->last_x1 = x1;\n      ctx->last_y1 = y1;\n      break;\n    }\n    case SVG_PATH_A: {\n      const svg_path_arc_t* p = (const svg_path_arc_t*)path;\n      bsvg_draw_arc_path(ctx, p);\n      break;\n    }\n    case SVG_PATH_A_REL: {\n      const svg_path_arc_t* p = (const svg_path_arc_t*)path;\n      bsvg_draw_arc_path(ctx, p);\n      break;\n    }\n    case SVG_PATH_Z: {\n      vgcanvas_close_path(canvas);\n      break;\n    }\n    case SVG_PATH_NULL:\n    default: {\n      break;\n    }\n  }\n  ctx->last_type = path->type;\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  46,
                  "ctx->canvas"
               ],
               [
                  52,
                  "p->x"
               ],
               [
                  53,
                  "p->y"
               ],
               [
                  62,
                  "p->x"
               ],
               [
                  63,
                  "p->y"
               ],
               [
                  72,
                  "p->x"
               ],
               [
                  73,
                  "p->y"
               ],
               [
                  80,
                  "p->x"
               ],
               [
                  81,
                  "p->y"
               ],
               [
                  88,
                  "p->x"
               ],
               [
                  95,
                  "p->x"
               ],
               [
                  102,
                  "p->y"
               ],
               [
                  109,
                  "p->y"
               ],
               [
                  117,
                  "p->x"
               ],
               [
                  118,
                  "p->y"
               ],
               [
                  119,
                  "p->x2"
               ],
               [
                  120,
                  "p->y2"
               ],
               [
                  125,
                  "p->x1"
               ],
               [
                  126,
                  "p->y1"
               ],
               [
                  127,
                  "p->x2"
               ],
               [
                  128,
                  "p->y2"
               ],
               [
                  129,
                  "p->x"
               ],
               [
                  130,
                  "p->y"
               ],
               [
                  141,
                  "ctx->x"
               ],
               [
                  142,
                  "ctx->y"
               ],
               [
                  145,
                  "ctx->last_x2"
               ],
               [
                  146,
                  "ctx->last_y2"
               ],
               [
                  150,
                  "p->x"
               ],
               [
                  151,
                  "p->y"
               ],
               [
                  152,
                  "p->x2"
               ],
               [
                  153,
                  "p->y2"
               ],
               [
                  158,
                  "ctx->x"
               ],
               [
                  159,
                  "ctx->y"
               ],
               [
                  160,
                  "p->x2"
               ],
               [
                  161,
                  "p->y2"
               ],
               [
                  162,
                  "p->x"
               ],
               [
                  163,
                  "p->y"
               ],
               [
                  166,
                  "ctx->last_x2"
               ],
               [
                  167,
                  "ctx->last_y2"
               ],
               [
                  180,
                  "p->x"
               ],
               [
                  181,
                  "p->y"
               ],
               [
                  182,
                  "p->x1"
               ],
               [
                  183,
                  "p->y1"
               ],
               [
                  188,
                  "p->x1"
               ],
               [
                  189,
                  "p->y1"
               ],
               [
                  190,
                  "p->x"
               ],
               [
                  191,
                  "p->y"
               ],
               [
                  202,
                  "ctx->last_x1"
               ],
               [
                  203,
                  "ctx->last_y1"
               ],
               [
                  207,
                  "p->x"
               ],
               [
                  208,
                  "p->y"
               ],
               [
                  215,
                  "ctx->last_x1"
               ],
               [
                  216,
                  "ctx->last_y1"
               ],
               [
                  217,
                  "p->x"
               ],
               [
                  218,
                  "p->y"
               ],
               [
                  247,
                  "path->type"
               ]
            ]
         },
         {
            "type": "func",
            "name": "bsvg_draw_shape_end",
            "line_range": [
               275,
               320
            ],
            "source_code": "ret_t bsvg_draw_shape_end(draw_ctx_t* ctx, const svg_shape_t* shape) {\n  vgcanvas_t* canvas = ctx->canvas;\n  bsvg_header_t* header = ctx->bsvg->header;\n\n  if (shape->line_cap) {\n    bsvg_draw_set_line_cap(canvas, shape->line_cap);\n  } else if (header->line_cap) {\n    bsvg_draw_set_line_cap(canvas, header->line_cap);\n  }\n\n  if (shape->line_join) {\n    bsvg_draw_set_line_join(canvas, shape->line_join);\n  } else if (header->line_join) {\n    bsvg_draw_set_line_join(canvas, header->line_join);\n  }\n\n  if (shape->stroke_width) {\n    vgcanvas_set_line_width(canvas, shape->stroke_width);\n  } else if (header->stroke_width) {\n    vgcanvas_set_line_width(canvas, header->stroke_width);\n  } else {\n    vgcanvas_set_line_width(canvas, 1);\n  }\n\n  if (shape->fill.rgba.a) {\n    vgcanvas_set_fill_color(canvas, shape->fill);\n  } else if (header->fill.rgba.a) {\n    vgcanvas_set_fill_color(canvas, header->fill);\n  }\n\n  if (!shape->no_fill) {\n    vgcanvas_fill(canvas);\n  }\n\n  if (shape->stroke.rgba.a) {\n    vgcanvas_set_stroke_color(canvas, shape->stroke);\n  } else if (header->stroke.rgba.a) {\n    vgcanvas_set_stroke_color(canvas, header->stroke);\n  }\n\n  if (!shape->no_stroke) {\n    vgcanvas_stroke(canvas);\n  }\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  277,
                  "ctx->canvas"
               ],
               [
                  278,
                  "bsvg->header"
               ],
               [
                  324,
                  "ctx->canvas"
               ],
               [
                  355,
                  "s->nr"
               ],
               [
                  356,
                  "data[i]"
               ],
               [
                  357,
                  "data[i + 1]"
               ],
               [
                  371,
                  "s->nr"
               ],
               [
                  372,
                  "data[i]"
               ],
               [
                  373,
                  "data[i + 1]"
               ]
            ]
         },
         {
            "type": "func",
            "name": "bsvg_draw_on_shape",
            "line_range": [
               412,
               420
            ],
            "source_code": "static ret_t bsvg_draw_on_shape(void* ctx, const void* data) {\n  draw_ctx_t* info = (draw_ctx_t*)ctx;\n  const svg_shape_t* shape = (const svg_shape_t*)data;\n\n  info->shape = shape;\n  bsvg_draw_shape(info, shape);\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  427,
                  "svg->header"
               ]
            ]
         },
         {
            "type": "func",
            "name": "calc_vector_angle",
            "line_range": [
               464,
               470
            ],
            "source_code": "static float calc_vector_angle(float ux, float uy, float vx, float vy) {\n  float ta = atan2(uy, ux);\n  float tb = atan2(vy, vx);\n  if (tb >= ta) return tb - ta;\n\n  return 2 * M_PI - (ta - tb);\n}",
            "key_variables": [
               [
                  521,
                  "info->ry"
               ],
               [
                  522,
                  "info->rx"
               ],
               [
                  537,
                  "info->num_segs"
               ],
               [
                  553,
                  "info->delta"
               ],
               [
                  575,
                  "info->seg_index"
               ]
            ]
         },
         {
            "type": "func",
            "name": "arc_info_init",
            "line_range": [
               472,
               543
            ],
            "source_code": "static ret_t arc_info_init(arc_info_t* info, pointf_t from, pointf_t to, pointf_t radii,\n                           float angle, bool_t largeArcFlag, bool_t sweepFlag) {\n  const float radPerDeg = M_PI / 180.0f;\n  info->seg_index = 0;\n\n  if (from.x == to.x && from.y == to.y) {\n    info->num_segs = 0;\n    return RET_OK;\n  }\n  /*\n  // Convert to center parameterization as shown in\n  // http://www.w3.org/TR/SVG/implnote.html\n  */\n  info->rx = fabs(radii.x);\n  info->ry = fabs(radii.y);\n\n  info->sin_phi = sin(angle * radPerDeg);\n  info->cos_phi = cos(angle * radPerDeg);\n\n  float x1dash = info->cos_phi * (from.x - to.x) / 2.0f + info->sin_phi * (from.y - to.y) / 2.0f;\n  float y1dash = -info->sin_phi * (from.x - to.x) / 2.0f + info->cos_phi * (from.y - to.y) / 2.0f;\n\n  float root;\n  float numerator = info->rx * info->rx * info->ry * info->ry -\n                    info->rx * info->rx * y1dash * y1dash - info->ry * info->ry * x1dash * x1dash;\n\n  if (numerator < 0.0f) {\n    /*\n    //  If info->rx , info->ry and are such that there is no solution (basically,\n    //  the ellipse is not big enough to reach from 'from' to 'to'\n    //  then the ellipse is scaled up uniformly until there is\n    //  exactly one solution (until the ellipse is just big enough).\n\n    // -> find factor s, such that numerator' with info->rx'=s*info->rx and\n    //    info->ry'=s*info->ry becomes 0 :\n    */\n    float s = sqrt(1.0f - numerator / (info->rx * info->rx * info->ry * info->ry));\n\n    info->rx *= s;\n    info->ry *= s;\n    root = 0.0f;\n\n  } else {\n    root = (largeArcFlag == sweepFlag ? -1.0f : 1.0f) *\n           sqrt(numerator /\n                (info->rx * info->rx * y1dash * y1dash + info->ry * info->ry * x1dash * x1dash));\n  }\n\n  float cxdash = root * info->rx * y1dash / info->ry;\n  float cydash = -root * info->ry * x1dash / info->rx;\n\n  info->c.x = info->cos_phi * cxdash - info->sin_phi * cydash + (from.x + to.x) / 2.0f;\n  info->c.y = info->sin_phi * cxdash + info->cos_phi * cydash + (from.y + to.y) / 2.0f;\n  info->theta =\n      calc_vector_angle(1.0f, 0.0f, (x1dash - cxdash) / info->rx, (y1dash - cydash) / info->ry);\n  float dtheta = calc_vector_angle((x1dash - cxdash) / info->rx, (y1dash - cydash) / info->ry,\n                                   (-x1dash - cxdash) / info->rx, (-y1dash - cydash) / info->ry);\n  if (!sweepFlag && dtheta > 0)\n    dtheta -= 2.0f * M_PI;\n  else if (sweepFlag && dtheta < 0)\n    dtheta += 2.0f * M_PI;\n\n  /* Convert into cubic bezier segments <= 90deg */\n  info->num_segs = (int32_t)(ceil(fabs(dtheta / (M_PI / 2.0f))));\n  info->delta = dtheta / info->num_segs;\n  info->t =\n      8.0f / 3.0f * sin(info->delta / 4.0f) * sin(info->delta / 4.0f) / sin(info->delta / 2.0f);\n\n  info->from = from;\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  589,
                  "ctx->canvas"
               ],
               [
                  592,
                  "ctx->x"
               ],
               [
                  593,
                  "ctx->y"
               ]
            ]
         }
      ],
      "src/svg/bsvg_to_svg.c": [
         {
            "type": "func",
            "name": "bsvg_to_svg_path",
            "line_range": [
               31,
               140
            ],
            "source_code": "ret_t bsvg_to_svg_path(str_t* str, const svg_path_t* path) {\n  char buff[128];\n\n  switch (path->type) {\n    case SVG_PATH_M: {\n      const svg_path_move_t* p = (const svg_path_move_t*)path;\n      tk_snprintf(buff, sizeof(buff) - 1, \" M%.1f %.1f\", p->x, p->y);\n      break;\n    }\n    case SVG_PATH_M_REL: {\n      const svg_path_move_t* p = (const svg_path_move_t*)path;\n      tk_snprintf(buff, sizeof(buff) - 1, \" m%.1f %.1f\", p->x, p->y);\n      break;\n    }\n    case SVG_PATH_L: {\n      const svg_path_line_t* p = (const svg_path_line_t*)path;\n      tk_snprintf(buff, sizeof(buff) - 1, \" L%.1f %.1f\", p->x, p->y);\n      break;\n    }\n    case SVG_PATH_L_REL: {\n      const svg_path_line_t* p = (const svg_path_line_t*)path;\n      tk_snprintf(buff, sizeof(buff) - 1, \" l%.1f %.1f\", p->x, p->y);\n      break;\n    }\n    case SVG_PATH_H: {\n      const svg_path_hline_t* p = (const svg_path_hline_t*)path;\n      tk_snprintf(buff, sizeof(buff) - 1, \" H%.1f\", p->x);\n      break;\n    }\n    case SVG_PATH_H_REL: {\n      const svg_path_hline_t* p = (const svg_path_hline_t*)path;\n      tk_snprintf(buff, sizeof(buff) - 1, \" h%.1f\", p->x);\n      break;\n    }\n    case SVG_PATH_V: {\n      const svg_path_vline_t* p = (const svg_path_vline_t*)path;\n      tk_snprintf(buff, sizeof(buff) - 1, \" V%.1f\", p->y);\n      break;\n    }\n    case SVG_PATH_V_REL: {\n      const svg_path_vline_t* p = (const svg_path_vline_t*)path;\n      tk_snprintf(buff, sizeof(buff) - 1, \" v%.1f\", p->y);\n      break;\n    }\n    case SVG_PATH_C: {\n      const svg_path_curve_to_t* p = (const svg_path_curve_to_t*)path;\n      tk_snprintf(buff, sizeof(buff) - 1, \" C%.1f %.1f %.1f %.1f %.1f %.1f\", p->x1, p->y1, p->x2,\n                  p->y2, p->x, p->y);\n      break;\n    }\n    case SVG_PATH_C_REL: {\n      const svg_path_curve_to_t* p = (const svg_path_curve_to_t*)path;\n      tk_snprintf(buff, sizeof(buff) - 1, \" c%.1f %.1f %.1f %.1f %.1f %.1f\", p->x1, p->y1, p->x2,\n                  p->y2, p->x, p->y);\n      break;\n    }\n    case SVG_PATH_S: {\n      const svg_path_scurve_to_t* p = (const svg_path_scurve_to_t*)path;\n      tk_snprintf(buff, sizeof(buff) - 1, \" S%.1f %.1f %.1f %.1f\", p->x2, p->y2, p->x, p->y);\n      break;\n    }\n    case SVG_PATH_S_REL: {\n      const svg_path_scurve_to_t* p = (const svg_path_scurve_to_t*)path;\n      tk_snprintf(buff, sizeof(buff) - 1, \" s%.1f %.1f %.1f %.1f\", p->x2, p->y2, p->x, p->y);\n      break;\n    }\n    case SVG_PATH_Q: {\n      const svg_path_qcurve_to_t* p = (const svg_path_qcurve_to_t*)path;\n      tk_snprintf(buff, sizeof(buff) - 1, \" Q%.1f %.1f %.1f %.1f\", p->x1, p->y1, p->x, p->y);\n      break;\n    }\n    case SVG_PATH_Q_REL: {\n      const svg_path_qcurve_to_t* p = (const svg_path_qcurve_to_t*)path;\n      tk_snprintf(buff, sizeof(buff) - 1, \" q%.1f %.1f %.1f %.1f\", p->x1, p->y1, p->x, p->y);\n      break;\n    }\n    case SVG_PATH_T: {\n      const svg_path_tcurve_to_t* p = (const svg_path_tcurve_to_t*)path;\n      tk_snprintf(buff, sizeof(buff) - 1, \" T%.1f %.1f\", p->x, p->y);\n      break;\n    }\n    case SVG_PATH_T_REL: {\n      const svg_path_tcurve_to_t* p = (const svg_path_tcurve_to_t*)path;\n      tk_snprintf(buff, sizeof(buff) - 1, \" t%.1f %.1f\", p->x, p->y);\n      break;\n    }\n    case SVG_PATH_A: {\n      const svg_path_arc_t* p = (const svg_path_arc_t*)path;\n      tk_snprintf(buff, sizeof(buff) - 1, \" A%.1f %.1f %.1f %d %d %.1f %.1f\", p->rx, p->ry,\n                  p->rotation, p->large_arc, p->sweep, p->x, p->y);\n      break;\n    }\n    case SVG_PATH_A_REL: {\n      const svg_path_arc_t* p = (const svg_path_arc_t*)path;\n      tk_snprintf(buff, sizeof(buff) - 1, \" a%.1f %.1f %.1f %d %d %.1f %.1f\", p->rx, p->ry,\n                  p->rotation, p->large_arc, p->sweep, p->x, p->y);\n      break;\n    }\n    case SVG_PATH_Z: {\n      tk_snprintf(buff, sizeof(buff) - 1, \"z\");\n      break;\n    }\n    case SVG_PATH_NULL:\n    default: {\n      break;\n    }\n  }\n\n  return str_append(str, buff);\n}",
            "key_variables": [
               [
                  33,
                  "buff[128]"
               ]
            ]
         },
         {
            "type": "func",
            "name": "bsvg_to_svg_shape_end",
            "line_range": [
               142,
               192
            ],
            "source_code": "ret_t bsvg_to_svg_shape_end(str_t* str, const svg_shape_t* shape) {\n  char buff[128];\n\n  if (shape->line_cap) {\n    const char* line_cap = \"butt\";\n    if (shape->line_cap == 'r') {\n      line_cap = \"round\";\n    } else if (shape->line_cap == 's') {\n      line_cap = \"square\";\n    }\n\n    tk_snprintf(buff, sizeof(buff) - 1, \" stroke-linecap=\\\"%s\\\"\", line_cap);\n    return_value_if_fail(str_append(str, buff) == RET_OK, RET_OOM);\n  }\n\n  if (shape->line_join) {\n    const char* line_join = \"miter\";\n    if (shape->line_join == 'r') {\n      line_join = \"round\";\n    } else if (shape->line_join == 'b') {\n      line_join = \"bevel\";\n    }\n\n    tk_snprintf(buff, sizeof(buff) - 1, \" stroke-linejoin=\\\"%s\\\"\", line_join);\n    return_value_if_fail(str_append(str, buff) == RET_OK, RET_OOM);\n  }\n\n  if (shape->stroke_width) {\n    tk_snprintf(buff, sizeof(buff) - 1, \" stroke-width==\\\"%d\\\"\", shape->stroke_width);\n    return_value_if_fail(str_append(str, buff) == RET_OK, RET_OOM);\n  }\n\n  if (shape->fill.rgba.a) {\n    const rgba_t* rgba = &(shape->fill.rgba);\n    tk_snprintf(buff, sizeof(buff) - 1, \" fill=\\\"rgba(%d,%d,%d,%.2f)\\\"\", (int)(rgba->r),\n                (int)(rgba->g), (int)(rgba->b), (float)rgba->a / 255.0f);\n    return_value_if_fail(str_append(str, buff) == RET_OK, RET_OOM);\n  }\n\n  if (shape->stroke.rgba.a) {\n    const rgba_t* rgba = &(shape->stroke.rgba);\n    tk_snprintf(buff, sizeof(buff) - 1, \" stroke=\\\"rgba(%d,%d,%d,%.2f)\\\"\", (int)(rgba->r),\n                (int)(rgba->g), (int)(rgba->b), (float)rgba->a / 255.0f);\n    return_value_if_fail(str_append(str, buff) == RET_OK, RET_OOM);\n  }\n\n  tk_snprintf(buff, sizeof(buff) - 1, \"/>\\n\");\n  return_value_if_fail(str_append(str, buff) == RET_OK, RET_OOM);\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  144,
                  "buff[128]"
               ],
               [
                  196,
                  "buff[128]"
               ],
               [
                  235,
                  "s->nr"
               ],
               [
                  248,
                  "s->nr"
               ]
            ]
         }
      ],
      "src/svg/svg_path_parser.c": [
         {
            "type": "func",
            "name": "svg_path_parser_next_token_type",
            "line_range": [
               34,
               50
            ],
            "source_code": "static token_type_t svg_path_parser_next_token_type(svg_path_parser_t* parser) {\n  const char* p = parser->p;\n  while (tk_isspace(*p) || *p == ',') {\n    p++;\n  }\n\n  parser->p = p;\n  if (!*p) {\n    return TOKEN_EOF;\n  }\n\n  if (tk_isalpha(*p)) {\n    return TOKEN_CMD;\n  } else {\n    return TOKEN_NUMBER;\n  }\n}",
            "key_variables": [
               [
                  36,
                  "parser->p"
               ]
            ]
         },
         {
            "type": "func",
            "name": "svg_path_parser_get_cmd",
            "line_range": [
               52,
               58
            ],
            "source_code": "static char svg_path_parser_get_cmd(svg_path_parser_t* parser) {\n  char c = parser->p[0];\n\n  parser->p++;\n\n  return c;\n}",
            "key_variables": [
               [
                  54,
                  "p[0]"
               ],
               [
                  64,
                  "token[TK_NUM_MAX_LEN + 1]"
               ],
               [
                  69,
                  "parser->p"
               ]
            ]
         }
      ],
      "src/svg/svg_to_bsvg.c": [
         {
            "type": "func",
            "name": "svg_on_svg_tag",
            "line_range": [
               35,
               61
            ],
            "source_code": "static void svg_on_svg_tag(bsvg_builder_t* svg, const char** attrs) {\n  uint32_t i = 0;\n  int32_t x = 0;\n  int32_t y = 0;\n  int32_t w = 0;\n  int32_t h = 0;\n\n  while (attrs[i] != NULL) {\n    const char* k = attrs[i];\n    const char* v = attrs[i + 1];\n    if (tk_str_eq(k, \"viewBox\")) {\n      tk_sscanf(v, \"%d %d %d %d\", &x, &y, &w, &h);\n\n      svg->header->viewport.x = x;\n      svg->header->viewport.y = y;\n      svg->header->viewport.w = w;\n      svg->header->viewport.h = h;\n    } else if (tk_str_eq(k, \"width\")) {\n      svg->header->w = tk_atoi(v);\n    } else if (tk_str_eq(k, \"height\")) {\n      svg->header->h = tk_atoi(v);\n    }\n    i += 2;\n  }\n\n  return;\n}",
            "key_variables": [
               [
                  44,
                  "attrs[i]"
               ],
               [
                  45,
                  "attrs[i + 1]"
               ]
            ]
         },
         {
            "type": "func",
            "name": "svg_init_shape",
            "line_range": [
               72,
               120
            ],
            "source_code": "static void svg_init_shape(bsvg_builder_t* svg, svg_shape_t* shape, const char** attrs) {\n  uint32_t i = 0;\n  bsvg_header_t* header = svg->header;\n  shape->no_stroke = TRUE;\n  shape->fill = header->fill;\n  shape->stroke = header->stroke;\n\n  while (attrs[i] != NULL) {\n    const char* k = attrs[i];\n    const char* v = attrs[i + 1];\n\n    if (v == NULL) {\n      break;\n    }\n\n    if (tk_str_eq(k, \"stroke-linecap\")) {\n      shape->line_cap = v[0];\n    } else if (tk_str_eq(k, \"stroke-linejoin\")) {\n      shape->line_join = v[0];\n    } else if (tk_str_eq(k, \"stroke-width\")) {\n      shape->stroke_width = tk_atoi(v);\n    } else if (tk_str_eq(k, \"stroke\")) {\n      if (tk_str_eq(v, \"transparent\") || tk_str_eq(v, \"none\")) {\n        shape->no_stroke = TRUE;\n      } else {\n        shape->no_stroke = FALSE;\n        if (tk_str_eq(v, \"\") || v == NULL) {\n          shape->stroke = color_init(0x00, 0x00, 0x00, 0xff);\n        } else {\n          shape->stroke = color_parse(v);\n        }\n      }\n    } else if (tk_str_eq(k, \"fill\")) {\n      if (tk_str_eq(v, \"transparent\") || tk_str_eq(v, \"none\")) {\n        shape->no_fill = TRUE;\n      } else {\n        if (tk_str_eq(v, \"\") || v == NULL) {\n          shape->fill = color_init(0x00, 0x00, 0x00, 0xff);\n        } else {\n          shape->fill = color_parse(v);\n        }\n      }\n    }\n\n    i += 2;\n  }\n\n  return;\n}",
            "key_variables": [
               [
                  75,
                  "svg->header"
               ],
               [
                  77,
                  "header->fill"
               ],
               [
                  78,
                  "header->stroke"
               ],
               [
                  81,
                  "attrs[i]"
               ],
               [
                  82,
                  "attrs[i + 1]"
               ],
               [
                  89,
                  "v[0]"
               ],
               [
                  91,
                  "v[0]"
               ],
               [
                  131,
                  "attrs[i]"
               ],
               [
                  132,
                  "attrs[i + 1]"
               ]
            ]
         },
         {
            "type": "func",
            "name": "svg_on_shape_line",
            "line_range": [
               141,
               169
            ],
            "source_code": "static void svg_on_shape_line(bsvg_builder_t* svg, const char** attrs) {\n  float x1 = 0;\n  float y1 = 0;\n  float x2 = 0;\n  float y2 = 0;\n  uint32_t i = 0;\n  svg_shape_line_t s;\n\n  while (attrs[i] != NULL) {\n    const char* k = attrs[i];\n    const char* v = attrs[i + 1];\n    if (tk_str_eq(k, \"x1\")) {\n      x1 = tk_atof(v);\n    } else if (tk_str_eq(k, \"y1\")) {\n      y1 = tk_atof(v);\n    } else if (tk_str_eq(k, \"x2\")) {\n      x2 = tk_atof(v);\n    } else if (tk_str_eq(k, \"y2\")) {\n      y2 = tk_atof(v);\n    }\n    i += 2;\n  }\n\n  svg_shape_line_init(&s, x1, y1, x2, y2);\n  svg_init_shape(svg, (svg_shape_t*)&s, attrs);\n  bsvg_builder_add_shape(svg, (svg_shape_t*)&s);\n\n  return;\n}",
            "key_variables": [
               [
                  151,
                  "attrs[i]"
               ],
               [
                  152,
                  "attrs[i + 1]"
               ],
               [
                  182,
                  "attrs[i]"
               ],
               [
                  183,
                  "attrs[i + 1]"
               ]
            ]
         },
         {
            "type": "func",
            "name": "svg_on_shape_rect",
            "line_range": [
               171,
               202
            ],
            "source_code": "static void svg_on_shape_rect(bsvg_builder_t* svg, const char** attrs) {\n  float x = 0;\n  float y = 0;\n  float w = 0;\n  float h = 0;\n  float r = 0;\n  uint32_t i = 0;\n  svg_shape_rect_t s;\n\n  while (attrs[i] != NULL) {\n    const char* k = attrs[i];\n    const char* v = attrs[i + 1];\n    if (tk_str_eq(k, \"x\")) {\n      x = tk_atof(v);\n    } else if (tk_str_eq(k, \"y\")) {\n      y = tk_atof(v);\n    } else if (tk_str_eq(k, \"width\")) {\n      w = tk_atof(v);\n    } else if (tk_str_eq(k, \"height\")) {\n      h = tk_atof(v);\n    } else if (tk_str_eq(k, \"rx\")) {\n      r = tk_atof(v);\n    }\n    i += 2;\n  }\n\n  svg_shape_rect_init(&s, x, y, w, h, r);\n  svg_init_shape(svg, (svg_shape_t*)&s, attrs);\n  bsvg_builder_add_shape(svg, (svg_shape_t*)&s);\n\n  return;\n}",
            "key_variables": [
               [
                  213,
                  "attrs[i]"
               ],
               [
                  214,
                  "attrs[i + 1]"
               ]
            ]
         },
         {
            "type": "func",
            "name": "svg_on_shape_circle",
            "line_range": [
               204,
               229
            ],
            "source_code": "static void svg_on_shape_circle(bsvg_builder_t* svg, const char** attrs) {\n  float x = 0;\n  float y = 0;\n  float r = 0;\n  uint32_t i = 0;\n  svg_shape_circle_t s;\n\n  while (attrs[i] != NULL) {\n    const char* k = attrs[i];\n    const char* v = attrs[i + 1];\n    if (tk_str_eq(k, \"cx\")) {\n      x = tk_atof(v);\n    } else if (tk_str_eq(k, \"cy\")) {\n      y = tk_atof(v);\n    } else if (tk_str_eq(k, \"r\")) {\n      r = tk_atof(v);\n    }\n    i += 2;\n  }\n\n  svg_shape_circle_init(&s, x, y, r);\n  svg_init_shape(svg, (svg_shape_t*)&s, attrs);\n  bsvg_builder_add_shape(svg, (svg_shape_t*)&s);\n\n  return;\n}",
            "key_variables": [
               [
                  241,
                  "attrs[i]"
               ],
               [
                  242,
                  "attrs[i + 1]"
               ],
               [
                  275,
                  "p[0]"
               ]
            ]
         },
         {
            "type": "func",
            "name": "svg_number_parser_get_number",
            "line_range": [
               277,
               293
            ],
            "source_code": "static float svg_number_parser_get_number(svg_number_parser_t* parser) {\n  uint32_t i = 0;\n  const char* p = NULL;\n  char token[TK_NUM_MAX_LEN + 1];\n\n  p = parser->p;\n  if (*p == '+' || *p == '-') {\n    token[i++] = *p++;\n  }\n  while (*p == '.' || (*p >= '0' && *p <= '9')) {\n    token[i++] = *p++;\n  }\n  token[i] = '\\0';\n  parser->p = p;\n\n  return tk_atof(token);\n}",
            "key_variables": [
               [
                  281,
                  "token[TK_NUM_MAX_LEN + 1]"
               ],
               [
                  283,
                  "parser->p"
               ]
            ]
         },
         {
            "type": "func",
            "name": "svg_number_parser_init",
            "line_range": [
               309,
               318
            ],
            "source_code": "static ret_t svg_number_parser_init(svg_number_parser_t* parser, const char* str, float* out,\n                                    uint32_t max_nr) {\n  parser->nr = 0;\n  parser->p = str;\n  parser->str = str;\n  parser->max_nr = max_nr;\n  parser->numbers = out;\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  339,
                  "attrs[i]"
               ],
               [
                  340,
                  "attrs[i + 1]"
               ]
            ]
         },
         {
            "type": "func",
            "name": "svg_on_shape_polygon",
            "line_range": [
               333,
               360
            ],
            "source_code": "static void svg_on_shape_polygon(bsvg_builder_t* svg, const char** attrs) {\n  uint32_t i = 0;\n  svg_shape_polygon_t* s = NULL;\n\n  while (attrs[i] != NULL) {\n    const char* k = attrs[i];\n    const char* v = attrs[i + 1];\n    if (tk_str_eq(k, \"points\")) {\n      uint32_t max_nr = svg_number_count(v);\n      s = TKMEM_ALLOC(sizeof(svg_shape_polygon_t) + sizeof(float) * max_nr);\n      return_if_fail(s != NULL);\n\n      svg_shape_polygon_init(s);\n      s->nr = svg_parse_numbers(v, s->data, max_nr);\n\n      break;\n    }\n    i += 2;\n  }\n\n  if (s != NULL) {\n    svg_init_shape(svg, (svg_shape_t*)s, attrs);\n    bsvg_builder_add_shape(svg, (svg_shape_t*)s);\n    TKMEM_FREE(s);\n  }\n\n  return;\n}",
            "key_variables": [
               [
                  368,
                  "attrs[i]"
               ],
               [
                  369,
                  "attrs[i + 1]"
               ]
            ]
         }
      ],
      "src/tkc/action_queue.c": [
         {
            "type": "func",
            "name": "action_queue_recv",
            "line_range": [
               39,
               55
            ],
            "source_code": "ret_t action_queue_recv(action_queue_t* q, qaction_t** action) {\n  return_value_if_fail(q != NULL && action != NULL, RET_BAD_PARAMS);\n  if (q->r != q->w || q->full) {\n    *action = q->actions[q->r];\n    q->actions[q->r] = NULL;\n    if ((q->r + 1) < q->capacity) {\n      q->r++;\n    } else {\n      q->r = 0;\n    }\n    q->full = FALSE;\n\n    return RET_OK;\n  }\n\n  return RET_FAIL;\n}",
            "key_variables": [
               [
                  43,
                  "actions[q->r]"
               ]
            ]
         },
         {
            "type": "func",
            "name": "action_queue_send",
            "line_range": [
               57,
               75
            ],
            "source_code": "ret_t action_queue_send(action_queue_t* q, qaction_t* action) {\n  return_value_if_fail(q != NULL && action != NULL, RET_BAD_PARAMS);\n  if (q->r != q->w || !q->full) {\n    q->actions[q->w] = action;\n\n    if ((q->w + 1) < q->capacity) {\n      q->w++;\n    } else {\n      q->w = 0;\n    }\n    if (q->r == q->w) {\n      q->full = TRUE;\n    }\n\n    return RET_OK;\n  }\n\n  return RET_FAIL;\n}",
            "key_variables": [
               [
                  81,
                  "q->capacity"
               ]
            ]
         }
      ],
      "src/tkc/action_thread_pool.c": [
         {
            "type": "func",
            "name": "action_thread_pool_get_thread_nr",
            "line_range": [
               65,
               81
            ],
            "source_code": "static uint32_t action_thread_pool_get_thread_nr(action_thread_pool_t* thread_pool) {\n  uint32_t i = 0;\n  uint32_t n = 0;\n  action_thread_t* thread = NULL;\n  return_value_if_fail(thread_pool != NULL, 0);\n  return_value_if_fail(tk_mutex_lock(thread_pool->mutex) == RET_OK, 0);\n\n  for (i = 0; i < thread_pool->max_thread_nr; i++) {\n    thread = thread_pool->threads[i];\n    if (thread != NULL) {\n      n++;\n    }\n  }\n  tk_mutex_unlock(thread_pool->mutex);\n\n  return n;\n}",
            "key_variables": [
               [
                  73,
                  "thread_pool->max_thread_nr"
               ],
               [
                  74,
                  "threads[i]"
               ],
               [
                  91,
                  "thread_pool->max_thread_nr"
               ]
            ]
         },
         {
            "type": "func",
            "name": "action_thread_pool_create_thread",
            "line_range": [
               103,
               120
            ],
            "source_code": "static ret_t action_thread_pool_create_thread(action_thread_pool_t* thread_pool) {\n  uint32_t i = 0;\n  return_value_if_fail(thread_pool != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(tk_mutex_lock(thread_pool->mutex) == RET_OK, RET_BAD_PARAMS);\n\n  for (i = 0; i < thread_pool->max_thread_nr; i++) {\n    if (thread_pool->threads[i] == NULL) {\n      thread_pool->threads[i] = action_thread_create_with_queue_ex(\n          thread_pool->queue, NULL, thread_pool->stack_size, thread_pool->priority);\n      action_thread_set_on_idle(thread_pool->threads[i],\n                                (action_thread_on_idle_t)action_thread_pool_on_thread_idle,\n                                thread_pool);\n      break;\n    }\n  }\n\n  return tk_mutex_unlock(thread_pool->mutex);\n}",
            "key_variables": [
               [
                  109,
                  "thread_pool->max_thread_nr"
               ]
            ]
         },
         {
            "type": "func",
            "name": "action_thread_pool_ensure_threads",
            "line_range": [
               122,
               131
            ],
            "source_code": "static ret_t action_thread_pool_ensure_threads(action_thread_pool_t* thread_pool) {\n  uint32_t thread_nr = action_thread_pool_get_thread_nr(thread_pool);\n  return_value_if_fail(thread_pool != NULL, RET_BAD_PARAMS);\n\n  if (thread_nr < thread_pool->min_idle_nr) {\n    return action_thread_pool_create_thread(thread_pool);\n  }\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  150,
                  "thread_pool->max_thread_nr"
               ],
               [
                  151,
                  "threads[i]"
               ]
            ]
         }
      ],
      "src/tkc/asset_info.c": [
         {
            "type": "func",
            "name": "asset_info_ref",
            "line_range": [
               111,
               119
            ],
            "source_code": "ret_t asset_info_ref(asset_info_t* info) {\n  return_value_if_fail(info != NULL, RET_BAD_PARAMS);\n\n  if (!(info->is_in_rom)) {\n    info->refcount++;\n  }\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  125,
                  "info->type"
               ],
               [
                  131,
                  "info->name"
               ]
            ]
         }
      ],
      "src/tkc/async.c": [
         {
            "type": "func",
            "name": "qaction_async_exec",
            "line_range": [
               47,
               51
            ],
            "source_code": "static ret_t qaction_async_exec(qaction_t* action) {\n  async_call_info_t* info = (async_call_info_t*)action->args;\n\n  return info->exec(info->ctx);\n}",
            "key_variables": [
               [
                  49,
                  "action->args"
               ],
               [
                  55,
                  "action->args"
               ]
            ]
         }
      ],
      "src/tkc/buffer.c": [
         {
            "type": "func",
            "name": "wbuffer_write_float",
            "line_range": [
               153,
               160
            ],
            "source_code": "ret_t wbuffer_write_float(wbuffer_t* wbuffer, float value) {\n  return_value_if_fail(wbuffer_extend_delta(wbuffer, sizeof(value)) == RET_OK, RET_BAD_PARAMS);\n\n  memcpy(wbuffer->data + wbuffer->cursor, &value, sizeof(value));\n  wbuffer->cursor += sizeof(value);\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  184,
                  "wbuffer->capacity"
               ]
            ]
         },
         {
            "type": "func",
            "name": "rbuffer_init",
            "line_range": [
               192,
               200
            ],
            "source_code": "rbuffer_t* rbuffer_init(rbuffer_t* rbuffer, const uint8_t* data, uint32_t capacity) {\n  return_value_if_fail(rbuffer != NULL && data != NULL, NULL);\n\n  rbuffer->data = data;\n  rbuffer->cursor = 0;\n  rbuffer->capacity = capacity;\n\n  return rbuffer;\n}",
            "key_variables": [
               [
                  206,
                  "rbuffer->capacity"
               ]
            ]
         },
         {
            "type": "func",
            "name": "rbuffer_skip",
            "line_range": [
               215,
               223
            ],
            "source_code": "ret_t rbuffer_skip(rbuffer_t* rbuffer, int32_t offset) {\n  return_value_if_fail(rbuffer != NULL && rbuffer->data != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(((int32_t)(rbuffer->cursor) + offset) >= 0, RET_BAD_PARAMS);\n  return_value_if_fail(((int32_t)(rbuffer->cursor) + offset) <= rbuffer->capacity, RET_BAD_PARAMS);\n\n  rbuffer->cursor += offset;\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  230,
                  "data[rbuffer->cursor++]"
               ]
            ]
         },
         {
            "type": "func",
            "name": "rbuffer_read_double",
            "line_range": [
               284,
               292
            ],
            "source_code": "ret_t rbuffer_read_double(rbuffer_t* rbuffer, double* value) {\n  return_value_if_fail(rbuffer != NULL && rbuffer->data != NULL && value != NULL, RET_BAD_PARAMS);\n  return_value_if_fail((rbuffer->cursor + sizeof(*value)) <= rbuffer->capacity, RET_BAD_PARAMS);\n\n  memcpy(value, rbuffer->data + rbuffer->cursor, sizeof(*value));\n  rbuffer->cursor += sizeof(*value);\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  308,
                  "rbuffer->cursor"
               ],
               [
                  318,
                  "data[rbuffer->cursor]"
               ]
            ]
         }
      ],
      "src/tkc/color.c": [
         {
            "type": "func",
            "name": "color_hex_str",
            "line_range": [
               63,
               73
            ],
            "source_code": "const char* color_hex_str(color_t c, char str[TK_COLOR_HEX_LEN + 1]) {\n  if (c.rgba.a == 0xff) {\n    tk_snprintf(str, TK_COLOR_HEX_LEN, \"#%02X%02X%02X\", (int)(c.rgba.r), (int)(c.rgba.g),\n                (int)(c.rgba.b));\n  } else {\n    tk_snprintf(str, TK_COLOR_HEX_LEN, \"#%02x%02x%02x%02x\", (int)(c.rgba.r), (int)(c.rgba.g),\n                (int)(c.rgba.b), (int)(c.rgba.a));\n  }\n\n  return str;\n}",
            "key_variables": [
               [
                  88,
                  "c->color"
               ]
            ]
         }
      ],
      "src/tkc/crc.c": [
         {
            "type": "func",
            "name": "tk_crc16_byte",
            "line_range": [
               55,
               57
            ],
            "source_code": "uint16_t tk_crc16_byte(uint16_t crc, uint8_t data) {\n  return (crc >> 8) ^ fcstab_16[(crc ^ (data)) & 0xff];\n}",
            "key_variables": [
               [
                  57,
                  "fcstab_16[(crc ^ (data)) & 0xff]"
               ]
            ]
         },
         {
            "type": "func",
            "name": "tk_crc16",
            "line_range": [
               59,
               67
            ],
            "source_code": "uint16_t tk_crc16(uint16_t crc, const uint8_t* data, int data_length) {\n  while (data_length) {\n    crc = (crc >> 8) ^ fcstab_16[(crc ^ (*data)) & 0xff];\n    data++;\n    data_length--;\n  }\n\n  return crc ^ ~0U;\n}",
            "key_variables": [
               [
                  62,
                  "fcstab_16[(crc ^ (*data)) & 0xff]"
               ]
            ]
         },
         {
            "type": "func",
            "name": "tk_chksum",
            "line_range": [
               77,
               85
            ],
            "source_code": "uint16_t tk_chksum(uint16_t sum, const uint8_t* data, int data_length) {\n  while (data_length) {\n    sum = sum + *data;\n    data++;\n    data_length--;\n  }\n\n  return 0xFFFF - sum;\n}",
            "key_variables": [
               [
                  176,
                  "crc_tab32[(crc ^ (uint32_t)*ptr++) & 0x000000FFul]"
               ]
            ]
         },
         {
            "type": "func",
            "name": "tk_crc32",
            "line_range": [
               168,
               180
            ],
            "source_code": "uint32_t tk_crc32(uint32_t init, const uint8_t* data, int size) {\n  size_t a = 0;\n  uint32_t crc = init;\n  const unsigned char* ptr = data;\n\n  if (ptr != NULL)\n    for (a = 0; a < size; a++) {\n      crc = (crc >> 8) ^ crc_tab32[(crc ^ (uint32_t)*ptr++) & 0x000000FFul];\n    }\n\n  return (crc ^ 0xFFFFFFFFul);\n\n} /* crc_32 */",
            "key_variables": [
               [
                  184,
                  "crc_tab32[(crc ^ (uint32_t)data) & 0x000000FFul]"
               ]
            ]
         }
      ],
      "src/tkc/darray.c": [
         {
            "type": "func",
            "name": "darray_find_index_ex",
            "line_range": [
               79,
               99
            ],
            "source_code": "int32_t darray_find_index_ex(darray_t* darray, tk_compare_t compare, void* data) {\n  int32_t i = 0;\n  int32_t size = 0;\n  void** elms = NULL;\n  return_value_if_fail(darray != NULL, -1);\n  elms = darray->elms;\n  size = darray->size;\n\n  if (compare == NULL) {\n    compare = darray->compare ? darray->compare : pointer_compare;\n  }\n\n  for (i = 0; i < size; i++) {\n    void* iter = elms[i];\n    if (compare(iter, data) == 0) {\n      return i;\n    }\n  }\n\n  return -1;\n}",
            "key_variables": [
               [
                  85,
                  "darray->elms"
               ],
               [
                  86,
                  "darray->size"
               ],
               [
                  93,
                  "elms[i]"
               ]
            ]
         },
         {
            "type": "func",
            "name": "darray_find_index",
            "line_range": [
               101,
               103
            ],
            "source_code": "int32_t darray_find_index(darray_t* darray, void* data) {\n  return darray_find_index_ex(darray, NULL, data);\n}",
            "key_variables": [
               [
                  112,
                  "darray->elms"
               ],
               [
                  117,
                  "elms[i + 1]"
               ]
            ]
         },
         {
            "type": "func",
            "name": "darray_remove",
            "line_range": [
               137,
               139
            ],
            "source_code": "ret_t darray_remove(darray_t* darray, void* data) {\n  return darray_remove_ex(darray, NULL, data);\n}",
            "key_variables": [
               [
                  149,
                  "darray->elms"
               ],
               [
                  150,
                  "darray->size"
               ],
               [
                  151,
                  "darray->compare"
               ],
               [
                  154,
                  "elms[i]"
               ],
               [
                  160,
                  "elms[i]"
               ]
            ]
         },
         {
            "type": "func",
            "name": "darray_remove_all",
            "line_range": [
               141,
               167
            ],
            "source_code": "ret_t darray_remove_all(darray_t* darray, tk_compare_t cmp, void* ctx) {\n  int32_t i = 0;\n  int32_t k = 0;\n  int32_t size = 0;\n  void** elms = NULL;\n  return_value_if_fail(darray != NULL, RET_BAD_PARAMS);\n\n  elms = darray->elms;\n  size = darray->size;\n  cmp = cmp != NULL ? cmp : darray->compare;\n\n  for (i = 0, k = 0; i < size; i++) {\n    void* iter = elms[i];\n    if (cmp(iter, ctx) == 0) {\n      darray->destroy(iter);\n      elms[i] = NULL;\n    } else {\n      if (k != i) {\n        elms[k] = elms[i];\n      }\n      k++;\n    }\n  }\n  darray->size = k;\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  172,
                  "darray->compare"
               ],
               [
                  183,
                  "darray->elms"
               ],
               [
                  184,
                  "darray->size"
               ],
               [
                  185,
                  "darray->compare"
               ],
               [
                  188,
                  "elms[i]"
               ]
            ]
         },
         {
            "type": "func",
            "name": "darray_find_ex",
            "line_range": [
               196,
               200
            ],
            "source_code": "void* darray_find_ex(darray_t* darray, tk_compare_t cmp, void* ctx) {\n  int32_t pos = darray_find_index_ex(darray, cmp, ctx);\n\n  return pos >= 0 ? darray->elms[pos] : NULL;\n}",
            "key_variables": [
               [
                  211,
                  "elms[--darray->size]"
               ],
               [
                  220,
                  "elms[darray->size - 1]"
               ]
            ]
         },
         {
            "type": "func",
            "name": "darray_head",
            "line_range": [
               222,
               226
            ],
            "source_code": "void* darray_head(darray_t* darray) {\n  return_value_if_fail(darray != NULL && darray->size > 0, NULL);\n\n  return darray->elms[0];\n}",
            "key_variables": [
               [
                  226,
                  "elms[0]"
               ],
               [
                  238,
                  "darray->size"
               ]
            ]
         },
         {
            "type": "func",
            "name": "darray_push",
            "line_range": [
               275,
               279
            ],
            "source_code": "ret_t darray_push(darray_t* darray, void* data) {\n  return_value_if_fail(darray != NULL, RET_BAD_PARAMS);\n\n  return darray_insert(darray, darray->size, data);\n}",
            "key_variables": [
               [
                  288,
                  "darray->elms"
               ],
               [
                  290,
                  "darray->size"
               ],
               [
                  291,
                  "elms[i]"
               ],
               [
                  306,
                  "darray->elms"
               ],
               [
                  308,
                  "darray->size"
               ],
               [
                  309,
                  "elms[i]"
               ]
            ]
         },
         {
            "type": "func",
            "name": "darray_count",
            "line_range": [
               281,
               298
            ],
            "source_code": "int32_t darray_count(darray_t* darray, void* data) {\n  int32_t n = 0;\n  return_value_if_fail(darray != NULL, 0);\n\n  if (darray->elms != NULL) {\n    uint32_t i = 0;\n    void** elms = darray->elms;\n\n    for (i = 0; i < darray->size; i++) {\n      void* iter = elms[i];\n      if (darray->compare(iter, data) == 0) {\n        n++;\n      }\n    }\n  }\n\n  return n;\n}",
            "key_variables": [
               [
                  325,
                  "darray->elms"
               ],
               [
                  327,
                  "darray->size"
               ],
               [
                  328,
                  "elms[i]"
               ]
            ]
         },
         {
            "type": "func",
            "name": "darray_set",
            "line_range": [
               337,
               343
            ],
            "source_code": "ret_t darray_set(darray_t* darray, uint32_t index, void* data) {\n  return_value_if_fail(darray != NULL && index < darray->size, RET_BAD_PARAMS);\n\n  darray->elms[index] = data;\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  360,
                  "elms[index]"
               ]
            ]
         },
         {
            "type": "func",
            "name": "darray_deinit",
            "line_range": [
               362,
               372
            ],
            "source_code": "ret_t darray_deinit(darray_t* darray) {\n  return_value_if_fail(darray != NULL, RET_BAD_PARAMS);\n\n  if (darray->elms != NULL) {\n    darray_clear(darray);\n    TKMEM_FREE(darray->elms);\n    memset(darray, 0x00, sizeof(darray_t));\n  }\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  397,
                  "darray->compare"
               ],
               [
                  403,
                  "elms[mid]"
               ]
            ]
         },
         {
            "type": "func",
            "name": "darray_destroy",
            "line_range": [
               374,
               381
            ],
            "source_code": "ret_t darray_destroy(darray_t* darray) {\n  return_value_if_fail(darray != NULL, RET_BAD_PARAMS);\n\n  darray_deinit(darray);\n  TKMEM_FREE(darray);\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  430,
                  "elms[index]"
               ]
            ]
         }
      ],
      "src/tkc/data_reader_factory.c": [
         {
            "type": "block",
            "name": "block",
            "line_range": "",
            "source_code": "",
            "key_variables": [
               32,
               "protocol[TK_NAME_LEN + 1]"
            ]
         },
         {
            "type": "func",
            "name": "data_reader_factory_register",
            "line_range": [
               58,
               71
            ],
            "source_code": "ret_t data_reader_factory_register(data_reader_factory_t* factory, const char* protocol,\n                                   data_reader_create_t create) {\n  creator_item_t* item = NULL;\n  return_value_if_fail(factory != NULL && protocol != NULL && create != NULL, RET_BAD_PARAMS);\n\n  item = TKMEM_ZALLOC(creator_item_t);\n  return_value_if_fail(item != NULL, RET_OOM);\n\n  item->create = create;\n  tk_strncpy(item->protocol, protocol, TK_NAME_LEN);\n  darray_push(&(factory->creators), item);\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  75,
                  "protocol[TK_NAME_LEN + 1]"
               ]
            ]
         }
      ],
      "src/tkc/data_reader_file.c": [
         {
            "type": "func",
            "name": "data_reader_file_get_size",
            "line_range": [
               40,
               44
            ],
            "source_code": "static uint64_t data_reader_file_get_size(data_reader_t* reader) {\n  data_reader_file_t* file = (data_reader_file_t*)reader;\n\n  return file->size;\n}",
            "key_variables": [
               [
                  44,
                  "file->size"
               ]
            ]
         }
      ],
      "src/tkc/data_reader_mem.c": [
         {
            "type": "func",
            "name": "data_reader_mem_get_size",
            "line_range": [
               48,
               52
            ],
            "source_code": "static uint64_t data_reader_mem_get_size(data_reader_t* reader) {\n  data_reader_mem_t* mem = (data_reader_mem_t*)reader;\n\n  return mem->size;\n}",
            "key_variables": [
               [
                  52,
                  "mem->size"
               ]
            ]
         }
      ],
      "src/tkc/data_writer_factory.c": [
         {
            "type": "block",
            "name": "block",
            "line_range": "",
            "source_code": "",
            "key_variables": [
               32,
               "protocol[TK_NAME_LEN + 1]"
            ]
         },
         {
            "type": "func",
            "name": "data_writer_factory_register",
            "line_range": [
               58,
               71
            ],
            "source_code": "ret_t data_writer_factory_register(data_writer_factory_t* factory, const char* protocol,\n                                   data_writer_create_t create) {\n  creator_item_t* item = NULL;\n  return_value_if_fail(factory != NULL && protocol != NULL && create != NULL, RET_BAD_PARAMS);\n\n  item = TKMEM_ZALLOC(creator_item_t);\n  return_value_if_fail(item != NULL, RET_OOM);\n\n  item->create = create;\n  tk_strncpy(item->protocol, protocol, TK_NAME_LEN);\n  darray_push(&(factory->creators), item);\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  75,
                  "protocol[TK_NAME_LEN + 1]"
               ]
            ]
         }
      ],
      "src/tkc/date_time.c": [
         {
            "type": "func",
            "name": "date_time_global_init_ex",
            "line_range": [
               29,
               38
            ],
            "source_code": "ret_t date_time_global_init_ex(const date_time_vtable_t* vt) {\n  return_value_if_fail(vt != NULL, RET_BAD_PARAMS);\n\n  s_date_time_get_now = vt->get_now;\n  s_date_time_set_now = vt->set_now;\n  s_date_time_from_time = vt->from_time;\n  s_date_time_to_time = vt->to_time;\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  33,
                  "vt->get_now"
               ],
               [
                  34,
                  "vt->set_now"
               ],
               [
                  35,
                  "vt->from_time"
               ],
               [
                  36,
                  "vt->to_time"
               ]
            ]
         },
         {
            "type": "func",
            "name": "date_time_destroy",
            "line_range": [
               85,
               91
            ],
            "source_code": "ret_t date_time_destroy(date_time_t* dt) {\n  return_value_if_fail(dt != NULL, RET_BAD_PARAMS);\n\n  TKMEM_FREE(dt);\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  107,
                  "days_of_month[month - 1]"
               ]
            ]
         },
         {
            "type": "func",
            "name": "date_time_get_wday",
            "line_range": [
               118,
               134
            ],
            "source_code": "int32_t date_time_get_wday(uint32_t year, uint32_t month, uint32_t day) {\n  int w = 0;\n  int a = 0;\n  int y = 0;\n  int m = 0;\n  return_value_if_fail(year <= 10000, -1);\n  return_value_if_fail(day >= 1 && day <= 31, -1);\n  return_value_if_fail(month >= 1 && month <= 12, -1);\n  return_value_if_fail(date_time_get_days(year, month) >= day && day > 0, -1);\n\n  a = ((14 - month) / 12);\n  y = (year - a);\n  m = (month + (12 * a) - 2);\n  w = (((day + y + (y / 4)) - (y / 100) + (y / 400) + (31 * m) / 12) % 7);\n\n  return w;\n}",
            "key_variables": [
               [
                  143,
                  "s_en_month_names[month - 1]"
               ]
            ]
         },
         {
            "type": "func",
            "name": "date_time_get_month_name",
            "line_range": [
               139,
               143
            ],
            "source_code": "const char* date_time_get_month_name(uint32_t month) {\n  return_value_if_fail(month >= 1 && month <= 12, NULL);\n\n  return s_en_month_names[month - 1];\n}",
            "key_variables": [
               [
                  153,
                  "s_en_wday_names[wday]"
               ]
            ]
         }
      ],
      "src/tkc/easing.c": [
         {
            "type": "func",
            "name": "easing_bounce_in",
            "line_range": [
               184,
               186
            ],
            "source_code": "static float_t easing_bounce_in(float_t k) {\n  return 1 - easing_bounce_out(1 - k);\n}",
            "key_variables": [
               [
                  222,
                  "s_easing_funcs[type]"
               ],
               [
                  224,
                  "s_easing_funcs[EASING_LINEAR]"
               ]
            ]
         }
      ],
      "src/tkc/emitter.c": [
         {
            "type": "func",
            "name": "emitter_item_destroy",
            "line_range": [
               55,
               68
            ],
            "source_code": "static ret_t emitter_item_destroy(emitter_item_t* iter) {\n  if (iter->on_destroy) {\n    iter->on_destroy(iter);\n  }\n\n#ifdef AWTK_WEB_JS\n  EM_ASM_INT({ return TBrowser.releaseFunction($0); }, iter->handler);\n#endif /*AWTK_WEB_JS*/\n\n  memset(iter, 0x00, sizeof(emitter_item_t));\n  TKMEM_FREE(iter);\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  80,
                  "iter->next"
               ],
               [
                  82,
                  "iter->next"
               ]
            ]
         },
         {
            "type": "func",
            "name": "emitter_remove",
            "line_range": [
               70,
               87
            ],
            "source_code": "static ret_t emitter_remove(emitter_t* emitter, emitter_item_t* prev, emitter_item_t* iter) {\n  return_value_if_fail(emitter != NULL && iter != NULL, RET_BAD_PARAMS);\n\n  if (emitter->curr_iter == iter) {\n    emitter->remove_curr_iter = TRUE;\n    return RET_OK;\n  }\n\n  if (iter == emitter->items) {\n    emitter->items = iter->next;\n  } else {\n    prev->next = iter->next;\n  }\n\n  emitter_item_destroy(iter);\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  94,
                  "emitter->items"
               ],
               [
                  95,
                  "emitter->items"
               ],
               [
                  98,
                  "iter->next"
               ],
               [
                  125,
                  "emitter->items"
               ],
               [
                  139,
                  "iter->next"
               ],
               [
                  150,
                  "iter->next"
               ]
            ]
         },
         {
            "type": "func",
            "name": "emitter_on_with_tag",
            "line_range": [
               158,
               175
            ],
            "source_code": "uint32_t emitter_on_with_tag(emitter_t* emitter, uint32_t etype, event_func_t handler, void* ctx,\n                             uint32_t tag) {\n  emitter_item_t* iter = NULL;\n  return_value_if_fail(emitter != NULL && handler != NULL, TK_INVALID_ID);\n\n  iter = TKMEM_ZALLOC(emitter_item_t);\n  return_value_if_fail(iter != NULL, TK_INVALID_ID);\n\n  iter->tag = tag;\n  iter->ctx = ctx;\n  iter->type = etype;\n  iter->handler = handler;\n  iter->id = emitter_next_id(emitter);\n  iter->next = emitter->items;\n  emitter->items = iter;\n\n  return iter->id;\n}",
            "key_variables": [
               [
                  172,
                  "emitter->items"
               ],
               [
                  175,
                  "iter->id"
               ],
               [
                  182,
                  "emitter->items"
               ],
               [
                  189,
                  "iter->next"
               ]
            ]
         },
         {
            "type": "func",
            "name": "emitter_exist",
            "line_range": [
               177,
               194
            ],
            "source_code": "bool_t emitter_exist(emitter_t* emitter, uint32_t etype, event_func_t handler, void* ctx) {\n  return_value_if_fail(emitter != NULL, FALSE);\n\n  if (emitter->items) {\n    emitter_item_t* iter = emitter->items;\n\n    while (iter != NULL) {\n      if (iter->handler == handler && iter->type == etype && iter->ctx == ctx) {\n        return TRUE;\n      }\n\n      iter = iter->next;\n    }\n  }\n\n  return FALSE;\n  ;\n}",
            "key_variables": [
               [
                  205,
                  "emitter->items"
               ],
               [
                  212,
                  "iter->next"
               ]
            ]
         },
         {
            "type": "func",
            "name": "emitter_find",
            "line_range": [
               200,
               216
            ],
            "source_code": "emitter_item_t* emitter_find(emitter_t* emitter, uint32_t id) {\n  return_value_if_fail(emitter != NULL, NULL);\n\n  if (emitter->items) {\n    emitter_item_t* iter = emitter->items;\n\n    while (iter != NULL) {\n      if (iter->id == id) {\n        return iter;\n      }\n\n      iter = iter->next;\n    }\n  }\n\n  return NULL;\n}",
            "key_variables": [
               [
                  224,
                  "emitter->items"
               ],
               [
                  228,
                  "iter->next"
               ],
               [
                  239,
                  "emitter->items"
               ],
               [
                  240,
                  "emitter->items"
               ],
               [
                  248,
                  "iter->next"
               ]
            ]
         },
         {
            "type": "func",
            "name": "emitter_disable",
            "line_range": [
               346,
               351
            ],
            "source_code": "ret_t emitter_disable(emitter_t* emitter) {\n  return_value_if_fail(emitter != NULL, RET_BAD_PARAMS);\n  emitter->disable++;\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  357,
                  "emitter->items"
               ],
               [
                  358,
                  "emitter->items"
               ],
               [
                  361,
                  "iter->next"
               ]
            ]
         },
         {
            "type": "func",
            "name": "emitter_set_on_destroy",
            "line_range": [
               378,
               387
            ],
            "source_code": "ret_t emitter_set_on_destroy(emitter_t* emitter, uint32_t id, tk_destroy_t on_destroy,\n                             void* on_destroy_ctx) {\n  emitter_item_t* item = emitter_find(emitter, id);\n  return_value_if_fail(item != NULL, RET_BAD_PARAMS);\n\n  item->on_destroy = on_destroy;\n  item->on_destroy_ctx = on_destroy_ctx;\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  401,
                  "emitter->items"
               ],
               [
                  403,
                  "iter->next"
               ]
            ]
         }
      ],
      "src/tkc/event.c": [
         {
            "type": "func",
            "name": "error_event_init",
            "line_range": [
               134,
               144
            ],
            "source_code": "event_t* error_event_init(error_event_t* event, int32_t code, const char* message) {\n  return_value_if_fail(event != NULL, NULL);\n  memset(event, 0x00, sizeof(*event));\n\n  event->e = event_init(EVT_ERROR, NULL);\n  event->e.size = sizeof(*event);\n  event->code = code;\n  event->message = message;\n\n  return (event_t*)(event);\n}",
            "key_variables": [
               [
                  171,
                  "event->type"
               ]
            ]
         }
      ],
      "src/tkc/event_source_fd.c": [
         {
            "type": "func",
            "name": "event_source_fd_get_fd",
            "line_range": [
               26,
               30
            ],
            "source_code": "static int32_t event_source_fd_get_fd(event_source_t* source) {\n  event_source_fd_t* event_source_fd = EVENT_SOURCE_FD(source);\n\n  return event_source_fd->fd;\n}",
            "key_variables": [
               [
                  30,
                  "event_source_fd->fd"
               ]
            ]
         }
      ],
      "src/tkc/event_source_manager.c": [
         {
            "type": "func",
            "name": "event_source_manager_prepare",
            "line_range": [
               41,
               57
            ],
            "source_code": "static ret_t event_source_manager_prepare(event_source_manager_t* manager) {\n  uint32_t i = 0;\n  uint32_t n = 0;\n  event_source_t** sources = NULL;\n  return_value_if_fail(manager != NULL && manager->dispatch != NULL, RET_BAD_PARAMS);\n\n  n = manager->sources.size;\n  sources = (event_source_t**)(manager->sources.elms);\n\n  for (i = 0; i < n; i++) {\n    event_source_t* iter = sources[i];\n    object_ref(OBJECT(iter));\n    darray_push(&(manager->dispatching_sources), iter);\n  }\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  52,
                  "sources[i]"
               ]
            ]
         },
         {
            "type": "func",
            "name": "event_source_manager_remove_by_tag",
            "line_range": [
               95,
               97
            ],
            "source_code": "ret_t event_source_manager_remove_by_tag(event_source_manager_t* manager, void* tag) {\n  return darray_remove_all(&(manager->sources), event_source_compare_by_tag, tag);\n}",
            "key_variables": [
               [
                  122,
                  "sources[i]"
               ]
            ]
         }
      ],
      "src/tkc/event_source_manager_default.c": [
         {
            "type": "func",
            "name": "event_source_manager_default_dispatch_fds",
            "line_range": [
               43,
               102
            ],
            "source_code": "static ret_t event_source_manager_default_dispatch_fds(event_source_manager_t* manager,\n                                                       uint32_t sleep_time) {\n  fd_set fdsr;\n  uint32_t i = 0;\n  int32_t fd = 0;\n  int32_t ret = 0;\n  int32_t max_fd = -1;\n  struct timeval tv = {0, 0};\n  event_source_t* iter = NULL;\n  event_source_t** sources = NULL;\n  return_value_if_fail(manager != NULL, 0);\n\n  FD_ZERO(&fdsr);\n  tv.tv_sec = sleep_time / 1000;\n  tv.tv_usec = (sleep_time % 1000) * 1000;\n\n  sources = (event_source_t**)(manager->dispatching_sources.elms);\n\n  for (i = 0; i < manager->dispatching_sources.size; i++) {\n    iter = sources[i];\n    fd = event_source_get_fd(iter);\n    if (fd >= 0) {\n      FD_SET(fd, &fdsr);\n      if (fd > max_fd) {\n        max_fd = fd;\n      }\n    }\n  }\n\n  if (max_fd < 0) {\n    return RET_OK;\n  }\n\n  ret = select(max_fd + 1, &fdsr, NULL, NULL, &tv);\n  if (ret < 0) {\n    perror(\"select\");\n    return RET_FAIL;\n  } else if (ret == 0) {\n    return RET_TIMEOUT;\n  }\n\n  for (i = 0; i < manager->dispatching_sources.size; i++) {\n    iter = sources[i];\n    if (darray_find(&manager->sources, iter) == NULL) {\n      continue;\n    }\n    fd = event_source_get_fd(iter);\n\n    if (fd >= 0) {\n      if (FD_ISSET(fd, &fdsr)) {\n        ret_t r = event_source_dispatch(iter);\n        if (r == RET_REMOVE) {\n          event_source_manager_remove(manager, iter);\n        }\n      }\n    }\n  }\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  63,
                  "sources[i]"
               ],
               [
                  86,
                  "sources[i]"
               ],
               [
                  121,
                  "sources[i]"
               ]
            ]
         }
      ],
      "src/tkc/fs.c": [
         {
            "type": "func",
            "name": "file_exist",
            "line_range": [
               294,
               298
            ],
            "source_code": "bool_t file_exist(const char* name) {\n  return_value_if_fail(name != NULL, FALSE);\n\n  return fs_file_exist(os_fs(), name);\n}",
            "key_variables": [
               [
                  308,
                  "buff[32]"
               ]
            ]
         },
         {
            "type": "func",
            "name": "fs_test_file",
            "line_range": [
               306,
               346
            ],
            "source_code": "ret_t fs_test_file(fs_t* fs) {\n  char buff[32];\n  fs_file_t* fp = NULL;\n  const char* filename = \"./test.txt\";\n\n  memset(buff, 0x00, sizeof(buff));\n  fp = fs_open_file(fs, filename, \"w+\");\n  assert(fs_file_write(fp, \"hello\", 5) == 5);\n  assert(fs_file_tell(fp) == 5);\n  assert(fs_file_sync(fp) == RET_OK);\n  assert(fs_file_size(fp) == 5);\n  assert(fs_file_truncate(fp, 0) == RET_OK);\n  assert(fs_file_write(fp, \"world\", 5) == 5);\n  assert(fs_file_seek(fp, 0) == RET_OK);\n  assert(fs_file_write(fp, \"WORLD\", 5) == 5);\n  assert(fs_file_close(fp) == RET_OK);\n  assert(fs_file_exist(fs, filename) == TRUE);\n\n  fp = fs_open_file(fs, filename, \"a\");\n  assert(fs_file_write(fp, \"world\", 5) == 5);\n  assert(fs_file_close(fp) == RET_OK);\n  assert(fs_get_file_size(fs, filename) == 10);\n\n  fp = fs_open_file(fs, filename, \"r\");\n  assert(fs_file_read(fp, buff, 10) == 10);\n  assert(strcmp(buff, \"WORLDworld\") == 0);\n  assert(fs_file_close(fp) == RET_OK);\n  assert(fs_get_file_size(fs, filename) == 10);\n\n  fp = fs_open_file(fs, filename, \"w+\");\n  assert(fs_file_printf(fp, \"%s:%d\", \"hello\", 10) == 8);\n  assert(fs_file_close(fp) == RET_OK);\n\n  assert(fs_file_rename(fs, filename, \"./test.bin\") == RET_OK);\n  assert(!fs_file_exist(fs, filename));\n  assert(fs_file_exist(fs, \"./test.bin\"));\n  assert(fs_remove_file(fs, \"./test.bin\") == RET_OK);\n  assert(!fs_file_exist(fs, \"./test.bin\"));\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  410,
                  "tbuff[128]"
               ],
               [
                  445,
                  "s[i]"
               ]
            ]
         },
         {
            "type": "func",
            "name": "fs_test_dir",
            "line_range": [
               348,
               401
            ],
            "source_code": "ret_t fs_test_dir(fs_t* fs) {\n  fs_item_t item;\n  fs_dir_t* dir = NULL;\n\n  fs_remove_dir_r(fs, \"./a\");\n  fs_remove_dir_r(fs, \"./b\");\n  assert(!fs_dir_exist(fs, \"./a\"));\n  assert(fs_create_dir(fs, \"./a\") == RET_OK);\n  assert(fs_dir_exist(fs, \"./a\"));\n\n  assert(fs_create_dir(fs, \"./a/b\") == RET_OK);\n  assert(fs_dir_exist(fs, \"./a/b\"));\n\n  assert(fs_create_dir(fs, \"./a/b/c1\") == RET_OK);\n  assert(fs_dir_exist(fs, \"./a/b/c1\"));\n\n  assert(fs_create_dir(fs, \"./a/b/c2\") == RET_OK);\n  assert(fs_dir_exist(fs, \"./a/b/c2\"));\n\n  dir = fs_open_dir(fs, \"./a/b\");\n  assert(dir != NULL);\n\n  do {\n    assert(fs_dir_read(dir, &item) == RET_OK);\n    if (item.name[0] != '.') {\n      break;\n    } else {\n      assert(!item.is_reg_file);\n      assert(item.is_dir);\n    }\n  } while (TRUE);\n\n  assert(strcmp(item.name, \"c1\") == 0 || strcmp(item.name, \"c2\") == 0);\n  assert(!item.is_reg_file);\n  assert(item.is_dir);\n\n  assert(fs_dir_read(dir, &item) == RET_OK);\n  assert(!item.is_reg_file);\n  assert(item.is_dir);\n\n  assert(fs_dir_close(dir) == RET_OK);\n\n  if (fs_dir_rename(fs, \"./a/b/c2\", \"./a/b/c3\") == RET_OK) {\n    assert(!fs_dir_exist(fs, \"./a/b/c2\"));\n    assert(fs_dir_exist(fs, \"./a/b/c3\"));\n    assert(fs_dir_rename(fs, \"./a/b/c3\", \"./a/b/c2\") == RET_OK);\n  }\n  assert(fs_remove_dir(fs, \"./a/b/c1\") == RET_OK);\n  assert(fs_remove_dir(fs, \"./a/b/c2\") == RET_OK);\n  assert(fs_remove_dir(fs, \"./a/b\") == RET_OK);\n  assert(fs_remove_dir(fs, \"./a\") == RET_OK);\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  465,
                  "home[MAX_PATH + 1]"
               ],
               [
                  466,
                  "path[MAX_PATH + 1]"
               ]
            ]
         },
         {
            "type": "func",
            "name": "fs_file_read_line",
            "line_range": [
               408,
               460
            ],
            "source_code": "int32_t fs_file_read_line(fs_file_t* file, char* buffer, uint32_t size) {\n  char tbuff[128];\n  char* d = buffer;\n  char* s = tbuff;\n  int32_t i = 0;\n  int32_t ret = 0;\n  int64_t offset = 0;\n  bool_t done = FALSE;\n  return_value_if_fail(file != NULL && buffer != NULL && size > 1, 0);\n\n  while (((d - buffer) < size) && !done) {\n    offset = fs_file_tell(file);\n    ret = fs_file_read(file, tbuff, sizeof(tbuff) - 1);\n    if (ret <= 0) {\n      break;\n    }\n    tbuff[ret] = '\\0';\n    for (i = 0; (i < ret) && ((d - buffer) < size); i++) {\n      offset++;\n      if (s[i] == '\\r') {\n        i++;\n        if (s[i] == '\\n') {\n          offset++;\n        } else if (s[i] == '\\0') {\n          char c = 0;\n          fs_file_read(file, &c, 1);\n          if (c == '\\n') {\n            offset++;\n          }\n        }\n        done = TRUE;\n        break;\n      } else if (s[i] == '\\n') {\n        done = TRUE;\n        break;\n      } else {\n        *d++ = s[i];\n      }\n    }\n\n    if (ret < (sizeof(tbuff) - 1)) {\n      break;\n    }\n  }\n\n  ret = d - buffer;\n  if (ret > 0) {\n    *d = '\\0';\n    fs_file_seek(file, offset);\n  }\n\n  return ret;\n}",
            "key_variables": [
               [
                  481,
                  "path[MAX_PATH + 1]"
               ],
               [
                  528,
                  "subname[MAX_PATH + 1]"
               ]
            ]
         },
         {
            "type": "func",
            "name": "fs_create_dir_r",
            "line_range": [
               478,
               509
            ],
            "source_code": "ret_t fs_create_dir_r(fs_t* fs, const char* name) {\n  int32_t len = 0;\n  char path[MAX_PATH + 1];\n  tokenizer_t tokenizer;\n  tokenizer_t* t = NULL;\n  return_value_if_fail(fs != NULL && name != NULL, RET_BAD_PARAMS);\n  t = tokenizer_init(&tokenizer, name, strlen(name), \"/\\\\\");\n  return_value_if_fail(t != NULL, RET_BAD_PARAMS);\n\n  while (tokenizer_has_more(t)) {\n    tokenizer_next(t);\n\n    len = tk_min(MAX_PATH, t->cursor);\n    tk_strncpy(path, name, len);\n\n    if (len > 0) {\n      if (path[len - 1] == '/' || path[len - 1] == '\\\\') {\n        path[len - 1] = '\\0';\n      }\n    }\n\n    if (!fs_dir_exist(fs, path)) {\n      if (fs_create_dir(fs, path) != RET_OK) {\n        log_debug(\"create %s failed\\n\", path);\n        break;\n      }\n    }\n  }\n  tokenizer_deinit(t);\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  573,
                  "dirname[MAX_PATH + 1]"
               ],
               [
                  596,
                  "subsrc[MAX_PATH + 1]"
               ],
               [
                  597,
                  "subdst[MAX_PATH + 1]"
               ]
            ]
         }
      ],
      "src/tkc/fscript.c": [
         {
            "type": "func",
            "name": "func_return",
            "line_range": [
               48,
               54
            ],
            "source_code": "static ret_t func_return(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  if (args->size > 0) {\n    value_deep_copy(result, args->args);\n  }\n  fscript->returned = TRUE;\n  return RET_OK;\n}",
            "key_variables": [
               [
                  63,
                  "fscript->curr"
               ]
            ]
         },
         {
            "type": "func",
            "name": "value_is_digit",
            "line_range": [
               82,
               95
            ],
            "source_code": "static bool_t value_is_digit(value_t* v) {\n  uint32_t type = 0;\n  bool_t ret = TRUE;\n  return_value_if_fail(v != NULL, FALSE);\n\n  type = v->type;\n  if (type == VALUE_TYPE_INVALID || type == VALUE_TYPE_POINTER || type == VALUE_TYPE_STRING ||\n      type == VALUE_TYPE_WSTRING || type == VALUE_TYPE_OBJECT || type == VALUE_TYPE_SIZED_STRING ||\n      type == VALUE_TYPE_BINARY || type == VALUE_TYPE_UBJSON) {\n    ret = FALSE;\n  }\n\n  return ret;\n}",
            "key_variables": [
               [
                  88,
                  "v->type"
               ]
            ]
         },
         {
            "type": "func",
            "name": "func_args_init",
            "line_range": [
               125,
               134
            ],
            "source_code": "static ret_t func_args_init(fscript_args_t* args, uint16_t init_args_capacity) {\n  memset(args, 0x00, sizeof(fscript_args_t));\n  if (init_args_capacity > 0) {\n    args->args = TKMEM_ZALLOCN(value_t, init_args_capacity);\n    return_value_if_fail(args->args != NULL, RET_OOM);\n    args->capacity = init_args_capacity;\n  }\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  140,
                  "args->size"
               ],
               [
                  145,
                  "v->type"
               ],
               [
                  160,
                  "iter->next"
               ]
            ]
         },
         {
            "type": "func",
            "name": "fscript_function_def_add_param",
            "line_range": [
               191,
               194
            ],
            "source_code": "static ret_t fscript_function_def_add_param(fscript_function_def_t* func, const char* name) {\n  return_value_if_fail(func != NULL, RET_BAD_PARAMS);\n  return darray_push(&(func->params), tk_strdup(name));\n}",
            "key_variables": [
               [
                  244,
                  "name[1]"
               ]
            ]
         },
         {
            "type": "func",
            "name": "fscript_get_var",
            "line_range": [
               266,
               297
            ],
            "source_code": "static ret_t fscript_get_var(fscript_t* fscript, const char* name, value_t* value) {\n  ret_t ret = RET_OK;\n  value_set_str(value, NULL);\n  return_value_if_fail(name != NULL, RET_BAD_PARAMS);\n  if (*name == '$') {\n    name += 1;\n  }\n\n  if (fscript->locals != NULL) {\n    if (object_get_prop(fscript->locals, name, value) == RET_OK) {\n      return RET_OK;\n    }\n  }\n\n  if (is_fast_var(name)) {\n    value_t* var = fscript_get_fast_var(fscript, name);\n    if (name[1] == '.') {\n      if (var->type == VALUE_TYPE_OBJECT) {\n        object_t* obj = value_object(var);\n        ret = object_get_prop(obj, name + 2, value);\n      } else {\n        ret = object_get_prop(fscript->obj, name, value);\n      }\n    } else {\n      ret = value_copy(value, var);\n    }\n  } else {\n    ret = object_get_prop(fscript->obj, name, value);\n  }\n\n  return ret;\n}",
            "key_variables": [
               [
                  331,
                  "s->type"
               ],
               [
                  360,
                  "msg[128]"
               ]
            ]
         },
         {
            "type": "func",
            "name": "fscript_exec_core_func",
            "line_range": [
               421,
               432
            ],
            "source_code": "static ret_t fscript_exec_core_func(fscript_t* fscript, fscript_func_call_t* iter,\n                                    value_t* result) {\n  if (iter->func == func_if) {\n    return fscript_exec_if(fscript, iter, result);\n  } else if (iter->func == func_while) {\n    return fscript_exec_while(fscript, iter, result);\n  } else if (iter->func == func_function_def) {\n    return RET_OK;\n  }\n\n  return RET_NOT_FOUND;\n}",
            "key_variables": [
               [
                  477,
                  "fscript->first"
               ],
               [
                  486,
                  "iter->next"
               ]
            ]
         },
         {
            "type": "func",
            "name": "fscript_parser_get_char",
            "line_range": [
               538,
               560
            ],
            "source_code": "static char fscript_parser_get_char(fscript_parser_t* parser) {\n  char c = '\\0';\n  return_value_if_fail(parser != NULL, c);\n  if (parser->c) {\n    c = parser->c;\n    parser->c = '\\0';\n    return c;\n  }\n\n  c = parser->cursor[0];\n  if (c) {\n    if (c == '\\n') {\n      parser->row++;\n      parser->col = 0;\n    } else {\n      parser->col++;\n    }\n\n    parser->cursor++;\n  }\n\n  return c;\n}",
            "key_variables": [
               [
                  543,
                  "parser->c"
               ],
               [
                  548,
                  "cursor[0]"
               ]
            ]
         },
         {
            "type": "func",
            "name": "fscript_parser_unget_char",
            "line_range": [
               562,
               566
            ],
            "source_code": "static ret_t fscript_parser_unget_char(fscript_parser_t* parser, char c) {\n  return_value_if_fail(parser->cursor > parser->str, RET_BAD_PARAMS);\n  parser->c = c;\n  return RET_OK;\n}",
            "key_variables": [
               [
                  573,
                  "parser->row"
               ],
               [
                  574,
                  "parser->col"
               ],
               [
                  575,
                  "parser->str"
               ]
            ]
         },
         {
            "type": "func",
            "name": "fscript_parser_skip_seperators",
            "line_range": [
               586,
               594
            ],
            "source_code": "static ret_t fscript_parser_skip_seperators(fscript_parser_t* parser) {\n  char c = '\\0';\n  do {\n    c = fscript_parser_get_char(parser);\n  } while (tk_isspace(c) || (int)c < 0);\n  fscript_parser_unget_char(parser, c);\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  652,
                  "str->str"
               ],
               [
                  653,
                  "str->size"
               ]
            ]
         },
         {
            "type": "func",
            "name": "fscript_parser_parse_id_or_number",
            "line_range": [
               694,
               736
            ],
            "source_code": "static ret_t fscript_parser_parse_id_or_number(fscript_parser_t* parser, token_type_t def_type) {\n  char c = '\\0';\n  str_t* str = &(parser->temp);\n  token_t* t = &(parser->token);\n  c = fscript_parser_get_char(parser);\n\n  if (c) {\n    str_set_with_len(str, &c, 1);\n  }\n\n  do {\n    c = fscript_parser_get_char(parser);\n    if (tk_isxdigit(c) || tk_isdigit(c) || tk_isalpha(c) || c == '.' || c == '_' || c == '[' ||\n        c == ']' || c == '#') {\n      str_append_char(str, c);\n    } else {\n      break;\n    }\n  } while (TRUE);\n\n  if (tk_isspace(c)) {\n    fscript_parser_skip_seperators_and_comments(parser);\n    c = fscript_parser_get_char(parser);\n  }\n\n  str_trim(str, \" \\t\\r\\n\");\n  TOKEN_INIT(t, (c == '(' ? TOKEN_FUNC : def_type), str);\n  if (c != '\\0') {\n    fscript_parser_unget_char(parser, c);\n  }\n\n  if (t->type == TOKEN_ID) {\n    if (tk_str_eq(t->token, \"function\")) {\n      t->type = TOKEN_FUNC_DEF;\n    } else if (tk_str_eq(t->token, \"var\")) {\n      t->type = TOKEN_VAR;\n    } else if (tk_str_eq(t->token, \"return\")) {\n      t->type = TOKEN_RETURN;\n    }\n  }\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  768,
                  "str->str"
               ],
               [
                  825,
                  "str->size"
               ],
               [
                  850,
                  "str->size"
               ]
            ]
         },
         {
            "type": "func",
            "name": "fscript_parser_get_token",
            "line_range": [
               879,
               881
            ],
            "source_code": "static token_t* fscript_parser_get_token(fscript_parser_t* parser) {\n  return fscript_parser_get_token_ex(parser, FALSE);\n}",
            "key_variables": [
               [
                  903,
                  "number[64]"
               ]
            ]
         },
         {
            "type": "func",
            "name": "fexpr_parse_function",
            "line_range": [
               1016,
               1069
            ],
            "source_code": "static ret_t fexpr_parse_function(fscript_parser_t* parser, value_t* result) {\n  value_t v;\n  fscript_args_t* args = NULL;\n  token_t* t = fscript_parser_get_token(parser);\n  fscript_func_call_t* acall = NULL;\n  if (t->token[0] == '-' && t->size == 1) {\n    acall = fscript_func_call_create(parser, \"minus\", 5);\n  } else {\n    acall = fscript_func_call_create(parser, t->token, t->size);\n  }\n  value_set_func(result, acall);\n  return_value_if_fail(acall != NULL, RET_BAD_PARAMS);\n\n  args = &(acall->args);\n  return_value_if_fail(fscript_parser_expect_token(parser, TOKEN_LPAREN, \"expect \\\"(\\\"\") == RET_OK,\n                       RET_FAIL);\n\n  do {\n    t = fscript_parser_get_token(parser);\n    if (t == NULL) {\n      return fscript_parser_set_error(parser, \"expect \\\")\\\"\");\n    }\n\n    if (t->type == TOKEN_RPAREN) {\n      break;\n    } else {\n      fscript_parser_unget_token(parser);\n    }\n    value_set_int(&v, 0);\n    return_value_if_fail(fexpr_parse(parser, &v) == RET_OK, RET_FAIL);\n    func_args_push(args, &v);\n    t = fscript_parser_get_token(parser);\n\n    if (t == NULL) {\n      return fscript_parser_set_error(parser, \"expect \\\")\\\"\");\n    } else if (t->type == TOKEN_RPAREN) {\n      break;\n    }\n    fscript_parser_unget_token(parser);\n    fscript_parser_expect_token(parser, TOKEN_COMMA, \"expect \\\",\\\"\");\n  } while (TRUE);\n\n  if (acall->func == func_if && acall->args.size == 1) {\n    if (fscript_parser_expect_token(parser, TOKEN_LBRACKET, \"expect \\\"{\\\"\") == RET_OK) {\n      fexpr_parse_if(parser, acall);\n    }\n  } else if (acall->func == func_while && acall->args.size == 1) {\n    if (fscript_parser_expect_token(parser, TOKEN_LBRACKET, \"expect \\\"{\\\"\") == RET_OK) {\n      fexpr_parse_while(parser, acall);\n    }\n  }\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  1118,
                  "token[0]"
               ],
               [
                  1123,
                  "t->size"
               ]
            ]
         },
         {
            "type": "func",
            "name": "fexpr_parse_compare",
            "line_range": [
               1211,
               1240
            ],
            "source_code": "static ret_t fexpr_parse_compare(fscript_parser_t* parser, value_t* result) {\n  value_t v;\n  token_t* t = NULL;\n  fscript_args_t* args = NULL;\n  fscript_func_call_t* acall = NULL;\n\n  value_set_int(result, 0);\n  return_value_if_fail(fexpr_parse_sum(parser, result) == RET_OK, RET_FAIL);\n\n  t = fscript_parser_get_token_ex(parser, TRUE);\n  if (t == NULL || t->type != TOKEN_FUNC || tk_str_eq(t->token, \"=\")) {\n    fscript_parser_unget_token(parser);\n    return RET_OK;\n  }\n\n  if (t->token[0] == '>' || t->token[0] == '<' || t->token[0] == '=' ||\n      (t->token[0] == '!' && t->token[1] == '=')) {\n    acall = fscript_func_call_create(parser, t->token, t->size);\n    return_value_if_fail(acall != NULL, RET_OOM);\n    args = &(acall->args);\n    func_args_push(args, result);\n    value_set_func(result, acall);\n    fexpr_parse_sum(parser, &v);\n    func_args_push(args, &v);\n  } else {\n    fscript_parser_unget_token(parser);\n  }\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  1347,
                  "parser->temp"
               ],
               [
                  1348,
                  "parser->obj"
               ],
               [
                  1349,
                  "parser->first"
               ],
               [
                  1350,
                  "parser->funcs_def"
               ]
            ]
         },
         {
            "type": "func",
            "name": "fexpr_parse_question",
            "line_range": [
               1275,
               1308
            ],
            "source_code": "static ret_t fexpr_parse_question(fscript_parser_t* parser, value_t* result) {\n  value_t v;\n  ret_t ret = RET_OK;\n  token_t* t = NULL;\n  fscript_args_t* args = NULL;\n  fscript_func_call_t* acall = NULL;\n\n  value_set_str(&v, NULL);\n  if (fexpr_parse_logic(parser, result) == RET_OK) {\n    t = fscript_parser_get_token(parser);\n    if (t && t->type == TOKEN_QUESTION) {\n      acall = fscript_func_call_create(parser, \"if\", 2);\n      return_value_if_fail(acall != NULL, RET_OOM);\n      args = &(acall->args);\n      func_args_push(args, result);\n      value_set_func(result, acall);\n\n      value_reset(&v);\n      return_value_if_fail(fexpr_parse_logic(parser, &v) == RET_OK, RET_FAIL);\n      func_args_push(args, &v);\n\n      return_value_if_fail(fscript_parser_expect_token(parser, TOKEN_COLON, \"expect :\") == RET_OK,\n                           RET_FAIL);\n      return_value_if_fail(fexpr_parse_logic(parser, &v) == RET_OK, RET_FAIL);\n      func_args_push(args, &v);\n    } else {\n      fscript_parser_unget_token(parser);\n    }\n  } else {\n    ret = RET_FAIL;\n  }\n\n  return ret;\n}",
            "key_variables": [
               [
                  1362,
                  "fscript->locals"
               ],
               [
                  1364,
                  "func_def->body"
               ],
               [
                  1389,
                  "func_name[TK_NAME_LEN + 1]"
               ]
            ]
         },
         {
            "type": "func",
            "name": "func_has_error",
            "line_range": [
               1546,
               1549
            ],
            "source_code": "static ret_t func_has_error(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  value_set_bool(result, fscript->error_code != RET_OK);\n  return RET_OK;\n}",
            "key_variables": [
               [
                  1564,
                  "args->size"
               ],
               [
                  1576,
                  "buff[64]"
               ],
               [
                  1578,
                  "args->size"
               ],
               [
                  1584,
                  "args->size"
               ]
            ]
         },
         {
            "type": "func",
            "name": "func_f32",
            "line_range": [
               1650,
               1654
            ],
            "source_code": "static ret_t func_f32(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  FSCRIPT_FUNC_CHECK(args->size == 1, RET_BAD_PARAMS);\n  value_set_float32(result, value_float32(args->args));\n  return RET_OK;\n}",
            "key_variables": [
               [
                  1672,
                  "buff[16]"
               ]
            ]
         },
         {
            "type": "func",
            "name": "func_float",
            "line_range": [
               1656,
               1660
            ],
            "source_code": "static ret_t func_float(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  FSCRIPT_FUNC_CHECK(args->size == 1, RET_BAD_PARAMS);\n  value_set_double(result, value_double(args->args));\n  return RET_OK;\n}",
            "key_variables": [
               [
                  1732,
                  "buff[64]"
               ],
               [
                  1739,
                  "args->size"
               ]
            ]
         },
         {
            "type": "func",
            "name": "func_join",
            "line_range": [
               1729,
               1748
            ],
            "source_code": "static ret_t func_join(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  uint32_t i = 0;\n  char buff[64];\n  str_t* str = &(fscript->str);\n  value_set_bool(result, FALSE);\n  FSCRIPT_FUNC_CHECK(args->size > 1, RET_BAD_PARAMS);\n\n  str_set(str, \"\");\n  value_set_bool(result, TRUE);\n  for (i = 1; i < args->size; i++) {\n    if (i > 1) {\n      str_append(str, value_str_ex(args->args, buff, sizeof(buff)));\n    }\n    str_append(str, value_str_ex(args->args + i, buff, sizeof(buff)));\n  }\n\n  value_set_str(result, str->str);\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  1785,
                  "args->size"
               ],
               [
                  1786,
                  "buff[64]"
               ]
            ]
         },
         {
            "type": "func",
            "name": "func_less",
            "line_range": [
               1914,
               1923
            ],
            "source_code": "static ret_t func_less(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  FSCRIPT_FUNC_CHECK(args->size == 2, RET_BAD_PARAMS);\n  if (args->args[0].type == VALUE_TYPE_STRING && args->args[1].type == VALUE_TYPE_STRING) {\n    value_set_bool(result, tk_str_cmp(value_str(args->args), value_str(args->args + 1)) < 0);\n  } else {\n    value_set_bool(result, value_double(args->args) < value_double(args->args + 1));\n  }\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  1951,
                  "args->args"
               ]
            ]
         },
         {
            "type": "func",
            "name": "func_ceil",
            "line_range": [
               2054,
               2058
            ],
            "source_code": "static ret_t func_ceil(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  FSCRIPT_FUNC_CHECK(args->size == 1, RET_BAD_PARAMS);\n  value_set_double(result, ceil(value_double(args->args)));\n  return RET_OK;\n}",
            "key_variables": [
               [
                  2068,
                  "buff[64]"
               ]
            ]
         },
         {
            "type": "func",
            "name": "func_substr",
            "line_range": [
               2117,
               2140
            ],
            "source_code": "static ret_t func_substr(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  str_t* str = &(fscript->str);\n  const char* org = NULL;\n  uint32_t total_len = 0;\n  uint32_t from = 0;\n  uint32_t len = 0;\n  FSCRIPT_FUNC_CHECK(args->size == 3, RET_BAD_PARAMS);\n  org = value_str(args->args);\n  from = value_uint32(args->args + 1);\n  len = value_uint32(args->args + 2);\n  total_len = tk_strlen(org);\n  FSCRIPT_FUNC_CHECK(org != NULL, RET_BAD_PARAMS);\n\n  if (from < total_len) {\n    len = tk_min(len, (total_len - from));\n    str_set_with_len(str, org + from, len);\n  } else {\n    str_set(str, \"\");\n  }\n\n  value_set_str(result, str->str);\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  2178,
                  "buff[64]"
               ]
            ]
         },
         {
            "type": "func",
            "name": "func_replace",
            "line_range": [
               2142,
               2160
            ],
            "source_code": "static ret_t func_replace(fscript_t* fscript, fscript_args_t* args, value_t* result) {\n  str_t* str = &(fscript->str);\n  const char* org = NULL;\n  const char* replace = NULL;\n  const char* replace_with = NULL;\n  FSCRIPT_FUNC_CHECK(args->size == 3, RET_BAD_PARAMS);\n\n  org = value_str(args->args);\n  replace = value_str(args->args + 1);\n  replace_with = value_str(args->args + 2);\n  FSCRIPT_FUNC_CHECK(org != NULL && replace != NULL && replace_with != NULL, RET_BAD_PARAMS);\n\n  str_set(str, org);\n  str_replace(str, replace, replace_with);\n\n  value_set_str(result, str->str);\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  2304,
                  "func_name[TK_NAME_LEN + 1]"
               ],
               [
                  2305,
                  "full_func_name[2 * TK_NAME_LEN + 1]"
               ],
               [
                  2309,
                  "parser->row"
               ],
               [
                  2310,
                  "parser->col"
               ],
               [
                  2315,
                  "iter->func"
               ]
            ]
         }
      ],
      "src/tkc/func_call_parser.c": [
         {
            "type": "func",
            "name": "func_call_parser_parse",
            "line_range": [
               34,
               65
            ],
            "source_code": "ret_t func_call_parser_parse(func_call_parser_t* parser) {\n  const char* token = NULL;\n  char name[TK_NAME_LEN + 1];\n  tokenizer_t* tokenizer = NULL;\n  return_value_if_fail(parser != NULL, RET_BAD_PARAMS);\n\n  tokenizer = &(parser->tokenizer);\n  return_value_if_fail(tokenizer_has_more(tokenizer) == TRUE, RET_BAD_PARAMS);\n\n  token = tokenizer_next(tokenizer);\n  if (parser->on_name != NULL) {\n    parser->on_name(parser, token);\n  }\n\n  while (tokenizer_has_more(tokenizer)) {\n    token = tokenizer_next(tokenizer);\n    tk_strncpy(name, token, TK_NAME_LEN);\n\n    return_value_if_fail(tokenizer_has_more(tokenizer), RET_BAD_PARAMS);\n    token = tokenizer_next(tokenizer);\n\n    if (parser->on_param != NULL) {\n      parser->on_param(parser, name, token);\n    }\n  }\n\n  if (parser->on_done != NULL) {\n    parser->on_done(parser);\n  }\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  37,
                  "name[TK_NAME_LEN + 1]"
               ]
            ]
         }
      ],
      "src/tkc/idle_manager.c": [
         {
            "type": "func",
            "name": "idle_manager_add",
            "line_range": [
               107,
               109
            ],
            "source_code": "uint32_t idle_manager_add(idle_manager_t* idle_manager, idle_func_t on_idle, void* ctx) {\n  return idle_manager_add_with_type(idle_manager, on_idle, ctx, IDLE_INFO_NORMAL);\n}",
            "key_variables": [
               [
                  121,
                  "idle->id"
               ]
            ]
         },
         {
            "type": "func",
            "name": "idle_manager_remove",
            "line_range": [
               123,
               129
            ],
            "source_code": "ret_t idle_manager_remove(idle_manager_t* idle_manager, uint32_t idle_id) {\n  idle_info_t idle;\n  return_value_if_fail(idle_id != TK_INVALID_ID, RET_BAD_PARAMS);\n  return_value_if_fail(idle_manager != NULL, RET_BAD_PARAMS);\n\n  return slist_remove(&(idle_manager->idles), idle_info_init_dummy(&idle, idle_id));\n}",
            "key_variables": [
               [
                  144,
                  "iter->next"
               ]
            ]
         },
         {
            "type": "func",
            "name": "idle_manager_find",
            "line_range": [
               131,
               137
            ],
            "source_code": "const idle_info_t* idle_manager_find(idle_manager_t* idle_manager, uint32_t idle_id) {\n  idle_info_t idle;\n  return_value_if_fail(idle_id != TK_INVALID_ID, NULL);\n  return_value_if_fail(idle_manager != NULL, NULL);\n\n  return slist_find(&(idle_manager->idles), idle_info_init_dummy(&idle, idle_id));\n}",
            "key_variables": [
               [
                  172,
                  "idle_manager->dispatch_times"
               ]
            ]
         },
         {
            "type": "func",
            "name": "idle_manager_dispatch_one",
            "line_range": [
               139,
               160
            ],
            "source_code": "static ret_t idle_manager_dispatch_one(idle_manager_t* idle_manager, uint32_t dispatch_id) {\n  slist_node_t* iter = idle_manager->idles.first;\n\n  while (iter != NULL && !idle_info_is_available(IDLE_INFO(iter->data), dispatch_id)) {\n    iter = iter->next;\n  }\n\n  if (iter != NULL) {\n    idle_info_t* idle = (idle_info_t*)object_ref((object_t*)(iter->data));\n    return_value_if_fail(idle != NULL, RET_BAD_PARAMS);\n\n    if (idle_info_on_idle(idle, dispatch_id) != RET_REPEAT) {\n      idle_manager_remove(idle_manager, idle->id);\n    }\n\n    object_unref((object_t*)idle);\n\n    return RET_OK;\n  }\n\n  return RET_DONE;\n}",
            "key_variables": [
               [
                  198,
                  "iter->next"
               ]
            ]
         }
      ],
      "src/tkc/int_str.c": [
         {
            "type": "func",
            "name": "int_str_value",
            "line_range": [
               23,
               36
            ],
            "source_code": "const char* int_str_value(const int_str_t* items, int32_t name) {\n  const int_str_t* iter = items;\n  return_value_if_fail(items != NULL, NULL);\n\n  while (iter->value != NULL) {\n    if (iter->name == name) {\n      return iter->value;\n    }\n\n    iter++;\n  }\n\n  return NULL;\n}",
            "key_variables": [
               [
                  30,
                  "iter->value"
               ]
            ]
         },
         {
            "type": "func",
            "name": "int_str_name",
            "line_range": [
               38,
               51
            ],
            "source_code": "int32_t int_str_name(const int_str_t* items, const char* value, int32_t defval) {\n  const int_str_t* iter = items;\n  return_value_if_fail(items != NULL && value != NULL, defval);\n\n  while (iter->value != NULL) {\n    if (tk_str_eq(iter->value, value)) {\n      return iter->name;\n    }\n\n    iter++;\n  }\n\n  return defval;\n}",
            "key_variables": [
               [
                  45,
                  "iter->name"
               ]
            ]
         }
      ],
      "src/tkc/istream.c": [
         {
            "type": "func",
            "name": "tk_istream_read_len",
            "line_range": [
               70,
               132
            ],
            "source_code": "int32_t tk_istream_read_len(tk_istream_t* stream, void* buff, uint32_t max_size,\n                            uint32_t timeout_ms) {\n  uint32_t now = 0;\n  uint32_t end = 0;\n  int32_t offset = 0;\n  ret_t ret = RET_OK;\n  int32_t read_bytes = 0;\n  int32_t remain_bytes = max_size;\n  uint8_t* p = (uint8_t*)buff;\n  return_value_if_fail(stream != NULL && stream->read != NULL, -1);\n  return_value_if_fail(buff != NULL, 0);\n\n  now = time_now_ms();\n  end = now + timeout_ms;\n\n  do {\n    errno = 0;\n    ret = tk_istream_wait_for_data(stream, 20);\n\n    if (ret == RET_TIMEOUT) {\n      now = time_now_ms();\n      if (now > end) {\n        break;\n      } else {\n        continue;\n      }\n    } else if (ret != RET_OK) {\n      break;\n    }\n\n    read_bytes = tk_istream_read(stream, p + offset, remain_bytes);\n    if (read_bytes <= 0) {\n      if (!object_get_prop_bool(OBJECT(stream), TK_STREAM_PROP_IS_OK, TRUE)) {\n        log_debug(\"stream is broken\\n\");\n        break;\n      } else {\n        log_debug(\"not get data\\n\");\n        continue;\n      }\n    }\n\n    offset += read_bytes;\n    remain_bytes -= read_bytes;\n\n    if (remain_bytes == 0) {\n      break;\n    }\n\n    if (object_get_prop_bool(OBJECT(stream), TK_STREAM_PROP_IS_EOS, FALSE)) {\n      log_debug(\"stream is end\\n\");\n      break;\n    }\n\n    now = time_now_ms();\n    if (now > end) {\n      break;\n    }\n\n    log_debug(\"read: %d/%u\\n\", offset, max_size);\n  } while (remain_bytes > 0);\n\n  return offset;\n}",
            "key_variables": [
               [
                  171,
                  "line[64]"
               ]
            ]
         }
      ],
      "src/tkc/matrix.c": [
         {
            "type": "func",
            "name": "matrix_identity",
            "line_range": [
               31,
               42
            ],
            "source_code": "matrix_t* matrix_identity(matrix_t* m) {\n  return_value_if_fail(m != NULL, NULL);\n\n  m->a0 = 1;\n  m->a1 = 0;\n  m->a2 = 0;\n  m->a3 = 1;\n  m->a4 = 0;\n  m->a5 = 0;\n\n  return m;\n}",
            "key_variables": [
               [
                  46,
                  "m->a3"
               ],
               [
                  47,
                  "m->a5"
               ]
            ]
         },
         {
            "type": "func",
            "name": "matrix_set",
            "line_range": [
               65,
               74
            ],
            "source_code": "matrix_t* matrix_set(matrix_t* m, float a0, float a1, float a2, float a3, float a4, float a5) {\n  m->a0 = a0;\n  m->a1 = a1;\n  m->a2 = a2;\n  m->a3 = a3;\n  m->a4 = a4;\n  m->a5 = a5;\n\n  return m;\n}",
            "key_variables": [
               [
                  78,
                  "m->a5"
               ],
               [
                  79,
                  "b->a5"
               ]
            ]
         },
         {
            "type": "func",
            "name": "matrix_multiply",
            "line_range": [
               76,
               88
            ],
            "source_code": "matrix_t* matrix_multiply(matrix_t* m, matrix_t* b) {\n  float a0 = m->a0, a1 = m->a1, a2 = m->a2, a3 = m->a3, a4 = m->a4, a5 = m->a5;\n  float b0 = b->a0, b1 = b->a1, b2 = b->a2, b3 = b->a3, b4 = b->a4, b5 = b->a5;\n\n  m->a0 = a0 * b0 + a2 * b1;\n  m->a1 = a1 * b0 + a3 * b1;\n  m->a2 = a0 * b2 + a2 * b3;\n  m->a3 = a1 * b2 + a3 * b3;\n  m->a4 = a0 * b4 + a2 * b5 + a4;\n  m->a5 = a1 * b4 + a3 * b5 + a5;\n\n  return m;\n}",
            "key_variables": [
               [
                  92,
                  "m->a5"
               ]
            ]
         },
         {
            "type": "func",
            "name": "matrix_scale",
            "line_range": [
               103,
               113
            ],
            "source_code": "matrix_t* matrix_scale(matrix_t* m, float sx, float sy) {\n  float a0 = m->a0, a1 = m->a1, a2 = m->a2, a3 = m->a3, a4 = m->a4, a5 = m->a5;\n  m->a0 = a0 * sx;\n  m->a1 = a1 * sx;\n  m->a2 = a2 * sy;\n  m->a3 = a3 * sy;\n  m->a4 = a4;\n  m->a5 = a5;\n\n  return m;\n}",
            "key_variables": [
               [
                  105,
                  "m->a5"
               ]
            ]
         },
         {
            "type": "func",
            "name": "matrix_rotate",
            "line_range": [
               115,
               127
            ],
            "source_code": "matrix_t* matrix_rotate(matrix_t* m, float rad) {\n  float a0 = m->a0, a1 = m->a1, a2 = m->a2, a3 = m->a3, a4 = m->a4, a5 = m->a5, s = sin(rad),\n        c = cos(rad);\n\n  m->a0 = a0 * c + a2 * s;\n  m->a1 = a1 * c + a3 * s;\n  m->a2 = a0 * -s + a2 * c;\n  m->a3 = a1 * -s + a3 * c;\n  m->a4 = a4;\n  m->a5 = a5;\n\n  return m;\n}",
            "key_variables": [
               [
                  131,
                  "m->a4"
               ],
               [
                  132,
                  "m->a5"
               ]
            ]
         },
         {
            "type": "func",
            "name": "matrix_transform_point",
            "line_range": [
               129,
               137
            ],
            "source_code": "matrix_t* matrix_transform_point(matrix_t* m, xy_t x, xy_t y, xy_t* ox, xy_t* oy) {\n  float x1 = m->a0 * x + m->a2 * y + m->a4;\n  float y1 = m->a1 * x + m->a3 * y + m->a5;\n\n  *ox = x1 > 0 ? x1 + 0.5f : x1 - 0.5f;\n  *oy = y1 > 0 ? y1 + 0.5f : y1 - 0.5f;\n\n  return m;\n}",
            "key_variables": [
               [
                  141,
                  "m->a4"
               ],
               [
                  142,
                  "m->a5"
               ],
               [
                  150,
                  "m->a0"
               ],
               [
                  151,
                  "m->a1"
               ],
               [
                  152,
                  "m->a2"
               ],
               [
                  153,
                  "m->a3"
               ]
            ]
         }
      ],
      "src/tkc/mem.c": [
         {
            "type": "func",
            "name": "calloc",
            "line_range": [
               129,
               131
            ],
            "source_code": "void* calloc(size_t count, size_t size) {\n  return tk_calloc(count, size, __FUNCTION__, __LINE__);\n}",
            "key_variables": [
               [
                  131,
                  "calloc"
               ]
            ]
         },
         {
            "type": "func",
            "name": "malloc",
            "line_range": [
               137,
               139
            ],
            "source_code": "void* malloc(size_t size) {\n  return tk_alloc(size, __FUNCTION__, __LINE__);\n}",
            "key_variables": [
               [
                  143,
                  "realloc"
               ]
            ]
         },
         {
            "type": "func",
            "name": "tk_calloc",
            "line_range": [
               148,
               159
            ],
            "source_code": "void* tk_calloc(uint32_t nmemb, uint32_t size, const char* func, uint32_t line) {\n  void* addr = NULL;\n  uint32_t total_size = size * nmemb;\n  mem_allocator_t* allocator = mem_allocator_get();\n  return_value_if_fail(allocator != NULL, NULL);\n\n  addr = mem_allocator_alloc(allocator, total_size, func, line);\n  return_value_if_fail(addr != NULL, NULL);\n  memset(addr, 0x00, total_size);\n\n  return addr;\n}",
            "key_variables": [
               [
                  166,
                  "realloc"
               ]
            ]
         }
      ],
      "src/tkc/object.c": [
         {
            "type": "func",
            "name": "object_clone",
            "line_range": [
               111,
               115
            ],
            "source_code": "object_t* object_clone(object_t* obj) {\n  return_value_if_fail(obj != NULL && obj->vt != NULL && obj->vt->clone != NULL, NULL);\n\n  return obj->vt->clone(obj);\n}",
            "key_variables": [
               [
                  134,
                  "temp[MAX_PATH + 1]"
               ]
            ]
         },
         {
            "type": "func",
            "name": "object_get_type",
            "line_range": [
               450,
               454
            ],
            "source_code": "const char* object_get_type(object_t* obj) {\n  return_value_if_fail(obj != NULL && obj->vt != NULL, NULL);\n\n  return obj->vt->type;\n}",
            "key_variables": [
               [
                  454,
                  "vt->type"
               ],
               [
                  460,
                  "vt->desc"
               ]
            ]
         },
         {
            "type": "func",
            "name": "object_get_desc",
            "line_range": [
               456,
               460
            ],
            "source_code": "const char* object_get_desc(object_t* obj) {\n  return_value_if_fail(obj != NULL && obj->vt != NULL, NULL);\n\n  return obj->vt->desc;\n}",
            "key_variables": [
               [
                  466,
                  "vt->is_collection"
               ]
            ]
         },
         {
            "type": "func",
            "name": "object_is_collection",
            "line_range": [
               462,
               466
            ],
            "source_code": "bool_t object_is_collection(object_t* obj) {\n  return_value_if_fail(obj != NULL && obj->vt != NULL, FALSE);\n\n  return obj->vt->is_collection;\n}",
            "key_variables": [
               [
                  472,
                  "vt->size"
               ]
            ]
         },
         {
            "type": "func",
            "name": "object_get_prop_uint32",
            "line_range": [
               748,
               755
            ],
            "source_code": "uint32_t object_get_prop_uint32(object_t* obj, const char* name, uint32_t defval) {\n  value_t v;\n  if (object_get_prop(obj, name, &v) == RET_OK) {\n    return value_uint32(&v);\n  } else {\n    return defval;\n  }\n}",
            "key_variables": [
               [
                  796,
                  "subname[MAX_PATH + 1]"
               ]
            ]
         }
      ],
      "src/tkc/object_array.c": [
         {
            "type": "func",
            "name": "object_array_clean_invalid_props",
            "line_range": [
               27,
               52
            ],
            "source_code": "static ret_t object_array_clean_invalid_props(object_t* obj) {\n  object_array_t* o = OBJECT_ARRAY(obj);\n  event_t e = event_init(EVT_ITEMS_CHANGED, o);\n  return_value_if_fail(o != NULL, RET_BAD_PARAMS);\n  if (o->size > 0) {\n    uint32_t i = 0;\n    value_t* dst = o->props;\n\n    for (i = 0; i < o->size; i++) {\n      value_t* iter = o->props + i;\n\n      if (iter->type != VALUE_TYPE_INVALID) {\n        if (dst != iter) {\n          memcpy(dst, iter, sizeof(value_t));\n        }\n        dst++;\n      }\n    }\n\n    o->size = dst - o->props;\n  }\n\n  emitter_dispatch(EMITTER(o), &e);\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  34,
                  "o->props"
               ],
               [
                  36,
                  "o->size"
               ],
               [
                  47,
                  "o->props"
               ]
            ]
         },
         {
            "type": "func",
            "name": "object_array_clear_props",
            "line_range": [
               54,
               69
            ],
            "source_code": "ret_t object_array_clear_props(object_t* obj) {\n  uint32_t i = 0;\n  object_array_t* o = OBJECT_ARRAY(obj);\n  event_t e = event_init(EVT_ITEMS_CHANGED, o);\n  return_value_if_fail(o != NULL, RET_BAD_PARAMS);\n\n  for (i = 0; i < o->size; i++) {\n    value_t* iter = o->props + i;\n    value_reset(iter);\n  }\n\n  o->size = 0;\n  emitter_dispatch(EMITTER(o), &e);\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  61,
                  "o->size"
               ]
            ]
         },
         {
            "type": "func",
            "name": "object_array_insert",
            "line_range": [
               108,
               132
            ],
            "source_code": "ret_t object_array_insert(object_t* obj, uint32_t index, const value_t* v) {\n  value_t* s = NULL;\n  value_t* d = NULL;\n  value_t* p = NULL;\n  object_array_t* o = OBJECT_ARRAY(obj);\n  event_t e = event_init(EVT_ITEMS_CHANGED, o);\n  return_value_if_fail(o != NULL, RET_BAD_PARAMS);\n\n  return_value_if_fail(o != NULL && v != NULL, RET_BAD_PARAMS);\n  index = tk_min(index, o->size);\n  return_value_if_fail(object_array_extend(obj) == RET_OK, RET_OOM);\n\n  p = o->props + index;\n  d = o->props + o->size;\n  s = d - 1;\n\n  while (s >= p) {\n    *d-- = *s--;\n  }\n  value_deep_copy(p, v);\n  o->size++;\n  emitter_dispatch(EMITTER(o), &e);\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  122,
                  "o->size"
               ]
            ]
         },
         {
            "type": "func",
            "name": "object_array_parse_index",
            "line_range": [
               141,
               151
            ],
            "source_code": "static int32_t object_array_parse_index(const char* name) {\n  if (tk_isdigit(*name)) {\n    return tk_atoi(name);\n  } else if (*name == '[') {\n    return tk_atoi(name + 1);\n  } else if (tk_str_eq(name, \"-1\")) {\n    return -1;\n  } else {\n    return -2;\n  }\n}",
            "key_variables": [
               [
                  159,
                  "o->size"
               ]
            ]
         },
         {
            "type": "func",
            "name": "object_array_get_prop",
            "line_range": [
               285,
               307
            ],
            "source_code": "static ret_t object_array_get_prop(object_t* obj, const char* name, value_t* v) {\n  ret_t ret = RET_NOT_FOUND;\n  object_array_t* o = OBJECT_ARRAY(obj);\n  return_value_if_fail(o != NULL, RET_BAD_PARAMS);\n\n  if (tk_str_eq(name, \"length\") || tk_str_eq(name, \"size\") || tk_str_eq(name, \"#size\")) {\n    value_set_int(v, o->size);\n    ret = RET_OK;\n  } else if (tk_str_eq(name, \"capacity\")) {\n    value_set_int(v, o->capacity);\n    ret = RET_OK;\n  } else if (o->size > 0) {\n    object_t* sub = object_get_child_object(obj, name, &name);\n    if (sub != NULL) {\n      return object_get_prop(sub, name, v);\n    }\n\n    int32_t index = object_array_parse_index(name);\n    ret = object_array_get(obj, index, v);\n  }\n\n  return ret;\n}",
            "key_variables": [
               [
                  344,
                  "name[TK_NAME_LEN + 1]"
               ],
               [
                  347,
                  "o->size"
               ]
            ]
         },
         {
            "type": "func",
            "name": "object_array_unref",
            "line_range": [
               412,
               414
            ],
            "source_code": "ret_t object_array_unref(object_t* obj) {\n  return object_unref(obj);\n}",
            "key_variables": [
               [
                  515,
                  "o->size"
               ]
            ]
         },
         {
            "type": "func",
            "name": "object_array_sort_as_int",
            "line_range": [
               599,
               605
            ],
            "source_code": "ret_t object_array_sort_as_int(object_t* obj, bool_t ascending) {\n  if (ascending) {\n    return object_array_sort(obj, value_cmp_as_int);\n  } else {\n    return object_array_sort(obj, value_cmp_as_int_r);\n  }\n}",
            "key_variables": [
               [
                  643,
                  "o->size"
               ]
            ]
         },
         {
            "type": "func",
            "name": "object_array_sort_as_double",
            "line_range": [
               607,
               613
            ],
            "source_code": "ret_t object_array_sort_as_double(object_t* obj, bool_t ascending) {\n  if (ascending) {\n    return object_array_sort(obj, value_cmp_as_double);\n  } else {\n    return object_array_sort(obj, value_cmp_as_double_r);\n  }\n}",
            "key_variables": [
               [
                  666,
                  "o->size"
               ]
            ]
         },
         {
            "type": "func",
            "name": "object_array_sort_as_str",
            "line_range": [
               615,
               629
            ],
            "source_code": "ret_t object_array_sort_as_str(object_t* obj, bool_t ascending, bool_t ignore_case) {\n  if (ascending) {\n    if (ignore_case) {\n      return object_array_sort(obj, value_cmp_as_str_i);\n    } else {\n      return object_array_sort(obj, value_cmp_as_str);\n    }\n  } else {\n    if (ignore_case) {\n      return object_array_sort(obj, value_cmp_as_str_i_r);\n    } else {\n      return object_array_sort(obj, value_cmp_as_str_r);\n    }\n  }\n}",
            "key_variables": [
               [
                  686,
                  "o->size"
               ],
               [
                  704,
                  "o->size"
               ],
               [
                  707,
                  "o->size"
               ]
            ]
         }
      ],
      "src/tkc/path.c": [
         {
            "type": "func",
            "name": "path_exe",
            "line_range": [
               100,
               102
            ],
            "source_code": "ret_t path_exe(char path[MAX_PATH + 1]) {\n  return fs_get_exe(os_fs(), path);\n}",
            "key_variables": [
               [
                  107,
                  "exe_path[MAX_PATH + 1]"
               ]
            ]
         },
         {
            "type": "func",
            "name": "path_is_abs",
            "line_range": [
               202,
               206
            ],
            "source_code": "bool_t path_is_abs(const char* path) {\n  return_value_if_fail(path != NULL && *path, FALSE);\n\n  return path[0] == '/' || path[1] == ':';\n}",
            "key_variables": [
               [
                  210,
                  "cwd[MAX_PATH + 1]"
               ]
            ]
         },
         {
            "type": "func",
            "name": "path_build",
            "line_range": [
               225,
               257
            ],
            "source_code": "ret_t path_build(char* result, int32_t size, ...) {\n  va_list va;\n  char* d = result;\n  const char* p = NULL;\n  int32_t avail_size = size;\n  return_value_if_fail(result != NULL, RET_BAD_PARAMS);\n\n  memset(result, 0x00, size);\n  va_start(va, size);\n  do {\n    p = va_arg(va, char*);\n    if (p != NULL) {\n      int32_t new_size = strlen(p);\n      return_value_if_fail(((new_size + 1) < avail_size), RET_FAIL);\n\n      if (d != result) {\n        if (d[-1] != TK_PATH_SEP) {\n          *d++ = TK_PATH_SEP;\n        }\n      }\n\n      memcpy(d, p, new_size);\n      avail_size -= new_size;\n      d += new_size;\n    } else {\n      break;\n    }\n  } while (p != NULL);\n\n  va_end(va);\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  262,
                  "dirname[MAX_PATH + 1]"
               ]
            ]
         }
      ],
      "src/tkc/plugin_manager.c": [
         {
            "type": "func",
            "name": "plugin_destroy",
            "line_range": [
               47,
               82
            ],
            "source_code": "static ret_t plugin_destroy(plugin_t* plugin) {\n  return_value_if_fail(plugin != NULL, RET_BAD_PARAMS);\n\n  if (plugin->plugin_manager != NULL && plugin->handle != NULL) {\n    char name[MAX_PATH + 1];\n    char func[TK_FUNC_NAME_LEN + 1];\n    tk_dl_t* handle = plugin->handle;\n    const char* lib_name = plugin->lib_name;\n    plugin_manager_t* plugin_manager = plugin->plugin_manager;\n\n    memset(func, 0x00, sizeof(func));\n    memset(name, 0x00, sizeof(name));\n    if (plugin_manager->get_deinit != NULL &&\n        plugin_manager->get_deinit(func, name_from_lib_name(name, lib_name)) == RET_OK) {\n      log_debug(\"deinit func:%s\\n\", func);\n    } else {\n      tk_strncpy(func, TK_PLUGIN_DEINIT, TK_FUNC_NAME_LEN);\n    }\n    plugin_deinit_func_t deinit = (plugin_deinit_func_t)tk_dl_sym(handle, func);\n    if (deinit != NULL) {\n      ret_t ret = deinit();\n      log_debug(\"%s: deinit %d\\n\", lib_name, ret);\n    } else {\n      log_debug(\"%s: no deinit func\\n\", lib_name);\n    }\n  }\n\n  TKMEM_FREE(plugin->lib_name);\n  if (plugin->handle != NULL) {\n    tk_dl_close(plugin->handle);\n    plugin->handle = NULL;\n  }\n  TKMEM_FREE(plugin);\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  52,
                  "name[MAX_PATH + 1]"
               ],
               [
                  53,
                  "func[TK_FUNC_NAME_LEN + 1]"
               ],
               [
                  54,
                  "plugin->handle"
               ],
               [
                  55,
                  "plugin->lib_name"
               ],
               [
                  56,
                  "plugin->plugin_manager"
               ]
            ]
         },
         {
            "type": "func",
            "name": "plugin_create",
            "line_range": [
               84,
               136
            ],
            "source_code": "static plugin_t* plugin_create(const char* path, const char* lib_name,\n                               plugin_manager_t* plugin_manager) {\n  tk_dl_t* handle = NULL;\n  plugin_t* plugin = NULL;\n  char filename[MAX_PATH + 1];\n\n  memset(filename, 0x00, sizeof(filename));\n  return_value_if_fail(lib_name != NULL && path != NULL, NULL);\n\n  path_build(filename, MAX_PATH, path, lib_name, NULL);\n  handle = tk_dl_open(filename);\n\n  if (handle == NULL) {\n    log_debug(\"dlopen %s failed: %s\\n\", filename, tk_dl_error());\n  }\n  return_value_if_fail(handle != NULL, NULL);\n\n  plugin = TKMEM_ZALLOC(plugin_t);\n  if (plugin != NULL) {\n    plugin->handle = handle;\n    plugin->plugin_manager = plugin_manager;\n    plugin->lib_name = tk_strdup(lib_name);\n    if (plugin->lib_name == NULL) {\n      plugin_destroy(plugin);\n      plugin = NULL;\n    }\n  } else {\n    tk_dl_close(handle);\n  }\n\n  if (plugin != NULL) {\n    char name[MAX_PATH + 1];\n    char func[TK_FUNC_NAME_LEN + 1];\n\n    memset(name, 0x00, sizeof(name));\n    memset(func, 0x00, sizeof(func));\n    if (plugin_manager->get_init != NULL &&\n        plugin_manager->get_init(func, name_from_lib_name(name, lib_name)) == RET_OK) {\n      log_debug(\"init func:%s\\n\", func);\n    } else {\n      tk_strncpy(func, TK_PLUGIN_INIT, TK_FUNC_NAME_LEN);\n    }\n    plugin_init_func_t init = (plugin_init_func_t)tk_dl_sym(handle, func);\n    if (init != NULL) {\n      ret_t ret = init();\n      log_debug(\"%s: init %d\\n\", lib_name, ret);\n    } else {\n      log_debug(\"%s: no init func\\n\", lib_name);\n    }\n  }\n\n  return plugin;\n}",
            "key_variables": [
               [
                  89,
                  "filename[MAX_PATH + 1]"
               ],
               [
                  116,
                  "name[MAX_PATH + 1]"
               ],
               [
                  117,
                  "func[TK_FUNC_NAME_LEN + 1]"
               ]
            ]
         }
      ],
      "src/tkc/rect.c": [
         {
            "type": "func",
            "name": "rect_init",
            "line_range": [
               75,
               78
            ],
            "source_code": "rect_t rect_init(xy_t x, xy_t y, wh_t w, wh_t h) {\n  rect_t r = {x, y, w, h};\n  return r;\n}",
            "key_variables": [
               [
                  140,
                  "r->x"
               ],
               [
                  144,
                  "r->y"
               ]
            ]
         }
      ],
      "src/tkc/ring_buffer.c": [
         {
            "type": "func",
            "name": "ring_buffer_is_full",
            "line_range": [
               44,
               48
            ],
            "source_code": "bool_t ring_buffer_is_full(ring_buffer_t* ring_buffer) {\n  return_value_if_fail(ring_buffer != NULL, FALSE);\n\n  return ring_buffer->full;\n}",
            "key_variables": [
               [
                  48,
                  "ring_buffer->full"
               ]
            ]
         },
         {
            "type": "func",
            "name": "ring_buffer_is_empty",
            "line_range": [
               50,
               54
            ],
            "source_code": "bool_t ring_buffer_is_empty(ring_buffer_t* ring_buffer) {\n  return_value_if_fail(ring_buffer != NULL, FALSE);\n\n  return (ring_buffer->full == FALSE) && (ring_buffer->r == ring_buffer->w);\n}",
            "key_variables": [
               [
                  61,
                  "ring_buffer->capacity"
               ],
               [
                  64,
                  "ring_buffer->r"
               ]
            ]
         },
         {
            "type": "func",
            "name": "ring_buffer_free_size",
            "line_range": [
               70,
               74
            ],
            "source_code": "uint32_t ring_buffer_free_size(ring_buffer_t* ring_buffer) {\n  return_value_if_fail(ring_buffer != NULL, 0);\n\n  return ring_buffer->capacity - ring_buffer_size(ring_buffer);\n}",
            "key_variables": [
               [
                  80,
                  "ring_buffer->capacity"
               ]
            ]
         },
         {
            "type": "func",
            "name": "ring_buffer_capacity",
            "line_range": [
               76,
               80
            ],
            "source_code": "uint32_t ring_buffer_capacity(ring_buffer_t* ring_buffer) {\n  return_value_if_fail(ring_buffer != NULL, 0);\n\n  return ring_buffer->capacity;\n}",
            "key_variables": [
               [
                  87,
                  "ring_buffer->w"
               ]
            ]
         },
         {
            "type": "func",
            "name": "ring_buffer_reset",
            "line_range": [
               82,
               90
            ],
            "source_code": "ret_t ring_buffer_reset(ring_buffer_t* ring_buffer) {\n  return_value_if_fail(ring_buffer != NULL, RET_BAD_PARAMS);\n\n  ring_buffer->full = FALSE;\n  ring_buffer->r = ring_buffer->w;\n  memset(ring_buffer->data, 0x00, ring_buffer->capacity);\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  94,
                  "ring_buffer->capacity"
               ]
            ]
         },
         {
            "type": "func",
            "name": "ring_buffer_set_write_cursor",
            "line_range": [
               103,
               110
            ],
            "source_code": "ret_t ring_buffer_set_write_cursor(ring_buffer_t* ring_buffer, uint32_t w) {\n  ring_buffer->w = w % ring_buffer->capacity;\n  if (ring_buffer->r == ring_buffer->w) {\n    ring_buffer->full = TRUE;\n  }\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  105,
                  "ring_buffer->capacity"
               ]
            ]
         },
         {
            "type": "func",
            "name": "ring_buffer_set_write_cursor_delta",
            "line_range": [
               112,
               114
            ],
            "source_code": "ret_t ring_buffer_set_write_cursor_delta(ring_buffer_t* ring_buffer, uint32_t w_delta) {\n  return ring_buffer_set_write_cursor(ring_buffer, ring_buffer->w + w_delta);\n}",
            "key_variables": [
               [
                  128,
                  "ring_buffer->r"
               ],
               [
                  132,
                  "ring_buffer->r"
               ],
               [
                  139,
                  "ring_buffer->r"
               ],
               [
                  149,
                  "ring_buffer->data"
               ]
            ]
         },
         {
            "type": "func",
            "name": "ring_buffer_read",
            "line_range": [
               116,
               164
            ],
            "source_code": "uint32_t ring_buffer_read(ring_buffer_t* ring_buffer, void* buff, uint32_t size) {\n  return_value_if_fail(ring_buffer != NULL && buff != NULL, 0);\n\n  if (size == 0) {\n    return 0;\n  }\n\n  if (ring_buffer->r != ring_buffer->w || ring_buffer->full) {\n    uint32_t ret = 0;\n    uint32_t rsize = 0;\n    uint8_t* d = (uint8_t*)buff;\n    uint8_t* s = ring_buffer->data + ring_buffer->r;\n\n    ring_buffer->full = FALSE;\n    if (ring_buffer->r < ring_buffer->w) {\n      rsize = ring_buffer->w - ring_buffer->r;\n      rsize = tk_min(rsize, size);\n\n      ret = rsize;\n      memcpy(d, s, rsize);\n      ring_buffer_set_read_cursor_delta(ring_buffer, rsize);\n    } else {\n      rsize = ring_buffer->capacity - ring_buffer->r;\n      rsize = tk_min(rsize, size);\n\n      ret = rsize;\n      memcpy(d, s, rsize);\n      ring_buffer_set_read_cursor_delta(ring_buffer, rsize);\n\n      if (rsize < size) {\n        size -= rsize;\n        d += rsize;\n        s = ring_buffer->data;\n\n        rsize = tk_min(ring_buffer->w, size);\n        if (rsize > 0) {\n          memcpy(d, s, rsize);\n          ret += rsize;\n        }\n\n        ring_buffer_set_read_cursor(ring_buffer, rsize);\n      }\n    }\n\n    return ret;\n  }\n\n  return 0;\n}",
            "key_variables": [
               [
                  173,
                  "ring_buffer->r"
               ],
               [
                  174,
                  "ring_buffer->full"
               ],
               [
                  194,
                  "ring_buffer->w"
               ],
               [
                  197,
                  "ring_buffer->w"
               ],
               [
                  204,
                  "ring_buffer->w"
               ],
               [
                  214,
                  "ring_buffer->data"
               ]
            ]
         },
         {
            "type": "func",
            "name": "ring_buffer_write",
            "line_range": [
               181,
               229
            ],
            "source_code": "uint32_t ring_buffer_write(ring_buffer_t* ring_buffer, const void* buff, uint32_t size) {\n  return_value_if_fail(ring_buffer != NULL && buff != NULL, 0);\n\n  ring_buffer_ensure_write_space(ring_buffer, size);\n  if (size == 0 || ring_buffer_free_size(ring_buffer) == 0) {\n    return 0;\n  }\n\n  if (ring_buffer->r != ring_buffer->w || !ring_buffer->full) {\n    uint32_t ret = 0;\n    uint32_t rsize = 0;\n    uint8_t* s = (uint8_t*)buff;\n    uint8_t* d = ring_buffer->data + ring_buffer->w;\n\n    if (ring_buffer->w < ring_buffer->r) {\n      rsize = ring_buffer->r - ring_buffer->w;\n      rsize = tk_min(rsize, size);\n\n      ret = rsize;\n      memcpy(d, s, rsize);\n      ring_buffer_set_write_cursor_delta(ring_buffer, rsize);\n    } else {\n      rsize = ring_buffer->capacity - ring_buffer->w;\n      rsize = tk_min(rsize, size);\n\n      ret = rsize;\n      memcpy(d, s, rsize);\n      ring_buffer_set_write_cursor_delta(ring_buffer, rsize);\n\n      if (rsize < size) {\n        size -= rsize;\n        s += rsize;\n        d = ring_buffer->data;\n\n        rsize = tk_min(ring_buffer->r, size);\n        if (rsize > 0) {\n          memcpy(d, s, rsize);\n          ret += rsize;\n        }\n\n        ring_buffer_set_write_cursor(ring_buffer, rsize);\n      }\n    }\n\n    return ret;\n  }\n\n  return 0;\n}",
            "key_variables": [
               [
                  247,
                  "ring_buffer->capacity"
               ]
            ]
         }
      ],
      "src/tkc/rlog.c": [
         {
            "type": "func",
            "name": "rlog_create",
            "line_range": [
               40,
               82
            ],
            "source_code": "rlog_t* rlog_create(const char* filename_pattern, uint32_t max_size, uint32_t buff_size) {\n  rlog_t* log = NULL;\n  fs_stat_info_t fst;\n  fs_file_t* fp = NULL;\n  uint32_t index = 0;\n  char filename[MAX_PATH + 1];\n  my_return_value_if_fail(filename_pattern != NULL && max_size > 1000 && buff_size > 32, NULL);\n\n  memset(filename, 0x00, sizeof(filename));\n  tk_snprintf(filename, MAX_PATH, filename_pattern, (int)index);\n  if (fs_stat(os_fs(), filename, &fst) == RET_OK) {\n    if (fst.size < (max_size - buff_size)) {\n      fp = fs_open_file(os_fs(), filename, \"ab+\");\n    } else {\n      index = 1;\n      tk_snprintf(filename, MAX_PATH, filename_pattern, (int)(index));\n      fp = fs_open_file(os_fs(), filename, \"ab+\");\n    }\n  } else {\n    fp = fs_open_file(os_fs(), filename, \"wb+\");\n  }\n  my_return_value_if_fail(fp != NULL, NULL);\n\n  log = TKMEM_ZALLOC(rlog_t);\n  if (log != NULL) {\n    log->index = index;\n    log->max_size = max_size;\n    log->buff_size = buff_size;\n    log->mutex = tk_mutex_nest_create();\n    log->filename_pattern = tk_strdup(filename_pattern);\n\n    if (log->filename_pattern != NULL) {\n      log->fp = fp;\n    } else {\n      fs_file_close(fp);\n      TKMEM_FREE(log);\n    }\n  } else {\n    fs_file_close(fp);\n  }\n\n  return log;\n}",
            "key_variables": [
               [
                  46,
                  "filename[MAX_PATH + 1]"
               ]
            ]
         },
         {
            "type": "func",
            "name": "rlog_write",
            "line_range": [
               84,
               116
            ],
            "source_code": "ret_t rlog_write(rlog_t* log, const char* str) {\n  uint32_t len = 0;\n  fs_stat_info_t fst;\n  my_return_value_if_fail(log != NULL && log->fp != NULL && str != NULL, RET_BAD_PARAMS);\n  my_return_value_if_fail(fs_file_stat(log->fp, &fst) == RET_OK, RET_BAD_PARAMS);\n\n  if (tk_mutex_nest_lock(log->mutex) == RET_OK) {\n    len = strlen(str);\n    if ((fst.size + len) > log->max_size) {\n      char filename0[MAX_PATH + 1];\n      char filename1[MAX_PATH + 1];\n\n      fs_file_close(log->fp);\n      memset(filename1, 0x00, sizeof(filename1));\n      tk_snprintf(filename1, MAX_PATH, log->filename_pattern, (int)1);\n      if (log->index == 1) {\n        memset(filename0, 0x00, sizeof(filename0));\n        tk_snprintf(filename0, MAX_PATH, log->filename_pattern, (int)0);\n        fs_remove_file(os_fs(), filename0);\n        fs_file_rename(os_fs(), filename1, filename0);\n      }\n      log->index = 1;\n      log->fp = fs_open_file(os_fs(), filename1, \"wb+\");\n    }\n    if (log->fp != NULL) {\n      fs_file_write(log->fp, str, len);\n      fs_file_sync(log->fp);\n    }\n    tk_mutex_nest_unlock(log->mutex);\n  }\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  94,
                  "filename0[MAX_PATH + 1]"
               ],
               [
                  95,
                  "filename1[MAX_PATH + 1]"
               ]
            ]
         }
      ],
      "src/tkc/rom_fs.c": [
         {
            "type": "func",
            "name": "rom_fread",
            "line_range": [
               57,
               70
            ],
            "source_code": "size_t rom_fread(void* ptr, size_t size, size_t nitems, rom_file_t* f) {\n  size_t available = 0;\n  size_t nr = size * nitems;\n  return_value_if_fail(size > 0, 0);\n  return_value_if_fail(ptr != NULL && f != NULL, 0);\n\n  available = f->capacity - f->cursor;\n  nr = tk_min(nr, available);\n\n  memcpy(ptr, f->data + f->cursor, nr);\n  f->cursor += nr;\n\n  return nr / size;\n}",
            "key_variables": [
               [
                  64,
                  "f->cursor"
               ]
            ]
         },
         {
            "type": "func",
            "name": "rom_ftell",
            "line_range": [
               80,
               84
            ],
            "source_code": "long rom_ftell(rom_file_t* f) {\n  return_value_if_fail(f != NULL, -1);\n\n  return f->cursor;\n}",
            "key_variables": [
               [
                  84,
                  "f->cursor"
               ],
               [
                  90,
                  "f->capacity"
               ]
            ]
         },
         {
            "type": "func",
            "name": "rom_ferror",
            "line_range": [
               92,
               94
            ],
            "source_code": "int rom_ferror(rom_file_t* f) {\n  return 0;\n}",
            "key_variables": [
               [
                  106,
                  "f->capacity"
               ]
            ]
         }
      ],
      "src/tkc/slist.c": [
         {
            "type": "func",
            "name": "slist_find",
            "line_range": [
               59,
               75
            ],
            "source_code": "void* slist_find(slist_t* slist, void* ctx) {\n  slist_node_t* iter = NULL;\n  return_value_if_fail(slist != NULL, NULL);\n  if (slist->first == NULL) {\n    return NULL;\n  }\n\n  iter = slist->first;\n  while (iter != NULL) {\n    if (slist->compare(iter->data, ctx) == 0) {\n      return iter->data;\n    }\n    iter = iter->next;\n  }\n\n  return NULL;\n}",
            "key_variables": [
               [
                  67,
                  "slist->first"
               ],
               [
                  70,
                  "iter->data"
               ],
               [
                  72,
                  "iter->next"
               ],
               [
                  86,
                  "slist->first"
               ],
               [
                  87,
                  "slist->first"
               ],
               [
                  91,
                  "first->next"
               ],
               [
                  93,
                  "iter->next"
               ],
               [
                  95,
                  "iter->next"
               ],
               [
                  104,
                  "iter->next"
               ]
            ]
         },
         {
            "type": "func",
            "name": "slist_remove",
            "line_range": [
               110,
               112
            ],
            "source_code": "ret_t slist_remove(slist_t* slist, void* ctx) {\n  return slist_remove_with_compare(slist, ctx, slist->compare, 1);\n}",
            "key_variables": [
               [
                  122,
                  "slist->first"
               ],
               [
                  127,
                  "iter->next"
               ],
               [
                  142,
                  "slist->first"
               ]
            ]
         },
         {
            "type": "func",
            "name": "slist_foreach",
            "line_range": [
               147,
               163
            ],
            "source_code": "ret_t slist_foreach(slist_t* slist, tk_visit_t visit, void* ctx) {\n  ret_t ret = RET_OK;\n  slist_node_t* iter = NULL;\n  return_value_if_fail(slist != NULL && visit != NULL, RET_BAD_PARAMS);\n\n  iter = slist->first;\n  while (iter != NULL) {\n    ret = visit(ctx, iter->data);\n    if (ret != RET_OK) {\n      break;\n    }\n\n    iter = iter->next;\n  }\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  153,
                  "slist->first"
               ],
               [
                  160,
                  "iter->next"
               ],
               [
                  172,
                  "slist->first"
               ],
               [
                  180,
                  "iter->next"
               ],
               [
                  186,
                  "iter->data"
               ]
            ]
         },
         {
            "type": "func",
            "name": "slist_tail_pop",
            "line_range": [
               165,
               189
            ],
            "source_code": "void* slist_tail_pop(slist_t* slist) {\n  void* data = NULL;\n  slist_node_t* iter = NULL;\n  slist_node_t* last_iter = NULL;\n  return_value_if_fail(slist != NULL, NULL);\n\n  iter = slist->first;\n  return_value_if_fail(iter != NULL, NULL);\n\n  if (iter->next == NULL) {\n    slist->first = NULL;\n  } else {\n    while (iter->next != NULL) {\n      last_iter = iter;\n      iter = iter->next;\n    }\n\n    last_iter->next = NULL;\n  }\n\n  data = iter->data;\n  TKMEM_FREE(iter);\n\n  return data;\n}",
            "key_variables": [
               [
                  197,
                  "slist->first"
               ],
               [
                  200,
                  "iter->next"
               ],
               [
                  202,
                  "iter->data"
               ]
            ]
         },
         {
            "type": "func",
            "name": "slist_head_pop",
            "line_range": [
               191,
               205
            ],
            "source_code": "void* slist_head_pop(slist_t* slist) {\n  void* data = NULL;\n  slist_node_t* iter = NULL;\n  return_value_if_fail(slist != NULL, NULL);\n\n  iter = slist->first;\n  return_value_if_fail(iter != NULL, NULL);\n\n  slist->first = iter->next;\n\n  data = iter->data;\n  TKMEM_FREE(iter);\n\n  return data;\n}",
            "key_variables": [
               [
                  213,
                  "slist->first"
               ],
               [
                  216,
                  "iter->next"
               ],
               [
                  227,
                  "slist->first"
               ],
               [
                  232,
                  "iter->next"
               ]
            ]
         },
         {
            "type": "func",
            "name": "slist_count",
            "line_range": [
               221,
               235
            ],
            "source_code": "int32_t slist_count(slist_t* slist, void* ctx) {\n  int32_t size = 0;\n  slist_node_t* iter = NULL;\n  return_value_if_fail(slist != NULL, 0);\n\n  iter = slist->first;\n  while (iter != NULL) {\n    if (slist->compare(iter->data, ctx) == 0) {\n      size++;\n    }\n    iter = iter->next;\n  }\n\n  return size;\n}",
            "key_variables": [
               [
                  245,
                  "slist->first"
               ],
               [
                  248,
                  "iter->next"
               ]
            ]
         },
         {
            "type": "func",
            "name": "slist_deinit",
            "line_range": [
               237,
               239
            ],
            "source_code": "ret_t slist_deinit(slist_t* slist) {\n  return slist_remove_all(slist);\n}",
            "key_variables": [
               [
                  277,
                  "slist->first"
               ],
               [
                  278,
                  "slist->first"
               ],
               [
                  282,
                  "iter->next"
               ],
               [
                  286,
                  "prev->next"
               ]
            ]
         }
      ],
      "src/tkc/str.c": [
         {
            "type": "func",
            "name": "str_append_more",
            "line_range": [
               102,
               122
            ],
            "source_code": "ret_t str_append_more(str_t* str, const char* text, ...) {\n  va_list va;\n  const char* p = NULL;\n  return_value_if_fail(str != NULL && text != NULL, RET_BAD_PARAMS);\n\n  return_value_if_fail(str_append(str, text) == RET_OK, RET_OOM);\n\n  va_start(va, text);\n  do {\n    p = va_arg(va, char*);\n    if (p != NULL) {\n      return_value_if_fail(str_append(str, p) == RET_OK, RET_OOM);\n    } else {\n      break;\n    }\n  } while (p != NULL);\n\n  va_end(va);\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  126,
                  "num[32]"
               ]
            ]
         },
         {
            "type": "func",
            "name": "str_append_int",
            "line_range": [
               124,
               129
            ],
            "source_code": "ret_t str_append_int(str_t* str, int32_t value) {\n  char num[32];\n  tk_snprintf(num, sizeof(num), \"%d\", value);\n\n  return str_append(str, num);\n}",
            "key_variables": [
               [
                  148,
                  "str->str"
               ],
               [
                  174,
                  "str->str"
               ]
            ]
         },
         {
            "type": "func",
            "name": "str_decode_xml_entity",
            "line_range": [
               178,
               182
            ],
            "source_code": "ret_t str_decode_xml_entity(str_t* str, const char* text) {\n  return_value_if_fail(str != NULL && text != NULL, RET_BAD_PARAMS);\n\n  return str_decode_xml_entity_with_len(str, text, strlen(text));\n}",
            "key_variables": [
               [
                  189,
                  "str->str"
               ],
               [
                  190,
                  "str->str"
               ],
               [
                  233,
                  "str->str"
               ]
            ]
         },
         {
            "type": "func",
            "name": "str_eq",
            "line_range": [
               237,
               251
            ],
            "source_code": "bool_t str_eq(str_t* str, const char* text) {\n  if ((str == NULL && text == NULL) || (str != NULL && str->str == NULL && text == NULL)) {\n    return TRUE;\n  }\n\n  if (str == NULL || text == NULL || str->str == NULL) {\n    return FALSE;\n  }\n\n  if (str->str[0] != text[0]) {\n    return FALSE;\n  }\n\n  return strcmp(str->str, text) == 0;\n}",
            "key_variables": [
               [
                  255,
                  "buff[TK_NUM_MAX_LEN + 1]"
               ],
               [
                  262,
                  "buff[TK_NUM_MAX_LEN + 1]"
               ]
            ]
         },
         {
            "type": "func",
            "name": "str_start_with",
            "line_range": [
               347,
               351
            ],
            "source_code": "bool_t str_start_with(str_t* str, const char* text) {\n  return_value_if_fail(str != NULL && str->str != NULL && text != NULL, FALSE);\n\n  return strncmp(str->str, text, strlen(text)) == 0;\n}",
            "key_variables": [
               [
                  357,
                  "str->str"
               ],
               [
                  358,
                  "str->size"
               ],
               [
                  370,
                  "p[i]"
               ],
               [
                  378,
                  "p[i]"
               ]
            ]
         },
         {
            "type": "func",
            "name": "str_trim_left",
            "line_range": [
               353,
               382
            ],
            "source_code": "ret_t str_trim_left(str_t* str, const char* text) {\n  uint32_t i = 0;\n  uint32_t k = 0;\n  char* p = str->str;\n  uint32_t n = str->size;\n  return_value_if_fail(str != NULL && str->str != NULL, RET_BAD_PARAMS);\n\n  if (!str->size) {\n    return RET_OK;\n  }\n\n  if (text == NULL) {\n    text = \" \";\n  }\n\n  for (i = 0; i < n; i++) {\n    char c = p[i];\n    if (strchr(text, c) == NULL) {\n      break;\n    }\n  }\n\n  str->size = n - i;\n  for (k = 0; i < n; i++, k++) {\n    p[k] = p[i];\n  }\n  str->str[str->size] = '\\0';\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  387,
                  "str->str"
               ],
               [
                  388,
                  "str->size"
               ],
               [
                  400,
                  "p[i]"
               ]
            ]
         },
         {
            "type": "func",
            "name": "str_trim_right",
            "line_range": [
               384,
               409
            ],
            "source_code": "ret_t str_trim_right(str_t* str, const char* text) {\n  int32_t i = 0;\n  char* p = str->str;\n  uint32_t n = str->size;\n  return_value_if_fail(str != NULL && str->str != NULL, RET_BAD_PARAMS);\n\n  if (!str->size) {\n    return RET_OK;\n  }\n\n  if (text == NULL) {\n    text = \" \";\n  }\n\n  for (i = n - 1; i >= 0; i--) {\n    char c = p[i];\n    if (strchr(text, c) == NULL) {\n      break;\n    }\n  }\n\n  p[i + 1] = '\\0';\n  str->size = i + 1;\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  423,
                  "s->str"
               ]
            ]
         },
         {
            "type": "func",
            "name": "str_count_sub_str",
            "line_range": [
               421,
               439
            ],
            "source_code": "static uint32_t str_count_sub_str(str_t* s, const char* str) {\n  char* p = s->str;\n  uint32_t count = 0;\n  uint32_t size = strlen(str);\n\n  if (size == 0) {\n    return 0;\n  }\n\n  do {\n    p = strstr(p, str);\n    if (p != NULL) {\n      count++;\n      p += size;\n    }\n  } while (p != NULL);\n\n  return count;\n}",
            "key_variables": [
               [
                  451,
                  "str->str"
               ],
               [
                  452,
                  "str->str"
               ],
               [
                  492,
                  "s->str"
               ],
               [
                  493,
                  "s->size"
               ]
            ]
         },
         {
            "type": "func",
            "name": "str_replace",
            "line_range": [
               441,
               487
            ],
            "source_code": "ret_t str_replace(str_t* str, const char* text, const char* new_text) {\n  uint32_t count = 0;\n\n  return_value_if_fail(str != NULL && str->str != NULL && text != NULL && new_text != NULL,\n                       RET_BAD_PARAMS);\n\n  count = str_count_sub_str(str, text);\n\n  if (count > 0) {\n    char* p = str->str;\n    char* src = str->str;\n    uint32_t str_len = strlen(text);\n    uint32_t new_text_len = strlen(new_text);\n    uint32_t capacity = str->size + count * (strlen(new_text) - strlen(text)) + 1;\n\n    char* temp_str = (char*)TKMEM_ALLOC(capacity);\n    char* dst = temp_str;\n    return_value_if_fail(temp_str != NULL, RET_OOM);\n    do {\n      uint32_t size = 0;\n      p = strstr(src, text);\n      if (p != NULL) {\n        size = (uint32_t)(p - src);\n      } else {\n        size = (uint32_t)strlen(src);\n      }\n      memcpy(dst, src, size);\n      src += size;\n      dst += size;\n      if (p != NULL) {\n        if (new_text_len > 0) {\n          memcpy(dst, new_text, new_text_len);\n          dst += new_text_len;\n        }\n        src += str_len;\n      }\n      *dst = '\\0';\n    } while (p != NULL);\n\n    TKMEM_FREE(str->str);\n    str->str = temp_str;\n    str->size = strlen(str->str);\n    str->capacity = capacity;\n  }\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  506,
                  "s->str"
               ],
               [
                  507,
                  "s->size"
               ]
            ]
         },
         {
            "type": "func",
            "name": "str_remove",
            "line_range": [
               535,
               543
            ],
            "source_code": "ret_t str_remove(str_t* s, uint32_t offset, uint32_t size) {\n  return_value_if_fail(s != NULL && (offset + size) <= s->size && size > 0, RET_BAD_PARAMS);\n\n  memmove(s->str + offset, s->str + offset + size, strlen(s->str + offset + size));\n  s->size -= size;\n  s->str[s->size] = '\\0';\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  549,
                  "name[TK_NAME_LEN + 1]"
               ],
               [
                  566,
                  "num[TK_NUM_MAX_LEN + 1]"
               ]
            ]
         },
         {
            "type": "func",
            "name": "str_expand_vars",
            "line_range": [
               574,
               596
            ],
            "source_code": "ret_t str_expand_vars(str_t* str, const char* src, const object_t* obj) {\n  const char* p = src;\n  return_value_if_fail(str != NULL && src != NULL && obj != NULL, RET_BAD_PARAMS);\n\n  while (*p) {\n    char c = *p;\n\n    if (c == '$') {\n      if (strncmp(p, \"${}\", 3) == 0) {\n        p += 3;\n      } else if (p[1] && p[2]) {\n        p = expand_var(str, p + 2, obj);\n      } else {\n        return RET_BAD_PARAMS;\n      }\n    } else {\n      str_append_char(str, c);\n      p++;\n    }\n  }\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  609,
                  "buff[64]"
               ]
            ]
         },
         {
            "type": "func",
            "name": "str_append_json_str_pair",
            "line_range": [
               645,
               653
            ],
            "source_code": "ret_t str_append_json_str_pair(str_t* str, const char* key, const char* value) {\n  return_value_if_fail(str != NULL && key != NULL && value != NULL, RET_BAD_PARAMS);\n\n  return_value_if_fail(str_append_json_str(str, key) == RET_OK, RET_OOM);\n  return_value_if_fail(str_append_char(str, ':') == RET_OK, RET_OOM);\n  return_value_if_fail(str_append_json_str(str, value) == RET_OK, RET_OOM);\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  676,
                  "tstr[64]"
               ],
               [
                  695,
                  "v[3]"
               ],
               [
                  698,
                  "str->str"
               ]
            ]
         }
      ],
      "src/tkc/str_str.c": [
         {
            "type": "func",
            "name": "str_str_value",
            "line_range": [
               23,
               36
            ],
            "source_code": "const char* str_str_value(const str_str_t* items, const char* name) {\n  const str_str_t* iter = items;\n  return_value_if_fail(items != NULL && name != NULL, NULL);\n\n  while (iter->name != NULL) {\n    if (tk_str_eq(iter->name, name)) {\n      return iter->value;\n    }\n\n    iter++;\n  }\n\n  return NULL;\n}",
            "key_variables": [
               [
                  30,
                  "iter->value"
               ]
            ]
         },
         {
            "type": "func",
            "name": "str_str_name",
            "line_range": [
               38,
               51
            ],
            "source_code": "const char* str_str_name(const str_str_t* items, const char* value) {\n  const str_str_t* iter = items;\n  return_value_if_fail(items != NULL && value != NULL, NULL);\n\n  while (iter->value != NULL) {\n    if (tk_str_eq(iter->value, value)) {\n      return iter->name;\n    }\n\n    iter++;\n  }\n\n  return NULL;\n}",
            "key_variables": [
               [
                  45,
                  "iter->name"
               ]
            ]
         }
      ],
      "src/tkc/timer_manager.c": [
         {
            "type": "func",
            "name": "timer_manager_add_with_type",
            "line_range": [
               97,
               107
            ],
            "source_code": "uint32_t timer_manager_add_with_type(timer_manager_t* timer_manager, timer_func_t on_timer,\n                                     void* ctx, uint32_t duration, uint16_t timer_info_type) {\n  timer_info_t* timer = NULL;\n  return_value_if_fail(on_timer != NULL, TK_INVALID_ID);\n  return_value_if_fail(timer_manager != NULL, TK_INVALID_ID);\n\n  timer = timer_info_create(timer_manager, on_timer, ctx, duration, timer_info_type);\n  return_value_if_fail(timer != NULL, TK_INVALID_ID);\n\n  return timer->id;\n}",
            "key_variables": [
               [
                  107,
                  "timer->id"
               ]
            ]
         },
         {
            "type": "func",
            "name": "timer_manager_reset",
            "line_range": [
               133,
               139
            ],
            "source_code": "ret_t timer_manager_reset(timer_manager_t* timer_manager, uint32_t timer_id) {\n  timer_info_t* info = (timer_info_t*)timer_manager_find(timer_manager, timer_id);\n  return_value_if_fail(info != NULL, RET_NOT_FOUND);\n  info->start = timer_manager->get_time();\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  155,
                  "iter->next"
               ]
            ]
         },
         {
            "type": "func",
            "name": "timer_manager_find",
            "line_range": [
               141,
               147
            ],
            "source_code": "const timer_info_t* timer_manager_find(timer_manager_t* timer_manager, uint32_t timer_id) {\n  timer_info_t timer;\n  return_value_if_fail(timer_id != TK_INVALID_ID, NULL);\n  return_value_if_fail(timer_manager != NULL, NULL);\n\n  return slist_find(&(timer_manager->timers), timer_info_init_dummy(&timer, timer_id));\n}",
            "key_variables": [
               [
                  185,
                  "timer_manager->last_dispatch_time"
               ]
            ]
         },
         {
            "type": "func",
            "name": "timer_manager_dispatch_one",
            "line_range": [
               149,
               176
            ],
            "source_code": "static ret_t timer_manager_dispatch_one(timer_manager_t* timer_manager, uint64_t now,\n                                        int32_t delta_time) {\n  slist_node_t* iter = timer_manager->timers.first;\n\n  while (iter != NULL && !timer_info_is_available(TIMER_INFO(iter->data), now)) {\n    iter = iter->next;\n  }\n\n  if (iter != NULL) {\n    timer_info_t* timer = (timer_info_t*)object_ref((object_t*)(iter->data));\n    return_value_if_fail(timer != NULL, RET_BAD_PARAMS);\n\n    timer->now = now;\n    if (!timer->suspend && (timer->start + timer->duration) <= now) {\n      if (timer_info_on_timer(timer, now) != RET_REPEAT) {\n        timer_manager_remove(timer_manager, timer->id);\n      } else {\n        timer->start = now;\n      }\n    }\n\n    object_unref((object_t*)timer);\n\n    return RET_OK;\n  }\n\n  return RET_DONE;\n}",
            "key_variables": [
               [
                  217,
                  "timer->duration"
               ],
               [
                  219,
                  "iter->next"
               ]
            ]
         }
      ],
      "src/tkc/tokenizer.c": [
         {
            "type": "func",
            "name": "tokenizer_init",
            "line_range": [
               40,
               43
            ],
            "source_code": "tokenizer_t* tokenizer_init(tokenizer_t* tokenizer, const char* str, uint32_t size,\n                            const char* separtor) {\n  return tokenizer_init_ex(tokenizer, str, size, separtor, NULL);\n}",
            "key_variables": [
               [
                  50,
                  "str[tokenizer->cursor]"
               ]
            ]
         },
         {
            "type": "func",
            "name": "tokenizer_skip_non_separator",
            "line_range": [
               60,
               78
            ],
            "source_code": "static ret_t tokenizer_skip_non_separator(tokenizer_t* tokenizer) {\n  const char* separtor = NULL;\n  const char* single_char_token = NULL;\n  return_value_if_fail(tokenizer != NULL, RET_BAD_PARAMS);\n\n  separtor = tokenizer->separtor;\n  single_char_token = tokenizer->single_char_token != NULL ? tokenizer->single_char_token : \"\";\n\n  while (tokenizer->cursor < tokenizer->size) {\n    char c = tokenizer->str[tokenizer->cursor];\n    if (strchr(separtor, c) == NULL && strchr(single_char_token, c) == NULL) {\n      tokenizer->cursor++;\n    } else {\n      break;\n    }\n  }\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  66,
                  "tokenizer->separtor"
               ],
               [
                  70,
                  "str[tokenizer->cursor]"
               ],
               [
                  84,
                  "tokenizer->size"
               ]
            ]
         },
         {
            "type": "func",
            "name": "tokenizer_has_more",
            "line_range": [
               80,
               84
            ],
            "source_code": "bool_t tokenizer_has_more(tokenizer_t* tokenizer) {\n  return_value_if_fail(tokenizer != NULL, FALSE);\n\n  return tokenizer->cursor < tokenizer->size;\n}",
            "key_variables": [
               [
                  89,
                  "str[tokenizer->cursor]"
               ],
               [
                  94,
                  "str[tokenizer->cursor++]"
               ]
            ]
         },
         {
            "type": "func",
            "name": "tokenizer_closing_bracket_until",
            "line_range": [
               111,
               134
            ],
            "source_code": "static ret_t tokenizer_closing_bracket_until(tokenizer_t* tokenizer, char opening_bracket,\n                                             char closing_bracket) {\n  int32_t lparent = 1;\n\n  tokenizer->cursor++;\n  while (tokenizer->str[tokenizer->cursor]) {\n    char c = tokenizer->str[tokenizer->cursor];\n    if (c == '\\\"') {\n      tokenizer_skip_quoted_str(tokenizer);\n      continue;\n    } else if (c == opening_bracket) {\n      lparent++;\n    } else if (c == closing_bracket) {\n      lparent--;\n      if (lparent <= 0) {\n        tokenizer->cursor++;\n        break;\n      }\n    }\n    tokenizer->cursor++;\n  }\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  118,
                  "str[tokenizer->cursor]"
               ],
               [
                  143,
                  "tokenizer->cursor"
               ],
               [
                  146,
                  "str[tokenizer->cursor]"
               ],
               [
                  172,
                  "s->str"
               ]
            ]
         },
         {
            "type": "func",
            "name": "tokenizer_next_expr_until",
            "line_range": [
               136,
               175
            ],
            "source_code": "const char* tokenizer_next_expr_until(tokenizer_t* tokenizer, const char* str) {\n  return_value_if_fail(tokenizer_skip_separator(tokenizer) == RET_OK && str != NULL, NULL);\n\n  if (tokenizer_has_more(tokenizer)) {\n    uint32_t len = 0;\n    str_t* s = &(tokenizer->token);\n    uint32_t start = tokenizer->cursor;\n\n    while (tokenizer->str[tokenizer->cursor]) {\n      char c = tokenizer->str[tokenizer->cursor];\n      if (c == '\\\"') {\n        tokenizer_skip_quoted_str(tokenizer);\n        continue;\n      } else if (c == '(') {\n        tokenizer_closing_bracket_until(tokenizer, '(', ')');\n        continue;\n      } else if (c == '{') {\n        tokenizer_closing_bracket_until(tokenizer, '{', '}');\n        continue;\n      } else if (c == '[') {\n        tokenizer_closing_bracket_until(tokenizer, '[', ']');\n        continue;\n      }\n\n      if (strchr(str, c) != NULL) {\n        break;\n      }\n\n      tokenizer->cursor++;\n    }\n\n    len = tokenizer->cursor - start;\n    str_set_with_len(s, tokenizer->str + start, len);\n    tokenizer_skip_separator(tokenizer);\n\n    return s->str;\n  }\n\n  return NULL;\n}",
            "key_variables": [
               [
                  184,
                  "tokenizer->cursor"
               ],
               [
                  187,
                  "str[tokenizer->cursor]"
               ],
               [
                  198,
                  "s->str"
               ],
               [
                  210,
                  "tokenizer->cursor"
               ],
               [
                  217,
                  "s->str"
               ],
               [
                  227,
                  "s->str"
               ]
            ]
         }
      ],
      "src/tkc/typed_array.c": [
         {
            "type": "func",
            "name": "typed_array_create",
            "line_range": [
               46,
               63
            ],
            "source_code": "typed_array_t* typed_array_create(value_type_t type, uint32_t capacity) {\n  typed_array_t* typed_array = NULL;\n  uint32_t element_size = value_type_size(type);\n  return_value_if_fail(typed_array_is_type_supported(type), NULL);\n  typed_array = TKMEM_ZALLOC(typed_array_t);\n  return_value_if_fail(typed_array != NULL, NULL);\n\n  typed_array->type = type;\n  typed_array->element_size = element_size;\n  if (capacity > 0) {\n    if (typed_array_extend(typed_array, capacity) != RET_OK) {\n      TKMEM_FREE(typed_array);\n      return NULL;\n    }\n  }\n\n  return typed_array;\n}",
            "key_variables": [
               [
                  70,
                  "typed_array->element_size"
               ]
            ]
         },
         {
            "type": "func",
            "name": "typed_array_set",
            "line_range": [
               123,
               179
            ],
            "source_code": "ret_t typed_array_set(typed_array_t* typed_array, uint32_t index, const value_t* v) {\n  uint8_t* p = NULL;\n  return_value_if_fail(typed_array != NULL && v != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(typed_array->data != NULL && index < typed_array->size, RET_BAD_PARAMS);\n  p = typed_array->data + index * typed_array->element_size;\n\n  switch (typed_array->type) {\n    case VALUE_TYPE_INT8: {\n      *(int8_t*)p = value_int8(v);\n      return RET_OK;\n    }\n    case VALUE_TYPE_UINT8: {\n      *(uint8_t*)p = value_uint8(v);\n      return RET_OK;\n    }\n    case VALUE_TYPE_INT16: {\n      *(int16_t*)p = value_int16(v);\n      return RET_OK;\n    }\n    case VALUE_TYPE_UINT16: {\n      *(uint16_t*)p = value_uint16(v);\n      return RET_OK;\n    }\n    case VALUE_TYPE_INT32: {\n      *(int32_t*)p = value_int32(v);\n      return RET_OK;\n    }\n    case VALUE_TYPE_UINT32: {\n      *(uint32_t*)p = value_uint32(v);\n      return RET_OK;\n    }\n    case VALUE_TYPE_INT64: {\n      *(int64_t*)p = value_int64(v);\n      return RET_OK;\n    }\n    case VALUE_TYPE_UINT64: {\n      *(uint64_t*)p = value_uint64(v);\n      return RET_OK;\n    }\n    case VALUE_TYPE_FLOAT: {\n      *(float_t*)p = value_float(v);\n      return RET_OK;\n    }\n    case VALUE_TYPE_FLOAT32: {\n      *(float*)p = value_float32(v);\n      return RET_OK;\n    }\n    case VALUE_TYPE_DOUBLE: {\n      *(double*)p = value_double(v);\n      return RET_OK;\n    }\n    default: {\n      assert(!\"not supported type\");\n      return RET_NOT_IMPL;\n    }\n  }\n}",
            "key_variables": [
               [
                  128,
                  "typed_array->element_size"
               ],
               [
                  186,
                  "typed_array->element_size"
               ],
               [
                  187,
                  "typed_array->size"
               ]
            ]
         },
         {
            "type": "func",
            "name": "typed_array_insert",
            "line_range": [
               211,
               233
            ],
            "source_code": "ret_t typed_array_insert(typed_array_t* typed_array, uint32_t index, const value_t* v) {\n  uint8_t* p = NULL;\n  uint8_t* s = NULL;\n  uint8_t* d = NULL;\n  uint32_t element_size = 0;\n  return_value_if_fail(typed_array != NULL && v != NULL, RET_BAD_PARAMS);\n  index = tk_min(index, typed_array->size);\n  return_value_if_fail(typed_array_extend_delta(typed_array, 1) == RET_OK, RET_OOM);\n\n  element_size = typed_array->element_size;\n  p = typed_array->data + index * element_size;\n  d = typed_array->data + element_size * typed_array->size;\n  s = d - element_size;\n\n  while (s >= p) {\n    memcpy(d, s, element_size);\n    s -= element_size;\n    d -= element_size;\n  }\n  typed_array->size++;\n\n  return typed_array_set(typed_array, index, v);\n}",
            "key_variables": [
               [
                  221,
                  "typed_array->element_size"
               ],
               [
                  223,
                  "typed_array->size"
               ],
               [
                  244,
                  "typed_array->element_size"
               ],
               [
                  247,
                  "typed_array->size"
               ]
            ]
         }
      ],
      "src/tkc/utf8.c": [
         {
            "type": "func",
            "name": "utf16_to_utf8",
            "line_range": [
               138,
               230
            ],
            "source_code": "static char* utf16_to_utf8(const wchar_t* str, int32_t len, char* utf8, int out_len) {\n  /* This function and g_utf16_to_ucs4 are almost exactly identical - The lines\n   * that differ are marked.\n   */\n  const wchar_t* in;\n  char* out;\n  char* result = NULL;\n  int n_bytes;\n  wchar_t high_surrogate;\n\n  return_value_if_fail(str != NULL, NULL);\n\n  n_bytes = 0;\n  in = str;\n  high_surrogate = 0;\n  while ((len < 0 || in - str < len) && *in) {\n    wchar_t c = *in;\n    wchar_t wc;\n\n    if (c >= 0xdc00 && c < 0xe000) /* low surrogate */\n    {\n      if (high_surrogate) {\n        wc = SURROGATE_VALUE(high_surrogate, c);\n        high_surrogate = 0;\n      } else {\n        log_error(\"Invalid sequence in conversion input\");\n        goto err_out;\n      }\n    } else {\n      if (high_surrogate) {\n        log_error(\"Invalid sequence in conversion input\");\n        goto err_out;\n      }\n\n      if (c >= 0xd800 && c < 0xdc00) /* high surrogate */\n      {\n        high_surrogate = c;\n        goto next1;\n      } else\n        wc = c;\n    }\n\n    /********** DIFFERENT for UTF8/UCS4 **********/\n    n_bytes += UTF8_LENGTH(wc);\n\n  next1:\n    in++;\n  }\n\n  if (high_surrogate) {\n    log_error(\"Partial character sequence at end of input\");\n    goto err_out;\n  }\n\n  /* At this point, everything is valid, and we just need to convert\n   */\n  /********** DIFFERENT for UTF8/UCS4 **********/\n  // result = g_malloc (n_bytes + 1);\n  result = utf8;\n  assert(out_len > n_bytes);\n\n  high_surrogate = 0;\n  out = result;\n  in = str;\n  while (out < result + n_bytes) {\n    wchar_t c = *in;\n    wchar_t wc;\n\n    if (c >= 0xdc00 && c < 0xe000) /* low surrogate */\n    {\n      wc = SURROGATE_VALUE(high_surrogate, c);\n      high_surrogate = 0;\n    } else if (c >= 0xd800 && c < 0xdc00) /* high surrogate */\n    {\n      high_surrogate = c;\n      goto next2;\n    } else\n      wc = c;\n\n    /********** DIFFERENT for UTF8/UCS4 **********/\n    out += unichar_to_utf8(wc, out);\n\n  next2:\n    in++;\n  }\n\n  /********** DIFFERENT for UTF8/UCS4 **********/\n  *out = '\\0';\n\n  return result;\nerr_out:\n  return NULL;\n}",
            "key_variables": [
               [
                  196,
                  "malloc"
               ]
            ]
         }
      ],
      "src/tkc/utils.c": [
         {
            "type": "func",
            "name": "tk_atob",
            "line_range": [
               48,
               54
            ],
            "source_code": "bool_t tk_atob(const char* str) {\n  if (str == NULL || *str == 'f' || *str == 'F') {\n    return FALSE;\n  }\n\n  return TRUE;\n}",
            "key_variables": [
               [
                  66,
                  "str[i]"
               ],
               [
                  76,
                  "str[i]"
               ],
               [
                  86,
                  "str[i]"
               ]
            ]
         },
         {
            "type": "func",
            "name": "tk_strdup",
            "line_range": [
               339,
               343
            ],
            "source_code": "char* tk_strdup(const char* str) {\n  return_value_if_fail(str != NULL, NULL);\n\n  return tk_strndup(str, strlen(str));\n}",
            "key_variables": [
               [
                  412,
                  "src[0]"
               ],
               [
                  413,
                  "src[1]"
               ],
               [
                  414,
                  "src[2]"
               ],
               [
                  441,
                  "src[0]"
               ],
               [
                  442,
                  "src[1]"
               ],
               [
                  443,
                  "src[2]"
               ]
            ]
         },
         {
            "type": "func",
            "name": "xml_property_get_close_state",
            "line_range": [
               582,
               609
            ],
            "source_code": "static xml_property_close_state_t xml_property_get_close_state(const char* start, const char* end) {\n  const char* tmp = start;\n  xml_property_close_state_t close_state = XML_PROPERTY_CLOSE_STATE_CLOSE;\n\n  while (tmp != end) {\n    if (*tmp == CHAR_DOUDLE_QUOTE) {\n      if (close_state == XML_PROPERTY_CLOSE_STATE_OPEN_DOUDLE_QUOTE) {\n        close_state = XML_PROPERTY_CLOSE_STATE_CLOSE;\n      } else if (close_state == XML_PROPERTY_CLOSE_STATE_CLOSE) {\n        close_state = XML_PROPERTY_CLOSE_STATE_OPEN_DOUDLE_QUOTE;\n      }\n    } else if (*tmp == CHAR_SINGLE_QUOTE) {\n      if (close_state == XML_PROPERTY_CLOSE_STATE_OPEN_SINGLE_QUOTE) {\n        close_state = XML_PROPERTY_CLOSE_STATE_CLOSE;\n      } else if (close_state == XML_PROPERTY_CLOSE_STATE_CLOSE) {\n        close_state = XML_PROPERTY_CLOSE_STATE_OPEN_SINGLE_QUOTE;\n      }\n    } else if (strstr(tmp, TAG_PROPERTY) == tmp) {\n      if (close_state == XML_PROPERTY_CLOSE_STATE_OPEN_PROPERTY) {\n        close_state = XML_PROPERTY_CLOSE_STATE_CLOSE;\n      } else if (close_state == XML_PROPERTY_CLOSE_STATE_CLOSE) {\n        close_state = XML_PROPERTY_CLOSE_STATE_OPEN_PROPERTY;\n      }\n    }\n    tmp++;\n  }\n  return close_state;\n}",
            "key_variables": [
               [
                  614,
                  "subfilename[MAX_PATH + 1]"
               ]
            ]
         },
         {
            "type": "func",
            "name": "tk_wstr_count_c",
            "line_range": [
               977,
               990
            ],
            "source_code": "uint32_t tk_wstr_count_c(const wchar_t* str, wchar_t c) {\n  uint32_t nr = 0;\n  const wchar_t* p = str;\n  return_value_if_fail(p != NULL, nr);\n\n  while (*p) {\n    if (*p == c) {\n      nr++;\n    }\n    p++;\n  }\n\n  return nr;\n}",
            "key_variables": [
               [
                  1085,
                  "buff[32]"
               ]
            ]
         },
         {
            "type": "func",
            "name": "escape_json_str",
            "line_range": [
               1034,
               1048
            ],
            "source_code": "static ret_t escape_json_str(str_t* str, const char* p) {\n  str_append_char(str, '\\\"');\n  if (p != NULL) {\n    while (*p) {\n      if (*p == '\\\"' || *p == '\\\\') {\n        str_append_char(str, '\\\\');\n      }\n      str_append_char(str, *p);\n      p++;\n    }\n  }\n  str_append_char(str, '\\\"');\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  1152,
                  "array[left]"
               ],
               [
                  1157,
                  "array[right]"
               ],
               [
                  1163,
                  "array[left]"
               ]
            ]
         }
      ],
      "src/tkc/wstr.c": [
         {
            "type": "func",
            "name": "wcs_cpy",
            "line_range": [
               48,
               59
            ],
            "source_code": "wchar_t* wcs_cpy(wchar_t* s1, const wchar_t* s2) {\n  wchar_t* d = s1;\n  const wchar_t* s = s2;\n  return_value_if_fail(s1 != NULL && s2 != NULL, NULL);\n\n  while (*s) {\n    *d++ = *s++;\n  }\n  *d = '\\0';\n\n  return s1;\n}",
            "key_variables": [
               [
                  66,
                  "s2[i]"
               ],
               [
                  67,
                  "s2[i]"
               ],
               [
                  73,
                  "s2[i]"
               ]
            ]
         },
         {
            "type": "func",
            "name": "wstr_remove",
            "line_range": [
               206,
               222
            ],
            "source_code": "ret_t wstr_remove(wstr_t* str, uint32_t offset, uint32_t nr) {\n  wchar_t* p = NULL;\n  return_value_if_fail(str != NULL && offset < str->size && nr > 0, RET_BAD_PARAMS);\n\n  if ((offset + nr) > str->size) {\n    nr = str->size - offset;\n  }\n\n  if (nr > 0) {\n    p = str->str;\n    memmove(p + offset, p + offset + nr, (str->size - offset - nr) * sizeof(wchar_t));\n    str->size -= nr;\n    str->str[str->size] = 0;\n  }\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  216,
                  "str->str"
               ],
               [
                  231,
                  "str->str"
               ],
               [
                  239,
                  "p[s]"
               ]
            ]
         },
         {
            "type": "func",
            "name": "wstr_append",
            "line_range": [
               260,
               264
            ],
            "source_code": "ret_t wstr_append(wstr_t* str, const wchar_t* text) {\n  return_value_if_fail(str != NULL && text != NULL, RET_BAD_PARAMS);\n\n  return wstr_append_with_len(str, text, wcslen(text));\n}",
            "key_variables": [
               [
                  277,
                  "buff[TK_NUM_MAX_LEN + 1]"
               ],
               [
                  278,
                  "s[TK_NUM_MAX_LEN + 1]"
               ]
            ]
         },
         {
            "type": "func",
            "name": "wstr_pop",
            "line_range": [
               289,
               295
            ],
            "source_code": "ret_t wstr_pop(wstr_t* str) {\n  return_value_if_fail(str != NULL && str->size > 0, RET_BAD_PARAMS);\n  str->size--;\n  str->str[str->size] = '\\0';\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  319,
                  "buff[TK_NUM_MAX_LEN + 1]"
               ]
            ]
         },
         {
            "type": "func",
            "name": "wstr_equal",
            "line_range": [
               297,
               315
            ],
            "source_code": "bool_t wstr_equal(wstr_t* str, wstr_t* other) {\n  if (str == other) {\n    return TRUE;\n  }\n\n  if (str == NULL || other == NULL) {\n    return FALSE;\n  }\n\n  if (str->str == other->str) {\n    return TRUE;\n  }\n\n  if (str->str == NULL || other->str == NULL) {\n    return FALSE;\n  }\n\n  return wcscmp(str->str, other->str) == 0;\n}",
            "key_variables": [
               [
                  326,
                  "buff[TK_NUM_MAX_LEN + 1]"
               ]
            ]
         },
         {
            "type": "func",
            "name": "wstr_to_fix",
            "line_range": [
               435,
               450
            ],
            "source_code": "ret_t wstr_to_fix(wstr_t* str, uint32_t fraction_nr) {\n  wchar_t* p = NULL;\n  return_value_if_fail(str != NULL && str->str != NULL, RET_BAD_PARAMS);\n\n  p = wcschr(str->str, '.');\n  if (p) {\n    p++;\n    uint32_t nr = wcslen(p);\n    if (nr > fraction_nr) {\n      str->size = p - str->str + fraction_nr;\n      str->str[str->size] = 0;\n    }\n  }\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  476,
                  "str->str"
               ],
               [
                  477,
                  "str->str"
               ],
               [
                  495,
                  "str->str"
               ],
               [
                  506,
                  "str->str"
               ],
               [
                  507,
                  "str->size"
               ]
            ]
         }
      ],
      "src/ubjson/ubjson_parser.c": [
         {
            "type": "block",
            "name": "block",
            "line_range": "",
            "source_code": "",
            "key_variables": [
               41,
               "stack[MAX_LEVEL + 1]"
            ]
         },
         {
            "type": "func",
            "name": "ubjson_parser_push",
            "line_range": [
               65,
               73
            ],
            "source_code": "static ret_t ubjson_parser_push(ubjson_parser_t* parser, object_t* obj) {\n  return_value_if_fail(parser->level < MAX_LEVEL, RET_BAD_PARAMS);\n\n  parser->obj = obj;\n  parser->stack[parser->level] = obj;\n  parser->level++;\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  83,
                  "stack[parser->level - 1]"
               ]
            ]
         }
      ],
      "src/ui_loader/ui_builder_default.c": [
         {
            "type": "func",
            "name": "ui_builder_default_on_widget_start",
            "line_range": [
               28,
               53
            ],
            "source_code": "static ret_t ui_builder_default_on_widget_start(ui_builder_t* b, const widget_desc_t* desc) {\n  const rect_t* layout = &(desc->layout);\n\n  xy_t x = layout->x;\n  xy_t y = layout->y;\n  wh_t w = layout->w;\n  wh_t h = layout->h;\n  widget_t* widget = NULL;\n  widget_t* parent = b->widget;\n  const char* type = desc->type;\n\n  widget = widget_factory_create_widget(widget_factory(), type, parent, x, y, w, h);\n  if (widget == NULL) {\n    log_debug(\"%s: not supported type %s\\n\", __FUNCTION__, type);\n    widget = widget_factory_create_widget(widget_factory(), WIDGET_TYPE_VIEW, parent, x, y, w, h);\n  }\n  return_value_if_fail(widget != NULL, RET_OOM);\n\n  b->widget = widget;\n  b->widget->loading = TRUE;\n  if (b->root == NULL) {\n    b->root = widget;\n  }\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  32,
                  "layout->x"
               ],
               [
                  33,
                  "layout->y"
               ],
               [
                  34,
                  "layout->w"
               ],
               [
                  35,
                  "layout->h"
               ],
               [
                  37,
                  "b->widget"
               ],
               [
                  38,
                  "desc->type"
               ]
            ]
         },
         {
            "type": "func",
            "name": "ui_builder_default_on_widget_end",
            "line_range": [
               68,
               78
            ],
            "source_code": "static ret_t ui_builder_default_on_widget_end(ui_builder_t* b) {\n  if (b->widget != NULL) {\n    event_t e = event_init(EVT_WIDGET_LOAD, NULL);\n    widget_dispatch(b->widget, &e);\n\n    b->widget->loading = FALSE;\n    b->widget = b->widget->parent;\n  }\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  75,
                  "widget->parent"
               ],
               [
                  83,
                  "b->root"
               ]
            ]
         }
      ],
      "src/ui_loader/ui_loader_xml.c": [
         {
            "type": "block",
            "name": "block",
            "line_range": "",
            "source_code": "",
            "key_variables": [
               45,
               "property_name[TK_NAME_LEN * 2 + 2]"
            ]
         },
         {
            "type": "func",
            "name": "is_valid_self_layout",
            "line_range": [
               75,
               78
            ],
            "source_code": "static bool_t is_valid_self_layout(const char* x, const char* y, const char* w, const char* h) {\n  return is_valid_layout_param(x) || is_valid_layout_param(y) || is_valid_layout_param(w) ||\n         is_valid_layout_param(h);\n}",
            "key_variables": [
               [
                  96,
                  "attrs[i]"
               ],
               [
                  97,
                  "attrs[i + 1]"
               ],
               [
                  99,
                  "key[0]"
               ],
               [
                  161,
                  "attrs[i]"
               ],
               [
                  162,
                  "attrs[i + 1]"
               ],
               [
                  163,
                  "key[0]"
               ],
               [
                  184,
                  "attrs[i]"
               ],
               [
                  185,
                  "attrs[i + 1]"
               ],
               [
                  186,
                  "key[0]"
               ]
            ]
         },
         {
            "type": "func",
            "name": "xml_loader_on_start_property",
            "line_range": [
               212,
               224
            ],
            "source_code": "static void xml_loader_on_start_property(XmlBuilder* thiz, const char* tag, const char** attrs) {\n  uint32_t i = 0;\n  xml_builder_t* b = (xml_builder_t*)thiz;\n\n  while (attrs[i] != NULL) {\n    const char* key = attrs[i];\n    const char* value = attrs[i + 1];\n    if (tk_str_eq(key, \"name\")) {\n      tk_strncpy(b->property_name, value, TK_NAME_LEN * 2 + 1);\n      break;\n    }\n  }\n}",
            "key_variables": [
               [
                  218,
                  "attrs[i]"
               ],
               [
                  219,
                  "attrs[i + 1]"
               ]
            ]
         }
      ],
      "src/ui_loader/ui_serializer.c": [
         {
            "type": "func",
            "name": "ui_widget_serialize_props",
            "line_range": [
               54,
               82
            ],
            "source_code": "static ret_t ui_widget_serialize_props(ui_builder_t* writer, widget_t* widget,\n                                       const char* const* properties) {\n  value_t v;\n  value_t defv;\n  uint32_t i = 0;\n  for (i = 0; properties[i] != NULL; i++) {\n    const char* prop = properties[i];\n    if (widget_get_prop(widget, prop, &v) == RET_OK) {\n      if (widget_get_prop_default_value(widget, prop, &defv) == RET_OK) {\n        if (v.type == VALUE_TYPE_STRING && (v.value.str == NULL || v.value.str[0] == '\\0')) {\n          continue;\n        }\n\n        if (v.type == VALUE_TYPE_WSTRING && (v.value.str == NULL || v.value.wstr[0] == '\\0')) {\n          continue;\n        }\n\n        if (value_equal(&v, &defv)) {\n          log_debug(\"skip default value %s\\n\", prop);\n          continue;\n        }\n      }\n\n      ui_widget_serialize_prop(writer, prop, &v);\n    }\n  }\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  61,
                  "properties[i]"
               ]
            ]
         },
         {
            "type": "func",
            "name": "ui_widget_serialize",
            "line_range": [
               84,
               117
            ],
            "source_code": "ret_t ui_widget_serialize(ui_builder_t* writer, widget_t* widget) {\n  widget_desc_t desc;\n\n  if (widget->auto_created) {\n    return RET_OK;\n  }\n\n  memset(&desc, 0x00, sizeof(desc));\n  tk_strncpy(desc.type, widget->vt->type, TK_NAME_LEN);\n\n  desc.layout.x = widget->x;\n  desc.layout.y = widget->y;\n  desc.layout.w = widget->w;\n  desc.layout.h = widget->h;\n\n  ui_builder_on_widget_start(writer, &desc);\n\n  ui_widget_serialize_props(writer, widget, widget_get_persistent_props());\n  if (widget->vt->clone_properties || widget->vt->persistent_properties) {\n    const char* const* properties = widget->vt->persistent_properties;\n    if (properties == NULL) {\n      properties = widget->vt->clone_properties;\n    }\n    ui_widget_serialize_props(writer, widget, properties);\n  }\n\n  ui_builder_on_widget_prop_end(writer);\n  WIDGET_FOR_EACH_CHILD_BEGIN(widget, iter, i)\n  ui_widget_serialize(writer, iter);\n  WIDGET_FOR_EACH_CHILD_END();\n  ui_builder_on_widget_end(writer);\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  95,
                  "widget->x"
               ],
               [
                  96,
                  "widget->y"
               ],
               [
                  97,
                  "widget->w"
               ],
               [
                  98,
                  "widget->h"
               ],
               [
                  104,
                  "vt->persistent_properties"
               ],
               [
                  106,
                  "vt->clone_properties"
               ]
            ]
         }
      ],
      "src/ui_loader/ui_xml_writer.c": [
         {
            "type": "func",
            "name": "ui_xml_writer_write_prop_int",
            "line_range": [
               70,
               75
            ],
            "source_code": "static ret_t ui_xml_writer_write_prop_int(str_t* str, const char* name, int32_t v) {\n  char value[32];\n  tk_snprintf(value, sizeof(value) - 1, \"%d\", v);\n\n  return ui_xml_writer_write_prop(str, name, value);\n}",
            "key_variables": [
               [
                  72,
                  "value[32]"
               ],
               [
                  80,
                  "desc->type"
               ],
               [
                  81,
                  "writer->str"
               ]
            ]
         },
         {
            "type": "func",
            "name": "ui_xml_writer_on_widget_prop_end",
            "line_range": [
               110,
               114
            ],
            "source_code": "static ret_t ui_xml_writer_on_widget_prop_end(ui_builder_t* b) {\n  ui_xml_writer_t* writer = (ui_xml_writer_t*)b;\n\n  return str_append(writer->str, \">\\n\");\n}",
            "key_variables": [
               [
                  121,
                  "writer->level"
               ]
            ]
         },
         {
            "type": "func",
            "name": "ui_xml_writer_get_tag",
            "line_range": [
               116,
               125
            ],
            "source_code": "static const char* ui_xml_writer_get_tag(ui_xml_writer_t* writer) {\n  uint32_t i = 0;\n  const char* tag = writer->tags.str;\n\n  for (i = 0; i < writer->level; i++) {\n    tag += strlen(tag) + 1;\n  }\n\n  return tag;\n}",
            "key_variables": [
               [
                  130,
                  "writer->str"
               ]
            ]
         }
      ],
      "src/vgcanvas/vgcanvas_cairo.c": [
         {
            "type": "func",
            "name": "vgcanvas_cairo_begin_frame",
            "line_range": [
               60,
               77
            ],
            "source_code": "ret_t vgcanvas_cairo_begin_frame(vgcanvas_t* vgcanvas, const dirty_rects_t* dirty_rects) {\n  const rect_t* dirty_rect = dirty_rects != NULL ? &(dirty_rects->max) : NULL;\n  const rect_t* r = dirty_rect;\n  vgcanvas_cairo_t* canvas = (vgcanvas_cairo_t*)vgcanvas;\n  cairo_t* vg = canvas->vg;\n\n  cairo_identity_matrix(vg);\n  vg->status = CAIRO_STATUS_SUCCESS;\n\n  cairo_new_path(vg);\n  cairo_rectangle(vg, r->x, r->y, r->w, r->h);\n  cairo_clip(vg);\n  cairo_new_path(vg);\n  cairo_save(vg);\n  vgcanvas->global_alpha = 1;\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  65,
                  "canvas->vg"
               ]
            ]
         },
         {
            "type": "func",
            "name": "vgcanvas_cairo_end_frame",
            "line_range": [
               79,
               85
            ],
            "source_code": "ret_t vgcanvas_cairo_end_frame(vgcanvas_t* vgcanvas) {\n  vgcanvas_cairo_t* canvas = (vgcanvas_cairo_t*)vgcanvas;\n  cairo_t* vg = canvas->vg;\n  cairo_restore(vg);\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  82,
                  "canvas->vg"
               ]
            ]
         },
         {
            "type": "func",
            "name": "vgcanvas_cairo_reset",
            "line_range": [
               87,
               97
            ],
            "source_code": "static ret_t vgcanvas_cairo_reset(vgcanvas_t* vgcanvas) {\n  vgcanvas_cairo_t* canvas = (vgcanvas_cairo_t*)vgcanvas;\n  cairo_t* vg = canvas->vg;\n\n  cairo_new_path(vg);\n  cairo_identity_matrix(vg);\n  vgcanvas->global_alpha = 1;\n  vg->status = CAIRO_STATUS_SUCCESS;\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  90,
                  "canvas->vg"
               ]
            ]
         },
         {
            "type": "func",
            "name": "vgcanvas_cairo_close_path",
            "line_range": [
               305,
               311
            ],
            "source_code": "static ret_t vgcanvas_cairo_close_path(vgcanvas_t* vgcanvas) {\n  cairo_t* vg = ((vgcanvas_cairo_t*)vgcanvas)->vg;\n\n  cairo_close_path(vg);\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  322,
                  "vgcanvas->fill_color"
               ],
               [
                  330,
                  "vgcanvas->global_alpha"
               ]
            ]
         },
         {
            "type": "func",
            "name": "vgcanvas_cairo_clip_rect",
            "line_range": [
               338,
               347
            ],
            "source_code": "static ret_t vgcanvas_cairo_clip_rect(vgcanvas_t* vgcanvas, float_t x, float_t y, float_t w,\n                                      float_t h) {\n  cairo_t* vg = ((vgcanvas_cairo_t*)vgcanvas)->vg;\n\n  cairo_reset_clip(vg);\n  cairo_rectangle(vg, x, y, w, h);\n  cairo_clip(vg);\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  359,
                  "vgcanvas->stroke_color"
               ],
               [
                  367,
                  "vgcanvas->global_alpha"
               ]
            ]
         },
         {
            "type": "func",
            "name": "create_surface",
            "line_range": [
               426,
               453
            ],
            "source_code": "static cairo_surface_t* create_surface(uint32_t w, uint32_t h, bitmap_format_t format,\n                                       void* fbuff) {\n  int32_t bpp = 0;\n  cairo_format_t cairo_format = CAIRO_FORMAT_ARGB32;\n  switch (format) {\n    case BITMAP_FMT_RGBA8888: {\n      bpp = 4;\n      /*FIXME*/\n      cairo_format = CAIRO_FORMAT_ARGB32;\n      break;\n    }\n    case BITMAP_FMT_BGRA8888: {\n      bpp = 4;\n      cairo_format = CAIRO_FORMAT_ARGB32;\n      break;\n    }\n    case BITMAP_FMT_BGR565: {\n      bpp = 2;\n      cairo_format = CAIRO_FORMAT_RGB16_565;\n      break;\n    }\n    default: {\n      return NULL;\n    }\n  }\n\n  return cairo_image_surface_create_for_data(fbuff, cairo_format, w, h, w * bpp);\n}",
            "key_variables": [
               [
                  457,
                  "img->specific"
               ]
            ]
         },
         {
            "type": "func",
            "name": "vgcanvas_cairo_ensure_image",
            "line_range": [
               469,
               495
            ],
            "source_code": "static cairo_surface_t* vgcanvas_cairo_ensure_image(vgcanvas_cairo_t* vg, bitmap_t* img) {\n  cairo_surface_t* surface = NULL;\n  darray_t* images = &(vg->images);\n  bitmap_t* cairo_img = (bitmap_t*)darray_find(images, img);\n\n  if (cairo_img == NULL) {\n    cairo_img = bitmap_clone(img);\n    return_value_if_fail(cairo_img != NULL, NULL);\n    darray_push(images, cairo_img);\n    bitmap_premulti_alpha(cairo_img);\n  }\n\n  surface = (cairo_surface_t*)(cairo_img->specific);\n  if (surface == NULL) {\n    uint8_t* cairo_img_data = bitmap_lock_buffer_for_read(cairo_img);\n    surface = create_surface(cairo_img->w, cairo_img->h, cairo_img->format, cairo_img_data);\n    bitmap_unlock_buffer(cairo_img);\n\n    if (surface != NULL) {\n      cairo_img->specific = surface;\n      cairo_img->specific_ctx = NULL;\n      cairo_img->specific_destroy = cairo_on_bitmap_destroy;\n    }\n  }\n\n  return surface;\n}",
            "key_variables": [
               [
                  503,
                  "vgcanvas->global_alpha"
               ]
            ]
         },
         {
            "type": "func",
            "name": "vgcanvas_cairo_set_stroke_radial_gradient",
            "line_range": [
               752,
               771
            ],
            "source_code": "static ret_t vgcanvas_cairo_set_stroke_radial_gradient(vgcanvas_t* vgcanvas, float_t cx, float_t cy,\n                                                       float_t inr, float_t outr, color_t icolor,\n                                                       color_t ocolor) {\n  cairo_t* vg = ((vgcanvas_cairo_t*)vgcanvas)->vg;\n  vgcanvas_cairo_t* canvas = (vgcanvas_cairo_t*)vgcanvas;\n\n  if (canvas->stroke_gradient != NULL) {\n    cairo_pattern_destroy(canvas->stroke_gradient);\n    canvas->stroke_gradient = NULL;\n  }\n\n  canvas->stroke_gradient = cairo_pattern_create_radial(cx, cy, inr, cx, cy, outr);\n  cairo_pattern_add_color_stop_color(canvas->stroke_gradient, 0, icolor);\n  cairo_pattern_add_color_stop_color(canvas->stroke_gradient, 1, ocolor);\n\n  cairo_set_source(vg, canvas->stroke_gradient);\n  canvas->stroke_source_type = CAIRO_SOURCE_GRADIENT;\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  853,
                  "vg_cache->vg"
               ]
            ]
         },
         {
            "type": "func",
            "name": "vgcanvas_cairo_reinit",
            "line_range": [
               815,
               858
            ],
            "source_code": "static ret_t vgcanvas_cairo_reinit(vgcanvas_t* vgcanvas, uint32_t w, uint32_t h, uint32_t stride,\n                                   bitmap_format_t format, void* data) {\n  vg_cairo_cache_t tmp;\n  vg_cairo_cache_t* vg_cache = NULL;\n  vgcanvas_cairo_t* canvas = (vgcanvas_cairo_t*)vgcanvas;\n\n  vgcanvas->w = w;\n  vgcanvas->h = h;\n  vgcanvas->ratio = 1;\n  vgcanvas->stride = stride;\n  vgcanvas->format = format;\n  vgcanvas->buff = (uint32_t*)data;\n\n  tmp.fb_data = data;\n  vg_cache = darray_find(&vg_cairo_cache, &tmp);\n  if (vg_cache == NULL) {\n    vg_cache = (vg_cairo_cache_t*)TKMEM_ZALLOC(vg_cairo_cache_t);\n    vg_cache->surface = create_surface(w, h, format, data);\n    if (vg_cache->surface != NULL) {\n      vg_cache->vg = cairo_create(vg_cache->surface);\n    }\n\n    if (vg_cache->vg == NULL) {\n      if (vg_cache->surface != NULL) {\n        cairo_surface_destroy(vg_cache->surface);\n      }\n      TKMEM_FREE(vg_cache);\n      return RET_OOM;\n    }\n\n    if (vg_cairo_cache.size >= VG_CAIRO_CACHE_MAX_NUMBER) {\n      darray_remove_index(&vg_cairo_cache, random() % vg_cairo_cache.size);\n    }\n    vg_cache->fb_data = data;\n    darray_push(&vg_cairo_cache, vg_cache);\n  }\n\n  canvas->vg = vg_cache->vg;\n  return_value_if_fail(canvas->vg, RET_OOM);\n\n  log_debug(\"resize to w=%u h=%u format=%d\\n\", w, h, format);\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  993,
                  "cairo->vg"
               ]
            ]
         }
      ],
      "src/vgcanvas/vgcanvas_nanovg_gl.c": [
         {
            "type": "block",
            "name": "block",
            "line_range": "",
            "source_code": "",
            "key_variables": [
               68,
               "vboIds[2]"
            ]
         }
      ],
      "src/widgets/button.c": [
         {
            "type": "func",
            "name": "button_on_long_press",
            "line_range": [
               72,
               81
            ],
            "source_code": "static ret_t button_on_long_press(const timer_info_t* info) {\n  pointer_event_t evt;\n  widget_t* widget = WIDGET(info->ctx);\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  button_pointer_up_cleanup(widget);\n  widget_dispatch(widget, pointer_event_init(&evt, EVT_LONG_PRESS, widget, 1, 1));\n\n  return RET_REMOVE;\n}",
            "key_variables": [
               [
                  85,
                  "e->type"
               ]
            ]
         },
         {
            "type": "func",
            "name": "button_set_prop",
            "line_range": [
               201,
               213
            ],
            "source_code": "static ret_t button_set_prop(widget_t* widget, const char* name, const value_t* v) {\n  return_value_if_fail(widget != NULL && name != NULL && v != NULL, RET_BAD_PARAMS);\n\n  if (tk_str_eq(name, WIDGET_PROP_REPEAT)) {\n    return button_set_repeat(widget, value_int(v));\n  } else if (tk_str_eq(name, WIDGET_PROP_LONG_PRESS_TIME)) {\n    return button_set_long_press_time(widget, value_int(v));\n  } else if (tk_str_eq(name, WIDGET_PROP_ENABLE_LONG_PRESS)) {\n    return button_set_enable_long_press(widget, value_bool(v));\n  }\n\n  return RET_NOT_FOUND;\n}",
            "key_variables": [
               [
                  231,
                  "widget->astyle"
               ]
            ]
         }
      ],
      "src/widgets/calibration_win.c": [
         {
            "type": "func",
            "name": "calibration_win_get_current_point",
            "line_range": [
               26,
               60
            ],
            "source_code": "static point_t calibration_win_get_current_point(widget_t* widget, uint32_t point_name) {\n  point_t pt = {0, 0};\n  calibration_win_t* win = CALIBRATION_WIN(widget);\n  return_value_if_fail(win != NULL, pt);\n\n  switch (point_name) {\n    case PT_TOP_LEFT: {\n      pt.x = win->x_offset;\n      pt.y = win->y_offset;\n      break;\n    };\n    case PT_TOP_RIGHT: {\n      pt.x = widget->w - win->x_offset;\n      pt.y = win->y_offset;\n      break;\n    };\n    case PT_BOTTOM_RIGHT: {\n      pt.x = widget->w - win->x_offset;\n      pt.y = widget->h - win->y_offset;\n      break;\n    };\n    case PT_BOTTOM_LEFT: {\n      pt.x = win->x_offset;\n      pt.y = widget->h - win->y_offset;\n      break;\n    };\n    case PT_CENTER: {\n      pt.x = widget->w >> 1;\n      pt.y = widget->h >> 1;\n      break;\n    };\n  }\n\n  return pt;\n}",
            "key_variables": [
               [
                  34,
                  "win->x_offset"
               ],
               [
                  35,
                  "win->y_offset"
               ],
               [
                  39,
                  "win->x_offset"
               ],
               [
                  40,
                  "win->y_offset"
               ],
               [
                  44,
                  "win->x_offset"
               ],
               [
                  45,
                  "win->y_offset"
               ],
               [
                  49,
                  "win->x_offset"
               ],
               [
                  50,
                  "win->y_offset"
               ]
            ]
         },
         {
            "type": "func",
            "name": "calibration_win_invalidate",
            "line_range": [
               62,
               76
            ],
            "source_code": "static ret_t calibration_win_invalidate(widget_t* widget, uint32_t point_name) {\n  calibration_win_t* win = CALIBRATION_WIN(widget);\n  return_value_if_fail(win != NULL && widget != NULL, RET_BAD_PARAMS);\n\n  if (point_name < PT_MAX_NR) {\n    uint32_t cross_size = win->cross_size;\n    point_t pt = calibration_win_get_current_point(widget, point_name);\n    rect_t r = rect_init(pt.x - cross_size / 2, pt.y - cross_size / 2, cross_size, cross_size);\n\n    widget->dirty = FALSE;\n    widget_invalidate(widget, &r);\n  }\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  68,
                  "win->cross_size"
               ]
            ]
         },
         {
            "type": "func",
            "name": "calibration_win_on_event",
            "line_range": [
               78,
               137
            ],
            "source_code": "static ret_t calibration_win_on_event(widget_t* widget, event_t* e) {\n  uint16_t type = e->type;\n  calibration_win_t* win = CALIBRATION_WIN(widget);\n  return_value_if_fail(widget != NULL && win != NULL, RET_BAD_PARAMS);\n\n  if (win->cursor == PT_MAX_NR) {\n    return RET_OK;\n  }\n\n  switch (type) {\n    case EVT_WINDOW_OPEN: {\n      widget_grab(widget->parent, widget);\n      return RET_OK;\n    }\n    case EVT_WINDOW_CLOSE: {\n      widget_ungrab(widget->parent, widget);\n      return RET_OK;\n    }\n    case EVT_POINTER_UP: {\n      point_t* p = win->points + win->cursor;\n      pointer_event_t* evt = (pointer_event_t*)e;\n\n      p->x = evt->x;\n      p->y = evt->y;\n\n      if (win->on_click != NULL) {\n        win->on_click(win->on_click_ctx, win->cursor, *p);\n      }\n      log_debug(\"click: %d {%d, %d}\\n\", win->cursor, p->x, p->y);\n\n      calibration_win_invalidate(widget, win->cursor);\n      win->cursor++;\n      calibration_win_invalidate(widget, win->cursor);\n\n      if (win->cursor == PT_MAX_NR) {\n        if (win->on_done != NULL) {\n          if (win->on_done(win->on_done_ctx, win->points) == RET_OK) {\n            window_close_force(widget);\n          } else {\n            win->cursor = 0;\n          }\n        } else {\n          window_close_force(widget);\n        }\n#if 0        \n        p = win->points;\n        log_debug(\"lt:{%d,%d} lr:{%d,%d} br:{%d,%d} bl:{%d,%d} center:{%d,%d}\\n\", p[PT_TOP_LEFT].x,\n                  p[PT_TOP_LEFT].y, p[PT_TOP_RIGHT].x, p[PT_TOP_RIGHT].y, p[PT_BOTTOM_RIGHT].x,\n                  p[PT_BOTTOM_RIGHT].y, p[PT_BOTTOM_LEFT].x, p[PT_BOTTOM_LEFT].y, p[PT_CENTER].x,\n                  p[PT_CENTER].y);\n#endif\n      }\n      break;\n    }\n    default:\n      break;\n  }\n\n  return window_base_on_event(widget, e);\n}",
            "key_variables": [
               [
                  80,
                  "e->type"
               ],
               [
                  98,
                  "win->cursor"
               ],
               [
                  101,
                  "evt->x"
               ],
               [
                  102,
                  "evt->y"
               ],
               [
                  124,
                  "win->points"
               ],
               [
                  143,
                  "widget->astyle"
               ]
            ]
         }
      ],
      "src/widgets/check_button.c": [
         {
            "type": "func",
            "name": "check_button_on_event",
            "line_range": [
               29,
               78
            ],
            "source_code": "static ret_t check_button_on_event(widget_t* widget, event_t* e) {\n  uint16_t type = e->type;\n  check_button_t* check_button = CHECK_BUTTON(widget);\n  return_value_if_fail(check_button != NULL, RET_BAD_PARAMS);\n\n  switch (type) {\n    case EVT_POINTER_DOWN: {\n      check_button->pressed = TRUE;\n      widget_set_state(widget, WIDGET_STATE_PRESSED);\n      widget_grab(widget->parent, widget);\n      break;\n    }\n    case EVT_POINTER_DOWN_ABORT: {\n      check_button->pressed = FALSE;\n      widget_ungrab(widget->parent, widget);\n      widget_set_state(widget, WIDGET_STATE_NORMAL);\n      break;\n    }\n    case EVT_CLICK: {\n      if (check_button->radio) {\n        check_button_set_value(widget, TRUE);\n      } else {\n        check_button_set_value(widget, !(check_button->value));\n      }\n      break;\n    }\n    case EVT_POINTER_UP: {\n      pointer_event_t* evt = (pointer_event_t*)e;\n      if (check_button->pressed && widget_is_point_in(widget, evt->x, evt->y, FALSE)) {\n        pointer_event_t click;\n        widget_dispatch(widget, pointer_event_init(&click, EVT_CLICK, widget, evt->x, evt->y));\n      }\n\n      check_button->pressed = FALSE;\n      widget_ungrab(widget->parent, widget);\n      widget_set_state(widget, WIDGET_STATE_NORMAL);\n      break;\n    }\n    case EVT_POINTER_LEAVE:\n      widget_set_state(widget, WIDGET_STATE_NORMAL);\n      break;\n    case EVT_POINTER_ENTER:\n      widget_set_state(widget, WIDGET_STATE_OVER);\n      break;\n    default:\n      break;\n  }\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  31,
                  "e->type"
               ]
            ]
         },
         {
            "type": "func",
            "name": "check_button_set_value_only",
            "line_range": [
               84,
               104
            ],
            "source_code": "static ret_t check_button_set_value_only(widget_t* widget, bool_t value) {\n  check_button_t* check_button = CHECK_BUTTON(widget);\n  return_value_if_fail(check_button != NULL, RET_BAD_PARAMS);\n\n  if (check_button->value != value) {\n    value_change_event_t evt;\n    value_change_event_init(&evt, EVT_VALUE_WILL_CHANGE, widget);\n    value_set_uint32(&(evt.old_value), check_button->value);\n    value_set_uint32(&(evt.new_value), value);\n\n    if (widget_dispatch(widget, (event_t*)&evt) != RET_STOP) {\n      check_button->value = value;\n      evt.e.type = EVT_VALUE_CHANGED;\n      widget_dispatch(widget, (event_t*)&evt);\n      widget_set_need_update_style(widget);\n      widget_invalidate_force(widget, NULL);\n    }\n  }\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  112,
                  "widget->parent"
               ]
            ]
         },
         {
            "type": "func",
            "name": "check_button_set_radio",
            "line_range": [
               209,
               222
            ],
            "source_code": "static ret_t check_button_set_radio(widget_t* widget, bool_t radio) {\n  check_button_t* check_button = CHECK_BUTTON(widget);\n  return_value_if_fail(check_button != NULL, RET_BAD_PARAMS);\n  check_button->radio = radio;\n  if (radio) {\n    widget->vt = TK_REF_VTABLE(radio_button);\n  } else {\n    widget->vt = TK_REF_VTABLE(check_button);\n  }\n  widget_set_need_update_style(widget);\n  widget_invalidate_force(widget, NULL);\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  238,
                  "widget->parent"
               ]
            ]
         }
      ],
      "src/widgets/color_tile.c": [
         {
            "type": "func",
            "name": "color_tile_on_paint_stroke",
            "line_range": [
               26,
               68
            ],
            "source_code": "static ret_t color_tile_on_paint_stroke(widget_t* widget, canvas_t* c) {\n  rect_t r;\n  color_t bd;\n  ret_t ret = RET_FAIL;\n  style_t* style = NULL;\n  int32_t border, border_width;\n  color_tile_t* color_tile = COLOR_TILE(widget);\n  uint32_t radius, radius_tl, radius_tr, radius_bl, radius_br;\n  return_value_if_fail(color_tile != NULL, RET_BAD_PARAMS);\n\n  style = widget->astyle;\n  r = rect_init(0, 0, widget->w, widget->h);\n\n  if (color_tile->border.rgba.a == 0) {\n    bd = style_get_color(style, STYLE_ID_BORDER_COLOR, color_tile->border);\n    if (bd.rgba.a == 0) {\n      return RET_OK;\n    }\n  } else {\n    bd = color_tile->border;\n  }\n\n  border = style_get_int(style, STYLE_ID_BORDER, BORDER_ALL);\n  border_width = style_get_int(style, STYLE_ID_BORDER_WIDTH, 1);\n\n  radius = style_get_int(style, STYLE_ID_ROUND_RADIUS, 0);\n  radius_tl = style_get_int(style, STYLE_ID_ROUND_RADIUS_TOP_LETF, radius);\n  radius_tr = style_get_int(style, STYLE_ID_ROUND_RADIUS_TOP_RIGHT, radius);\n  radius_bl = style_get_int(style, STYLE_ID_ROUND_RADIUS_BOTTOM_LETF, radius);\n  radius_br = style_get_int(style, STYLE_ID_ROUND_RADIUS_BOTTOM_RIGHT, radius);\n\n  canvas_set_stroke_color(c, bd);\n  if (radius_tl > 3 || radius_tr > 3 || radius_bl > 3 || radius_br > 3) {\n    if (canvas_stroke_rounded_rect_ex(c, &r, NULL, &bd, radius_tl, radius_tr, radius_bl, radius_br,\n                                      border_width, border) != RET_OK) {\n      widget_stroke_border_rect_for_border_type(c, &r, bd, border, border_width);\n    }\n  } else {\n    widget_stroke_border_rect_for_border_type(c, &r, bd, border, border_width);\n  }\n\n  return ret;\n}",
            "key_variables": [
               [
                  37,
                  "widget->astyle"
               ],
               [
                  46,
                  "color_tile->border"
               ]
            ]
         },
         {
            "type": "func",
            "name": "color_tile_on_paint_fill",
            "line_range": [
               70,
               106
            ],
            "source_code": "static ret_t color_tile_on_paint_fill(widget_t* widget, canvas_t* c) {\n  rect_t r;\n  color_t color;\n  ret_t ret = RET_FAIL;\n  style_t* style = NULL;\n  color_tile_t* color_tile = COLOR_TILE(widget);\n  uint32_t radius, radius_tl, radius_tr, radius_bl, radius_br;\n  return_value_if_fail(color_tile != NULL && widget != NULL, RET_BAD_PARAMS);\n\n  style = widget->astyle;\n  r = rect_init(0, 0, widget->w, widget->h);\n  if (color_tile->bg.rgba.a == 0) {\n    color = style_get_color(style, STYLE_ID_BG_COLOR, color_tile->bg);\n    if (color.rgba.a == 0) {\n      return RET_OK;\n    }\n  } else {\n    color = color_tile->bg;\n  }\n\n  radius = style_get_int(style, STYLE_ID_ROUND_RADIUS, 0);\n  radius_tl = style_get_int(style, STYLE_ID_ROUND_RADIUS_TOP_LETF, radius);\n  radius_tr = style_get_int(style, STYLE_ID_ROUND_RADIUS_TOP_RIGHT, radius);\n  radius_bl = style_get_int(style, STYLE_ID_ROUND_RADIUS_BOTTOM_LETF, radius);\n  radius_br = style_get_int(style, STYLE_ID_ROUND_RADIUS_BOTTOM_RIGHT, radius);\n\n  canvas_set_fill_color(c, color);\n  if (radius_tl > 3 || radius_tr > 3 || radius_bl > 3 || radius_br > 3) {\n    ret = canvas_fill_rounded_rect_ex(c, &r, NULL, &color, radius_tl, radius_tr, radius_bl,\n                                      radius_br);\n  }\n  if (ret == RET_FAIL) {\n    ret = canvas_fill_rect(c, r.x, r.y, r.w, r.h);\n  }\n\n  return ret;\n}",
            "key_variables": [
               [
                  80,
                  "widget->astyle"
               ],
               [
                  88,
                  "color_tile->bg"
               ]
            ]
         },
         {
            "type": "func",
            "name": "color_tile_set_border_color",
            "line_range": [
               184,
               194
            ],
            "source_code": "ret_t color_tile_set_border_color(widget_t* widget, const char* color) {\n  color_tile_t* color_tile = COLOR_TILE(widget);\n  return_value_if_fail(color_tile != NULL && color != NULL, RET_BAD_PARAMS);\n\n  color_tile->border = color_parse(color);\n  color_hex_str(color_tile->border, color_tile->border_color);\n\n  widget_invalidate(widget, NULL);\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  223,
                  "color_tile->bg_color"
               ]
            ]
         },
         {
            "type": "func",
            "name": "color_tile_set_value",
            "line_range": [
               196,
               216
            ],
            "source_code": "ret_t color_tile_set_value(widget_t* widget, color_t color) {\n  color_tile_t* color_tile = COLOR_TILE(widget);\n  return_value_if_fail(color_tile != NULL, RET_BAD_PARAMS);\n\n  if (color_tile->bg.color != color.color) {\n    value_change_event_t evt;\n    value_change_event_init(&evt, EVT_VALUE_WILL_CHANGE, widget);\n    value_set_uint32(&(evt.old_value), color_tile->bg.color);\n    value_set_uint32(&(evt.new_value), color.color);\n\n    if (widget_dispatch(widget, (event_t*)&evt) != RET_STOP) {\n      color_tile->bg = color;\n      color_hex_str(color_tile->bg, color_tile->bg_color);\n      evt.e.type = EVT_VALUE_CHANGED;\n      widget_dispatch(widget, (event_t*)&evt);\n      widget_invalidate(widget, NULL);\n    }\n  }\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  230,
                  "color_tile->border_color"
               ]
            ]
         }
      ],
      "src/widgets/combo_box.c": [
         {
            "type": "block",
            "name": "block",
            "line_range": "",
            "source_code": "",
            "key_variables": [
               68,
               "combo_box_other->item_height"
            ]
         },
         {
            "type": "block",
            "name": "block",
            "line_range": "",
            "source_code": "",
            "key_variables": [
               69,
               "combo_box_other->selected_index"
            ]
         },
         {
            "type": "block",
            "name": "block",
            "line_range": "",
            "source_code": "",
            "key_variables": [
               70,
               "combo_box_other->localize_options"
            ]
         },
         {
            "type": "func",
            "name": "combo_box_set_text",
            "line_range": [
               202,
               246
            ],
            "source_code": "static ret_t combo_box_set_text(widget_t* widget, const char* text, const wchar_t* wtext,\n\n                                bool_t tr) {\n\n  widget_t* value_widget = widget_lookup(widget, WIDGET_NAME_VALUE, TRUE);\n\n\n\n  if (value_widget == NULL) {\n\n    value_widget = widget;\n\n  } else {\n\n    TKMEM_FREE(widget->tr_text);\n\n    widget_set_text(widget, L\"\");\n\n  }\n\n\n\n  if (tr) {\n\n    widget_set_tr_text(value_widget, text);\n\n  } else {\n\n    if (wtext != NULL) {\n\n      widget_set_text(value_widget, wtext);\n\n    } else {\n\n      widget_set_text_utf8(value_widget, text);\n\n    }\n\n  }\n\n\n\n  return RET_OK;\n\n}",
            "key_variables": [
               [
                  221,
                  "combo_box->item_height"
               ],
               [
                  225,
                  "combobox_popup->h"
               ],
               [
                  229,
                  "widget->h"
               ],
               [
                  231,
                  "combobox_popup->h"
               ]
            ]
         },
         {
            "type": "func",
            "name": "combo_box_get_prop",
            "line_range": [
               250,
               300
            ],
            "source_code": "static ret_t combo_box_get_prop(widget_t* widget, const char* name, value_t* v) {\n\n  combo_box_t* combo_box = COMBO_BOX(widget);\n\n  return_value_if_fail(widget != NULL && combo_box != NULL, RET_BAD_PARAMS);\n\n\n\n  if (tk_str_eq(name, WIDGET_PROP_OPEN_WINDOW)) {\n\n    value_set_str(v, combo_box->open_window);\n\n    return RET_OK;\n\n  } else if (tk_str_eq(name, WIDGET_PROP_SELECTED_INDEX)) {\n\n    value_set_int(v, combo_box->selected_index);\n\n    return RET_OK;\n\n  } else if (tk_str_eq(name, WIDGET_PROP_VALUE)) {\n\n    value_set_int(v, combo_box->value);\n\n    return RET_OK;\n\n  } else if (tk_str_eq(name, WIDGET_PROP_LOCALIZE_OPTIONS)) {\n\n    value_set_bool(v, combo_box->localize_options);\n\n    return RET_OK;\n\n  } else if (tk_str_eq(name, WIDGET_PROP_OPTIONS)) {\n\n    value_set_str(v, combo_box->options);\n\n    return RET_OK;\n\n  } else if (tk_str_eq(name, WIDGET_PROP_ITEM_HEIGHT)) {\n\n    value_set_int(v, combo_box->item_height);\n\n    return RET_OK;\n\n  } else {\n\n    return edit_get_prop(widget, name, v);\n\n  }\n\n}",
            "key_variables": [
               [
                  328,
                  "widget->h"
               ]
            ]
         },
         {
            "type": "func",
            "name": "combo_box_set_prop",
            "line_range": [
               378,
               422
            ],
            "source_code": "static ret_t combo_box_set_prop(widget_t* widget, const char* name, const value_t* v) {\n\n  if (tk_str_eq(name, WIDGET_PROP_OPEN_WINDOW)) {\n\n    combo_box_set_open_window(widget, value_str(v));\n\n    return RET_OK;\n\n  } else if (tk_str_eq(name, WIDGET_PROP_SELECTED_INDEX)) {\n\n    combo_box_set_selected_index(widget, value_int(v));\n\n    return RET_OK;\n\n  } else if (tk_str_eq(name, WIDGET_PROP_VALUE)) {\n\n    combo_box_set_value(widget, value_int(v));\n\n    return RET_OK;\n\n  } else if (tk_str_eq(name, WIDGET_PROP_LOCALIZE_OPTIONS)) {\n\n    combo_box_set_localize_options(widget, value_bool(v));\n\n    return RET_OK;\n\n  } else if (tk_str_eq(name, WIDGET_PROP_OPTIONS)) {\n\n    combo_box_parse_options(widget, value_str(v));\n\n    return RET_OK;\n\n  } else if (tk_str_eq(name, WIDGET_PROP_ITEM_HEIGHT)) {\n\n    combo_box_set_item_height(widget, value_uint32(v));\n\n    return RET_OK;\n\n  } else {\n\n    return edit_set_prop(widget, name, v);\n\n  }\n\n}",
            "key_variables": [
               [
                  456,
                  "combo_box->option_items"
               ],
               [
                  467,
                  "iter->next"
               ]
            ]
         },
         {
            "type": "func",
            "name": "combo_box_on_layout_children_for_combobox_popup",
            "line_range": [
               426,
               476
            ],
            "source_code": "static ret_t combo_box_on_layout_children_for_combobox_popup(widget_t* widget) {\n\n  combo_box_t* combo_box = COMBO_BOX(widget);\n\n  return_value_if_fail(combo_box != NULL, RET_BAD_PARAMS);\n\n\n\n  if (combo_box->combobox_popup != NULL) {\n\n    point_t p = {0, 0};\n\n    int32_t margin = COMBO_BOX_DEFAULT_MARGIN;\n\n    int32_t item_height = combo_box->item_height;\n\n    int32_t nr = combo_box_count_options(widget);\n\n    int32_t h = nr * item_height + 2 * margin;\n\n    if (combo_box->open_window != NULL) {\n\n      h = combo_box->combobox_popup->h;\n\n    }\n\n    widget_to_screen(widget, &p);\n\n    if ((p.y + widget->h + h) < combo_box->combobox_popup->parent->h) {\n\n      p.y += widget->h;\n\n    } else if (p.y >= h) {\n\n      p.y -= combo_box->combobox_popup->h;\n\n    } else {\n\n      p.y = 0;\n\n    }\n\n\n\n    widget_move_resize(combo_box->combobox_popup, p.x, p.y, widget->w, h);\n\n  }\n\n  return RET_OK;\n\n}",
            "key_variables": [
               [
                  487,
                  "params[128]"
               ],
               [
                  493,
                  "combo_box->item_height"
               ],
               [
                  495,
                  "widget->w"
               ],
               [
                  548,
                  "win->parent"
               ],
               [
                  550,
                  "widget->h"
               ],
               [
                  552,
                  "win->h"
               ]
            ]
         },
         {
            "type": "func",
            "name": "combo_box_on_key_event",
            "line_range": [
               556,
               608
            ],
            "source_code": "static ret_t combo_box_on_key_event(widget_t* widget, key_event_t* evt) {\n\n  ret_t ret = RET_OK;\n\n  edit_t* edit = EDIT(WIDGET(widget));\n\n  return_value_if_fail(edit != NULL, RET_BAD_PARAMS);\n\n\n\n  if (evt->key == TK_KEY_UP) {\n\n    ret = RET_STOP;\n\n    if (evt->e.type == EVT_KEY_DOWN) {\n\n      combo_box_add_selected_index(widget, -1);\n\n    }\n\n  } else if (evt->key == TK_KEY_DOWN) {\n\n    ret = RET_STOP;\n\n    if (evt->e.type == EVT_KEY_DOWN) {\n\n      combo_box_add_selected_index(widget, 1);\n\n    }\n\n  } else if (widget_is_activate_key(widget, evt) && evt->e.type == EVT_KEY_UP) {\n\n    if (edit->readonly) {\n\n      ret = RET_STOP;\n\n      combo_box_active(widget);\n\n    } else if (key_code_is_enter(evt->key)) {\n\n      ret = RET_STOP;\n\n      combo_box_active(widget);\n\n    }\n\n  }\n\n\n\n  return ret;\n\n}",
            "key_variables": [
               [
                  585,
                  "combo_box->option_items"
               ],
               [
                  586,
                  "combo_box->option_items"
               ],
               [
                  591,
                  "iter->next"
               ],
               [
                  593,
                  "iter->next"
               ],
               [
                  601,
                  "iter->next"
               ],
               [
                  613,
                  "combo_box->option_items"
               ],
               [
                  615,
                  "iter->next"
               ],
               [
                  654,
                  "combo_box->option_items"
               ],
               [
                  655,
                  "iter->next"
               ],
               [
                  670,
                  "combo_box->option_items"
               ],
               [
                  673,
                  "iter->next"
               ],
               [
                  685,
                  "combo_box->option_items"
               ],
               [
                  692,
                  "iter->next"
               ],
               [
                  704,
                  "combo_box->option_items"
               ],
               [
                  711,
                  "iter->next"
               ]
            ]
         },
         {
            "type": "func",
            "name": "edit_get_right_margin",
            "line_range": [
               522,
               552
            ],
            "source_code": "static uint32_t edit_get_right_margin(widget_t* widget) {\n\n  int32_t right_margin = 0;\n\n  style_t* style = widget != NULL ? widget->astyle : NULL;\n\n\n\n  right_margin = widget_get_prop_int(widget, WIDGET_PROP_RIGHT_MARGIN, 0);\n\n\n\n  if (right_margin == 0) {\n\n    right_margin = style_get_int(style, STYLE_ID_MARGIN_RIGHT, 0);\n\n  }\n\n\n\n  if (right_margin == 0) {\n\n    right_margin = style_get_int(style, STYLE_ID_MARGIN, 0);\n\n  }\n\n\n\n  return right_margin;\n\n}",
            "key_variables": [
               [
                  725,
                  "option->value"
               ]
            ]
         },
         {
            "type": "func",
            "name": "combo_box_on_add_child",
            "line_range": [
               728,
               752
            ],
            "source_code": "static ret_t combo_box_on_add_child(widget_t* widget, widget_t* child) {\n\n  if (tk_str_eq(widget_get_type(child), WIDGET_TYPE_BUTTON)) {\n\n    widget_t* button = widget_lookup_by_type(widget, WIDGET_TYPE_BUTTON, TRUE);\n\n\n\n    if (button != NULL && button != child) {\n\n      widget_destroy(button);\n\n    }\n\n\n\n    widget_on(child, EVT_CLICK, combo_box_on_button_click, widget);\n\n  }\n\n\n\n  return RET_FAIL;\n\n}",
            "key_variables": [
               [
                  799,
                  "combo_box->value"
               ],
               [
                  825,
                  "widget->tr_text"
               ]
            ]
         }
      ],
      "src/widgets/combo_box_item.c": [
         {
            "type": "func",
            "name": "combo_box_item_on_event",
            "line_range": [
               28,
               69
            ],
            "source_code": "static ret_t combo_box_item_on_event(widget_t* widget, event_t* e) {\n  uint16_t type = e->type;\n  combo_box_item_t* combo_box_item = COMBO_BOX_ITEM(widget);\n  return_value_if_fail(combo_box_item != NULL, RET_BAD_PARAMS);\n\n  switch (type) {\n    case EVT_POINTER_DOWN: {\n      combo_box_item->pressed = TRUE;\n      widget_set_state(widget, WIDGET_STATE_PRESSED);\n      break;\n    }\n    case EVT_POINTER_DOWN_ABORT: {\n      combo_box_item->pressed = FALSE;\n      widget_set_state(widget, WIDGET_STATE_NORMAL);\n      break;\n    }\n    case EVT_POINTER_UP: {\n      pointer_event_t evt = *(pointer_event_t*)e;\n      if (combo_box_item->pressed) {\n        evt.e = event_init(EVT_CLICK, widget);\n        evt.e.size = sizeof(pointer_event_t);\n        combo_box_item_set_checked(widget, TRUE);\n        widget_dispatch(widget, (event_t*)&evt);\n      }\n\n      combo_box_item->pressed = FALSE;\n      widget_set_state(widget, WIDGET_STATE_NORMAL);\n      break;\n    }\n    case EVT_POINTER_LEAVE:\n      combo_box_item->pressed = FALSE;\n      widget_set_state(widget, WIDGET_STATE_NORMAL);\n      break;\n    case EVT_POINTER_ENTER:\n      widget_set_state(widget, WIDGET_STATE_OVER);\n      break;\n    default:\n      break;\n  }\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  30,
                  "e->type"
               ]
            ]
         },
         {
            "type": "func",
            "name": "combo_box_item_set_checked_only",
            "line_range": [
               126,
               147
            ],
            "source_code": "static ret_t combo_box_item_set_checked_only(widget_t* widget, bool_t checked) {\n  combo_box_item_t* combo_box_item = COMBO_BOX_ITEM(widget);\n  return_value_if_fail(combo_box_item != NULL, RET_BAD_PARAMS);\n\n  if (combo_box_item->checked != checked) {\n    value_change_event_t evt;\n    value_change_event_init(&evt, EVT_VALUE_WILL_CHANGE, widget);\n    value_set_bool(&(evt.old_value), combo_box_item->checked);\n    value_set_bool(&(evt.new_value), checked);\n\n    if (widget_dispatch(widget, (event_t*)&evt) != RET_STOP) {\n      combo_box_item->checked = checked;\n      evt.e.type = EVT_VALUE_CHANGED;\n      widget_dispatch(widget, (event_t*)&evt);\n      widget_invalidate(widget, NULL);\n    }\n  }\n\n  widget_set_need_update_style(widget);\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  155,
                  "widget->parent"
               ]
            ]
         }
      ],
      "src/widgets/dragger.c": [
         {
            "type": "func",
            "name": "dragger_on_event",
            "line_range": [
               52,
               117
            ],
            "source_code": "static ret_t dragger_on_event(widget_t* widget, event_t* e) {\n  uint16_t type = e->type;\n  dragger_t* dragger = DRAGGER(widget);\n  return_value_if_fail(dragger != NULL, RET_BAD_PARAMS);\n\n  switch (type) {\n    case EVT_POINTER_DOWN: {\n      pointer_event_t* pointer_event = (pointer_event_t*)e;\n      event_t evt = event_init(EVT_DRAG_START, widget);\n      widget_set_state(widget, WIDGET_STATE_PRESSED);\n      widget_dispatch(widget, (event_t*)&evt);\n      widget_grab(widget->parent, widget);\n\n      dragger->down_x = pointer_event->x;\n      dragger->down_y = pointer_event->y;\n      dragger->save_x = widget->x;\n      dragger->save_y = widget->y;\n      dragger_move(widget, 0, 0);\n      dragger->dragging = TRUE;\n      break;\n    }\n    case EVT_POINTER_DOWN_ABORT: {\n      event_t evt = event_init(EVT_DRAG_END, widget);\n      dragger_move(widget, 0, 0);\n      widget_set_state(widget, WIDGET_STATE_NORMAL);\n      widget_dispatch(widget, (event_t*)&evt);\n      widget_ungrab(widget->parent, widget);\n      dragger->dragging = FALSE;\n      dragger->moving = FALSE;\n      break;\n    }\n    case EVT_POINTER_UP: {\n      pointer_event_t* pointer_event = (pointer_event_t*)e;\n      event_t evt = event_init(EVT_DRAG_END, widget);\n      if (dragger->moving) {\n        dragger_move(widget, pointer_event->x - dragger->down_x,\n                     pointer_event->y - dragger->down_y);\n      }\n      widget_set_state(widget, WIDGET_STATE_NORMAL);\n      widget_dispatch(widget, (event_t*)&evt);\n      widget_ungrab(widget->parent, widget);\n      dragger->dragging = FALSE;\n      dragger->moving = FALSE;\n      break;\n    }\n    case EVT_POINTER_MOVE: {\n      if (dragger->dragging) {\n        pointer_event_t* pointer_event = (pointer_event_t*)e;\n        dragger_move(widget, pointer_event->x - dragger->down_x,\n                     pointer_event->y - dragger->down_y);\n        dragger->moving = TRUE;\n      }\n      return RET_STOP;\n    }\n    case EVT_POINTER_LEAVE:\n      widget_set_state(widget, WIDGET_STATE_NORMAL);\n      break;\n    case EVT_POINTER_ENTER:\n      widget_set_state(widget, WIDGET_STATE_OVER);\n      break;\n    default:\n      break;\n  }\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  54,
                  "e->type"
               ],
               [
                  66,
                  "pointer_event->x"
               ],
               [
                  67,
                  "pointer_event->y"
               ],
               [
                  68,
                  "widget->x"
               ],
               [
                  69,
                  "widget->y"
               ]
            ]
         }
      ],
      "src/widgets/edit.c": [
         {
            "type": "func",
            "name": "edit_do_input_char",
            "line_range": [
               135,
               137
            ],
            "source_code": "static ret_t edit_do_input_char(widget_t* widget, wchar_t c) {\n  return text_edit_paste(EDIT(widget)->model, &c, 1);\n}",
            "key_variables": [
               [
                  163,
                  "edit->input_type"
               ]
            ]
         },
         {
            "type": "func",
            "name": "edit_commit_str",
            "line_range": [
               305,
               316
            ],
            "source_code": "static ret_t edit_commit_str(widget_t* widget, const char* str) {\n  uint32_t i = 0;\n  wchar_t wstr[32];\n  tk_utf8_to_utf16(str, wstr, ARRAY_SIZE(wstr));\n\n  while (wstr[i]) {\n    edit_input_char(widget, wstr[i]);\n    i++;\n  }\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  308,
                  "wstr[32]"
               ],
               [
                  324,
                  "edit->input_type"
               ]
            ]
         },
         {
            "type": "func",
            "name": "edit_is_size_valid",
            "line_range": [
               329,
               340
            ],
            "source_code": "static bool_t edit_is_size_valid(widget_t* widget) {\n  edit_t* edit = EDIT(widget);\n  uint32_t size = widget->text.size;\n  uint32_t min = (uint32_t)(edit->min);\n  uint32_t max = (uint32_t)(edit->max);\n\n  if (min == max && min == 0) {\n    return TRUE;\n  }\n\n  return (min <= size && size <= max);\n}",
            "key_variables": [
               [
                  398,
                  "edit->min"
               ],
               [
                  399,
                  "edit->max"
               ],
               [
                  428,
                  "text->size"
               ],
               [
                  429,
                  "edit->max"
               ],
               [
                  458,
                  "edit->min"
               ],
               [
                  459,
                  "edit->max"
               ]
            ]
         },
         {
            "type": "func",
            "name": "edit_pre_input",
            "line_range": [
               593,
               601
            ],
            "source_code": "static ret_t edit_pre_input(widget_t* widget, uint32_t key) {\n  edit_t* edit = EDIT(widget);\n  return_value_if_fail(edit != NULL, RET_BAD_PARAMS);\n  if (edit->pre_input != NULL) {\n    return edit->pre_input(widget, key);\n  }\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  605,
                  "e->key"
               ]
            ]
         },
         {
            "type": "func",
            "name": "edit_on_key_down",
            "line_range": [
               603,
               679
            ],
            "source_code": "static ret_t edit_on_key_down(widget_t* widget, key_event_t* e) {\n  uint32_t key = e->key;\n  edit_t* edit = EDIT(widget);\n  return_value_if_fail(edit != NULL, RET_BAD_PARAMS);\n\n  if (!e->cmd && !e->ctrl) {\n    if (edit_pre_input(widget, key) == RET_STOP) {\n      return RET_STOP;\n    }\n  }\n\n  if (key == TK_KEY_TAB || key == TK_KEY_ESCAPE || (key >= TK_KEY_F1 && key <= TK_KEY_F12)) {\n    return RET_OK;\n  } else if (key == TK_KEY_LEFT || key == TK_KEY_RIGHT) {\n    uint32_t cursor = text_edit_get_cursor(edit->model);\n    if (key == TK_KEY_LEFT && cursor == 0) {\n      return RET_STOP;\n    }\n\n    if (key == TK_KEY_RIGHT && cursor == widget->text.size) {\n      return RET_STOP;\n    }\n  } else if (key == TK_KEY_DOWN) {\n    if (widget_is_change_focus_key(widget, e)) {\n      return RET_OK;\n    }\n\n    if (edit_is_number(widget) || edit->inc_value != NULL) {\n      edit_dec(edit);\n    } else {\n      widget_focus_next(widget);\n    }\n    return RET_STOP;\n  } else if (key == TK_KEY_UP) {\n    if (widget_is_change_focus_key(widget, e)) {\n      return RET_OK;\n    }\n\n    if (edit_is_number(widget) || edit->inc_value != NULL) {\n      edit_inc(edit);\n    } else {\n      widget_focus_prev(widget);\n    }\n    return RET_STOP;\n  }\n\n  if (key == TK_KEY_BACKSPACE || key == TK_KEY_DELETE || key == TK_KEY_LEFT ||\n      key == TK_KEY_RIGHT || key == TK_KEY_HOME || key == TK_KEY_END ||\n      ((e->ctrl || e->cmd) &&\n       (key == TK_KEY_a || key == TK_KEY_y || key == TK_KEY_z || key == TK_KEY_v ||\n        key == TK_KEY_x || key == TK_KEY_c || key == TK_KEY_A || key == TK_KEY_Y ||\n        key == TK_KEY_Z || key == TK_KEY_V || key == TK_KEY_X || key == TK_KEY_C))) {\n    if (key == TK_KEY_v || key == TK_KEY_V) {\n      edit_paste(widget);\n    } else {\n      text_edit_key_down(edit->model, (key_event_t*)e);\n    }\n\n    if (key != TK_KEY_LEFT && key != TK_KEY_RIGHT && key != TK_KEY_HOME && key != TK_KEY_END) {\n      edit_dispatch_value_change_event(widget, EVT_VALUE_CHANGING);\n    }\n  } else if (key < 128 && tk_isprint(key)) {\n    if (!input_method_is_native(input_method())) {\n      edit_input_char(widget, (wchar_t)key);\n    }\n  } else {\n    if (widget->emitter != NULL) {\n      void* saved_target = e->e.target;\n\n      e->e.target = widget;\n      emitter_dispatch(widget->emitter, (event_t*)e);\n      e->e.target = saved_target;\n    }\n  }\n\n  return RET_STOP;\n}",
            "key_variables": [
               [
                  683,
                  "e->key"
               ]
            ]
         },
         {
            "type": "func",
            "name": "edit_check_valid_value",
            "line_range": [
               711,
               722
            ],
            "source_code": "static ret_t edit_check_valid_value(widget_t* widget) {\n  edit_t* edit = EDIT(widget);\n  return_value_if_fail(widget != NULL && edit != NULL, RET_BAD_PARAMS);\n  if (!edit_is_valid_value(widget)) {\n    if (edit->auto_fix) {\n      edit_auto_fix(widget);\n    } else if (widget->text.size > 0) {\n      widget_set_state(widget, WIDGET_STATE_ERROR);\n    }\n  }\n  return RET_OK;\n}",
            "key_variables": [
               [
                  727,
                  "e->type"
               ],
               [
                  755,
                  "e->time"
               ],
               [
                  771,
                  "e->time"
               ],
               [
                  780,
                  "e->time"
               ],
               [
                  784,
                  "e->time"
               ],
               [
                  790,
                  "e->time"
               ],
               [
                  800,
                  "e->time"
               ],
               [
                  847,
                  "evt->dy"
               ],
               [
                  854,
                  "e->time"
               ]
            ]
         },
         {
            "type": "func",
            "name": "edit_set_keyboard",
            "line_range": [
               1101,
               1108
            ],
            "source_code": "ret_t edit_set_keyboard(widget_t* widget, const char* keyboard) {\n  edit_t* edit = EDIT(widget);\n  return_value_if_fail(edit != NULL && keyboard != NULL, RET_BAD_PARAMS);\n\n  edit->keyboard = tk_str_copy(edit->keyboard, keyboard);\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  1116,
                  "edit->input_type"
               ]
            ]
         },
         {
            "type": "func",
            "name": "widget_has_uint_min_max",
            "line_range": [
               1110,
               1119
            ],
            "source_code": "static bool_t widget_has_uint_min_max(widget_t* widget) {\n  edit_t* edit = EDIT(widget);\n  input_type_t input_type = INPUT_TEXT;\n  return_value_if_fail(edit != NULL, FALSE);\n\n  input_type = edit->input_type;\n\n  return input_type == INPUT_TEXT || input_type == INPUT_ASCII || input_type == INPUT_PASSWORD ||\n         input_type == INPUT_EMAIL || input_type == INPUT_UINT;\n}",
            "key_variables": [
               [
                  1127,
                  "edit->input_type"
               ],
               [
                  1187,
                  "edit->margin"
               ],
               [
                  1197,
                  "edit->margin"
               ],
               [
                  1207,
                  "edit->margin"
               ],
               [
                  1217,
                  "edit->margin"
               ],
               [
                  1275,
                  "widget->focused"
               ]
            ]
         },
         {
            "type": "func",
            "name": "edit_get_prop",
            "line_range": [
               1121,
               1281
            ],
            "source_code": "ret_t edit_get_prop(widget_t* widget, const char* name, value_t* v) {\n  edit_t* edit = EDIT(widget);\n  input_type_t input_type = INPUT_TEXT;\n  return_value_if_fail(edit != NULL && name != NULL && v != NULL, RET_BAD_PARAMS);\n\n  input_type = edit->input_type;\n  if (tk_str_eq(name, WIDGET_PROP_MIN)) {\n    if (input_type == INPUT_INT) {\n      value_set_int(v, edit->min);\n    } else if (widget_has_uint_min_max(widget)) {\n      value_set_uint32(v, edit->min);\n    } else if (input_type == INPUT_FLOAT || input_type == INPUT_UFLOAT) {\n      value_set_double(v, edit->min);\n    } else {\n      return RET_NOT_FOUND;\n    }\n    return RET_OK;\n  } else if (tk_str_eq(name, WIDGET_PROP_MAX)) {\n    if (input_type == INPUT_INT) {\n      value_set_int(v, edit->max);\n    } else if (widget_has_uint_min_max(widget)) {\n      value_set_uint32(v, edit->max);\n    } else if (input_type == INPUT_FLOAT || input_type == INPUT_UFLOAT) {\n      value_set_double(v, edit->max);\n    } else {\n      return RET_NOT_FOUND;\n    }\n    return RET_OK;\n  } else if (tk_str_eq(name, WIDGET_PROP_STEP)) {\n    if (input_type == INPUT_FLOAT || input_type == INPUT_UFLOAT) {\n      value_set_float(v, edit->step);\n      return RET_OK;\n    } else if (input_type == INPUT_INT || input_type == INPUT_UINT) {\n      value_set_double(v, edit->step);\n      return RET_OK;\n    } else {\n      return RET_NOT_FOUND;\n    }\n  } else if (tk_str_eq(name, WIDGET_PROP_INPUT_TYPE)) {\n    value_set_uint32(v, input_type);\n    return RET_OK;\n  } else if (tk_str_eq(name, WIDGET_PROP_READONLY)) {\n    value_set_bool(v, edit->readonly);\n    return RET_OK;\n  } else if (tk_str_eq(name, WIDGET_PROP_CANCELABLE)) {\n    value_set_bool(v, edit->cancelable);\n    return RET_OK;\n  } else if (tk_str_eq(name, WIDGET_PROP_AUTO_FIX)) {\n    value_set_bool(v, edit->auto_fix);\n    return RET_OK;\n  } else if (tk_str_eq(name, WIDGET_PROP_SELECT_NONE_WHEN_FOCUSED)) {\n    value_set_bool(v, edit->select_none_when_focused);\n    return RET_OK;\n  } else if (tk_str_eq(name, WIDGET_PROP_OPEN_IM_WHEN_FOCUSED)) {\n    value_set_bool(v, edit->open_im_when_focused);\n    return RET_OK;\n  } else if (tk_str_eq(name, WIDGET_PROP_CLOSE_IM_WHEN_BLURED)) {\n    value_set_bool(v, edit->close_im_when_blured);\n    return RET_OK;\n  } else if (tk_str_eq(name, WIDGET_PROP_LEFT_MARGIN)) {\n    uint32_t margin = 0;\n    if (widget->astyle != NULL) {\n      TEXT_EDIT_GET_STYLE_MARGIN(widget->astyle, margin, LEFT);\n    }\n    if (margin == 0) {\n      margin = edit->left_margin != 0 ? edit->left_margin : edit->margin;\n    }\n    value_set_int(v, margin);\n    return RET_OK;\n  } else if (tk_str_eq(name, WIDGET_PROP_RIGHT_MARGIN)) {\n    uint32_t margin = 0;\n    if (widget->astyle != NULL) {\n      TEXT_EDIT_GET_STYLE_MARGIN(widget->astyle, margin, RIGHT);\n    }\n    if (margin == 0) {\n      margin = edit->right_margin != 0 ? edit->right_margin : edit->margin;\n    }\n    value_set_int(v, margin);\n    return RET_OK;\n  } else if (tk_str_eq(name, WIDGET_PROP_TOP_MARGIN)) {\n    uint32_t margin = 0;\n    if (widget->astyle != NULL) {\n      TEXT_EDIT_GET_STYLE_MARGIN(widget->astyle, margin, TOP);\n    }\n    if (margin == 0) {\n      margin = edit->top_margin != 0 ? edit->top_margin : edit->margin;\n    }\n    value_set_int(v, margin);\n    return RET_OK;\n  } else if (tk_str_eq(name, WIDGET_PROP_BOTTOM_MARGIN)) {\n    uint32_t margin = 0;\n    if (widget->astyle != NULL) {\n      TEXT_EDIT_GET_STYLE_MARGIN(widget->astyle, margin, BOTTOM);\n    }\n    if (margin == 0) {\n      margin = edit->bottom_margin != 0 ? edit->bottom_margin : edit->margin;\n    }\n    value_set_int(v, margin);\n    return RET_OK;\n  } else if (tk_str_eq(name, WIDGET_PROP_PASSWORD_VISIBLE)) {\n    value_set_bool(v, edit->password_visible);\n    return RET_OK;\n  } else if (tk_str_eq(name, WIDGET_PROP_ACTION_TEXT)) {\n    value_set_str(v, edit->action_text);\n    return RET_OK;\n  } else if (tk_str_eq(name, WIDGET_PROP_TIPS)) {\n    value_set_str(v, edit->tips);\n    return RET_OK;\n  } else if (tk_str_eq(name, WIDGET_PROP_TR_TIPS)) {\n    value_set_str(v, edit->tr_tips);\n    return RET_OK;\n  } else if (tk_str_eq(name, WIDGET_PROP_KEYBOARD)) {\n    value_set_str(v, edit->keyboard);\n    return RET_OK;\n  } else if (tk_str_eq(name, WIDGET_PROP_FOCUSABLE)) {\n    value_set_bool(v, !(edit->readonly));\n    return RET_OK;\n  } else if (tk_str_eq(name, WIDGET_PROP_VALUE)) {\n    switch (edit->input_type) {\n      case INPUT_INT: {\n        int32_t n = edit_get_int(widget);\n        value_set_int32(v, n);\n        break;\n      }\n      case INPUT_UINT: {\n        uint32_t n = (uint32_t)edit_get_int(widget);\n        value_set_uint32(v, n);\n        break;\n      }\n      case INPUT_FLOAT:\n      case INPUT_UFLOAT: {\n        double d = edit_get_double(widget);\n        value_set_double(v, d);\n        break;\n      }\n      default: {\n        value_set_wstr(v, widget->text.str);\n      }\n    }\n    return RET_OK;\n  } else if (tk_str_eq(name, WIDGET_PROP_CARET_X)) {\n    text_edit_state_t state;\n    text_edit_get_state(edit->model, &state);\n    value_set_int(v, state.caret.x);\n    return RET_OK;\n  } else if (tk_str_eq(name, WIDGET_PROP_CARET_Y)) {\n    text_edit_state_t state;\n    text_edit_get_state(edit->model, &state);\n    value_set_int(v, state.caret.y);\n    return RET_OK;\n  } else if (tk_str_eq(name, WIDGET_PROP_INPUTING)) {\n    int64_t delta = (time_now_ms() - edit->last_user_action_time);\n    bool_t inputing =\n        (delta < TK_INPUTING_TIMEOUT) && (edit->last_user_action_time > 0) && widget->focused;\n    value_set_bool(v, inputing);\n\n    return RET_OK;\n  }\n\n  return RET_NOT_FOUND;\n}",
            "key_variables": [
               [
                  1310,
                  "edit->input_type"
               ]
            ]
         },
         {
            "type": "func",
            "name": "edit_get_double",
            "line_range": [
               1504,
               1511
            ],
            "source_code": "double edit_get_double(widget_t* widget) {\n  double v = 0;\n  return_value_if_fail(widget != NULL, 0);\n\n  wstr_to_float(&(widget->text), &v);\n\n  return v;\n}",
            "key_variables": [
               [
                  1541,
                  "edit->input_type"
               ]
            ]
         },
         {
            "type": "func",
            "name": "edit_set_double",
            "line_range": [
               1523,
               1531
            ],
            "source_code": "ret_t edit_set_double(widget_t* widget, double value) {\n  value_t v;\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  value_set_double(&v, value);\n  edit_set_text(widget, &v);\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  1578,
                  "edit->input_type"
               ]
            ]
         },
         {
            "type": "func",
            "name": "edit_on_clear",
            "line_range": [
               1631,
               1634
            ],
            "source_code": "static ret_t edit_on_clear(void* ctx, event_t* e) {\n  (void)e;\n  return edit_clear(EDIT(ctx));\n}",
            "key_variables": [
               [
                  1655,
                  "widget->name"
               ]
            ]
         },
         {
            "type": "func",
            "name": "edit_hook_button",
            "line_range": [
               1648,
               1667
            ],
            "source_code": "static ret_t edit_hook_button(void* ctx, const void* iter) {\n  widget_t* widget = WIDGET(iter);\n  widget_t* edit = WIDGET(ctx);\n  return_value_if_fail(widget != NULL && edit != NULL, RET_REMOVE);\n\n  if (widget->name && widget != edit) {\n    const char* name = widget->name;\n    if (tk_str_eq(name, \"inc\")) {\n      widget_on(widget, EVT_CLICK, edit_on_inc, edit);\n    } else if (tk_str_eq(name, \"dec\")) {\n      widget_on(widget, EVT_CLICK, edit_on_dec, edit);\n    } else if (tk_str_eq(name, \"clear\")) {\n      widget_on(widget, EVT_CLICK, edit_on_clear, edit);\n    } else if (tk_str_eq(name, \"visible\")) {\n      widget_on(widget, EVT_VALUE_CHANGED, edit_on_password_visible, edit);\n    }\n  }\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  1733,
                  "edit_other->min"
               ],
               [
                  1734,
                  "edit_other->max"
               ],
               [
                  1735,
                  "edit_other->step"
               ],
               [
                  1736,
                  "edit_other->readonly"
               ],
               [
                  1737,
                  "edit_other->auto_fix"
               ],
               [
                  1738,
                  "edit_other->left_margin"
               ],
               [
                  1739,
                  "edit_other->right_margin"
               ],
               [
                  1740,
                  "edit_other->top_margin"
               ],
               [
                  1741,
                  "edit_other->bottom_margin"
               ],
               [
                  1742,
                  "edit_other->password_visible"
               ]
            ]
         },
         {
            "type": "func",
            "name": "edit_set_dec_value",
            "line_range": [
               1841,
               1848
            ],
            "source_code": "ret_t edit_set_dec_value(widget_t* widget, edit_dec_value_t dec_value) {\n  edit_t* edit = EDIT(widget);\n  return_value_if_fail(edit != NULL, RET_BAD_PARAMS);\n\n  edit->dec_value = dec_value;\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  1907,
                  "text->size"
               ],
               [
                  1910,
                  "text->str"
               ],
               [
                  1932,
                  "text->size"
               ]
            ]
         },
         {
            "type": "func",
            "name": "edit_set_select",
            "line_range": [
               1859,
               1864
            ],
            "source_code": "ret_t edit_set_select(widget_t* widget, uint32_t start, uint32_t end) {\n  edit_t* edit = EDIT(widget);\n  return_value_if_fail(edit != NULL && edit->model != NULL, RET_BAD_PARAMS);\n\n  return text_edit_set_select(edit->model, start, end);\n}",
            "key_variables": [
               [
                  1979,
                  "str[cursor]"
               ]
            ]
         }
      ],
      "src/widgets/image.c": [
         {
            "type": "func",
            "name": "image_on_copy",
            "line_range": [
               110,
               119
            ],
            "source_code": "static ret_t image_on_copy(widget_t* widget, widget_t* other) {\n  image_t* image = IMAGE(widget);\n  image_t* image_other = IMAGE(other);\n  return_value_if_fail(image != NULL && image_other != NULL, RET_BAD_PARAMS);\n\n  image_base_on_copy(widget, other);\n  image->draw_type = image_other->draw_type;\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  117,
                  "image_other->draw_type"
               ]
            ]
         }
      ],
      "src/widgets/label.c": [
         {
            "type": "func",
            "name": "label_paint_text_mlines",
            "line_range": [
               28,
               76
            ],
            "source_code": "static ret_t label_paint_text_mlines(widget_t* widget, canvas_t* c, line_parser_t* p, int32_t x,\n                                     int32_t y, int32_t w, int32_t h) {\n  int32_t top = y;\n  int32_t bottom = y + h;\n  style_t* style = widget->astyle;\n  int32_t font_size = c->font_size;\n  int32_t line_height = font_size + style_get_int(style, STYLE_ID_SPACER, 2);\n  align_v_t align_v = (align_v_t)style_get_int(style, STYLE_ID_TEXT_ALIGN_V, ALIGN_V_MIDDLE);\n  align_h_t align_h = (align_h_t)style_get_int(style, STYLE_ID_TEXT_ALIGN_H, ALIGN_H_CENTER);\n  int32_t h_text = p->total_lines * line_height;\n\n  switch (align_v) {\n    case ALIGN_V_MIDDLE: {\n      y = (widget->h - h_text) / 2;\n      break;\n    }\n    case ALIGN_V_BOTTOM: {\n      y = y + h - h_text;\n      break;\n    }\n    default: {\n      break;\n    }\n  }\n\n  y = tk_max(y, top);\n  canvas_set_text_align(c, align_h, align_v);\n\n  while (line_parser_next(p) == RET_OK) {\n    uint32_t size = 0;\n    rect_t r = rect_init(x, y, w, font_size);\n\n    if ((y + font_size) > bottom) {\n      break;\n    }\n\n    for (size = 0; size < p->line_size; size++) {\n      if (p->line[size] == '\\r' || p->line[size] == '\\n') {\n        break;\n      }\n    }\n\n    widget_draw_text_in_rect(widget, c, p->line, size, &r, FALSE);\n\n    y += line_height;\n  }\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  33,
                  "widget->astyle"
               ],
               [
                  34,
                  "c->font_size"
               ],
               [
                  65,
                  "p->line_size"
               ]
            ]
         },
         {
            "type": "func",
            "name": "label_paint_text",
            "line_range": [
               78,
               96
            ],
            "source_code": "static ret_t label_paint_text(widget_t* widget, canvas_t* c, const wchar_t* str, uint32_t size) {\n  line_parser_t p;\n  label_t* label = LABEL(widget);\n  rect_t r = widget_get_content_area(widget);\n\n  return_value_if_fail((r.w > 0 && widget->h >= c->font_size), RET_FAIL);\n  return_value_if_fail(line_parser_init(&p, c, widget->text.str, widget->text.size, c->font_size,\n                                        r.w, label->line_wrap, label->word_wrap) == RET_OK,\n                       RET_BAD_PARAMS);\n\n  if (p.total_lines > 1) {\n    return label_paint_text_mlines(widget, c, &p, r.x, r.y, r.w, r.h);\n  } else {\n    wstr_t str = widget->text;\n    str.size = size;\n\n    return widget_paint_helper(widget, c, NULL, &str);\n  }\n}",
            "key_variables": [
               [
                  92,
                  "widget->text"
               ]
            ]
         },
         {
            "type": "func",
            "name": "label_set_prop",
            "line_range": [
               191,
               209
            ],
            "source_code": "static ret_t label_set_prop(widget_t* widget, const char* name, const value_t* v) {\n  return_value_if_fail(widget != NULL && name != NULL && v != NULL, RET_BAD_PARAMS);\n\n  widget_set_need_relayout(widget);\n  if (tk_str_eq(name, WIDGET_PROP_VALUE) || tk_str_eq(name, WIDGET_PROP_TEXT)) {\n    wstr_from_value(&(widget->text), v);\n    return RET_OK;\n  } else if (tk_str_eq(name, WIDGET_PROP_LENGTH)) {\n    return label_set_length(widget, tk_roundi(value_float(v)));\n  } else if (tk_str_eq(name, WIDGET_PROP_MAX_W)) {\n    return label_set_max_w(widget, value_int(v));\n  } else if (tk_str_eq(name, WIDGET_PROP_LINE_WRAP)) {\n    return label_set_line_wrap(widget, value_bool(v));\n  } else if (tk_str_eq(name, WIDGET_PROP_WORD_WRAP)) {\n    return label_set_word_wrap(widget, value_bool(v));\n  }\n\n  return RET_NOT_FOUND;\n}",
            "key_variables": [
               [
                  219,
                  "widget->astyle"
               ]
            ]
         },
         {
            "type": "func",
            "name": "label_auto_adjust_size",
            "line_range": [
               270,
               286
            ],
            "source_code": "static ret_t label_auto_adjust_size(widget_t* widget) {\n  int32_t max_w = 0;\n  label_t* label = LABEL(widget);\n  canvas_t* c = widget_get_canvas(widget);\n  return_value_if_fail(c != NULL, RET_BAD_PARAMS);\n  return_value_if_fail(label != NULL && widget->astyle != NULL, RET_BAD_PARAMS);\n\n  if (!widget->auto_adjust_size || !widget_is_window_created(widget)) {\n    return RET_OK;\n  }\n\n  if (label->max_w != 0) {\n    max_w = label->max_w > 0 ? label->max_w : (widget->parent->w + label->max_w);\n  }\n\n  return label_auto_adjust_size_impl(widget, c, 0, max_w, 0, 0xffff);\n}",
            "key_variables": [
               [
                  300,
                  "e->type"
               ]
            ]
         }
      ],
      "src/widgets/overlay.c": [
         {
            "type": "func",
            "name": "overlay_get_prop",
            "line_range": [
               38,
               51
            ],
            "source_code": "static ret_t overlay_get_prop(widget_t* widget, const char* name, value_t* v) {\n  overlay_t* overlay = OVERLAY(widget);\n  return_value_if_fail(overlay != NULL && name != NULL && v != NULL, RET_BAD_PARAMS);\n\n  if (tk_str_eq(name, WIDGET_PROP_CLICK_THROUGH)) {\n    value_set_bool(v, overlay->click_through);\n    return RET_OK;\n  } else if (tk_str_eq(name, WIDGET_PROP_ALWAYS_ON_TOP)) {\n    value_set_bool(v, overlay->always_on_top);\n    return RET_OK;\n  }\n\n  return window_base_get_prop(widget, name, v);\n}",
            "key_variables": [
               [
                  62,
                  "iter->x"
               ],
               [
                  63,
                  "iter->y"
               ]
            ]
         }
      ],
      "src/widgets/pages.c": [
         {
            "type": "func",
            "name": "pages_set_prop",
            "line_range": [
               163,
               171
            ],
            "source_code": "static ret_t pages_set_prop(widget_t* widget, const char* name, const value_t* v) {\n  return_value_if_fail(widget != NULL && name != NULL && v != NULL, RET_BAD_PARAMS);\n\n  if (tk_str_eq(name, WIDGET_PROP_VALUE) || tk_str_eq(name, WIDGET_PROP_ACTIVE)) {\n    return pages_set_active(widget, value_int(v));\n  }\n\n  return RET_NOT_FOUND;\n}",
            "key_variables": [
               [
                  176,
                  "e->type"
               ]
            ]
         }
      ],
      "src/widgets/popup.c": [
         {
            "type": "func",
            "name": "popup_idle_window_close",
            "line_range": [
               69,
               82
            ],
            "source_code": "static ret_t popup_idle_window_close(const idle_info_t* idle) {\n  widget_t* widget = WIDGET(idle->ctx);\n  widget_t* win = widget->parent;\n  return_value_if_fail(win && widget != NULL, RET_REMOVE);\n\n  widget_ungrab(win, widget);\n\n  if (window_manager_is_animating(win)) {\n    window_close_force(widget);\n  } else {\n    window_close(widget);\n  }\n  return RET_REMOVE;\n}",
            "key_variables": [
               [
                  72,
                  "widget->parent"
               ]
            ]
         },
         {
            "type": "func",
            "name": "popup_update_close_timer",
            "line_range": [
               84,
               93
            ],
            "source_code": "static ret_t popup_update_close_timer(widget_t* widget) {\n  popup_t* popup = POPUP(widget);\n  return_value_if_fail(popup && widget != NULL, RET_BAD_PARAMS);\n\n  if (popup->timer_id != TK_INVALID_ID && popup->close_when_timeout > 0) {\n    timer_modify(popup->timer_id, popup->close_when_timeout);\n  }\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  97,
                  "e->type"
               ]
            ]
         }
      ],
      "src/widgets/progress_bar.c": [
         {
            "type": "func",
            "name": "progress_bar_get_percent",
            "line_range": [
               37,
               41
            ],
            "source_code": "uint32_t progress_bar_get_percent(widget_t* widget) {\n  double percent = progress_bar_get_progress(widget) * 100;\n\n  return tk_roundi(percent);\n}",
            "key_variables": [
               [
                  46,
                  "widget->astyle"
               ],
               [
                  54,
                  "progress_bar->reverse"
               ],
               [
                  58,
                  "widget->w"
               ],
               [
                  63,
                  "widget->h"
               ],
               [
                  76,
                  "widget->w"
               ],
               [
                  80,
                  "widget->h"
               ]
            ]
         },
         {
            "type": "func",
            "name": "progress_bar_update_text",
            "line_range": [
               96,
               113
            ],
            "source_code": "static ret_t progress_bar_update_text(widget_t* widget) {\n  char str[TK_NUM_MAX_LEN + 1];\n  progress_bar_t* progress_bar = PROGRESS_BAR(widget);\n  return_value_if_fail(progress_bar != NULL, RET_BAD_PARAMS);\n\n  if (progress_bar->format != NULL) {\n    if (strchr(progress_bar->format, 'd') != NULL || strchr(progress_bar->format, 'x') != NULL ||\n        strchr(progress_bar->format, 'X') != NULL) {\n      tk_snprintf(str, TK_NUM_MAX_LEN, progress_bar->format, tk_roundi(progress_bar->value));\n    } else {\n      tk_snprintf(str, TK_NUM_MAX_LEN, progress_bar->format, progress_bar->value);\n    }\n  } else {\n    tk_snprintf(str, TK_NUM_MAX_LEN, \"%d%%\", progress_bar_get_percent(widget));\n  }\n\n  return widget_set_text_utf8(widget, str);\n}",
            "key_variables": [
               [
                  98,
                  "str[TK_NUM_MAX_LEN + 1]"
               ]
            ]
         }
      ],
      "src/widgets/slider.c": [
         {
            "type": "func",
            "name": "slider_load_icon",
            "line_range": [
               29,
               37
            ],
            "source_code": "static ret_t slider_load_icon(widget_t* widget, bitmap_t* img) {\n  style_t* style = widget->astyle;\n  const char* image_name = style_get_str(style, STYLE_ID_ICON, NULL);\n  if (image_name && widget_load_image(widget, image_name, img) == RET_OK) {\n    return RET_OK;\n  } else {\n    return RET_FAIL;\n  }\n}",
            "key_variables": [
               [
                  31,
                  "widget->astyle"
               ]
            ]
         },
         {
            "type": "func",
            "name": "slider_get_bar_size",
            "line_range": [
               39,
               48
            ],
            "source_code": "static uint32_t slider_get_bar_size(widget_t* widget) {\n  slider_t* slider = SLIDER(widget);\n  return_value_if_fail(slider != NULL, 0);\n\n  if (slider->vertical) {\n    return slider->bar_size ? slider->bar_size : (widget->w >> 1);\n  } else {\n    return slider->bar_size ? slider->bar_size : (widget->h >> 1);\n  }\n}",
            "key_variables": [
               [
                  62,
                  "lcd->ratio"
               ],
               [
                  69,
                  "widget->w"
               ],
               [
                  70,
                  "slider->dragger_size"
               ],
               [
                  74,
                  "slider->dragger_size"
               ],
               [
                  75,
                  "widget->h"
               ]
            ]
         },
         {
            "type": "func",
            "name": "slider_fill_rect",
            "line_range": [
               82,
               112
            ],
            "source_code": "static ret_t slider_fill_rect(widget_t* widget, canvas_t* c, rect_t* r, rect_t* br,\n                              image_draw_type_t draw_type) {\n  bitmap_t img;\n  style_t* style = widget->astyle;\n  color_t trans = color_init(0, 0, 0, 0);\n  uint32_t radius = style_get_int(style, STYLE_ID_ROUND_RADIUS, 0);\n  const char* color_key = br ? STYLE_ID_FG_COLOR : STYLE_ID_BG_COLOR;\n  const char* image_key = br ? STYLE_ID_FG_IMAGE : STYLE_ID_BG_IMAGE;\n  const char* draw_type_key = br ? STYLE_ID_FG_IMAGE_DRAW_TYPE : STYLE_ID_BG_IMAGE_DRAW_TYPE;\n\n  color_t color = style_get_color(style, color_key, trans);\n  const char* image_name = style_get_str(style, image_key, NULL);\n\n  if (color.rgba.a && r->w > 0 && r->h > 0) {\n    canvas_set_fill_color(c, color);\n    if (radius > 3) {\n      canvas_fill_rounded_rect(c, r, br, &color, radius);\n    } else {\n      canvas_fill_rect(c, r->x, r->y, r->w, r->h);\n    }\n  }\n\n  if (image_name != NULL && r->w > 0 && r->h > 0) {\n    if (widget_load_image(widget, image_name, &img) == RET_OK) {\n      draw_type = (image_draw_type_t)style_get_int(style, draw_type_key, draw_type);\n      canvas_draw_image_ex(c, &img, draw_type, r);\n    }\n  }\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  86,
                  "widget->astyle"
               ],
               [
                  119,
                  "widget->astyle"
               ]
            ]
         },
         {
            "type": "func",
            "name": "slider_paint_dragger",
            "line_range": [
               114,
               140
            ],
            "source_code": "static ret_t slider_paint_dragger(widget_t* widget, canvas_t* c) {\n  bitmap_t img;\n  color_t color;\n  uint32_t radius;\n  style_t* style = widget->astyle;\n  slider_t* slider = SLIDER(widget);\n  rect_t* r = &(slider->dragger_rect);\n  color_t trans = color_init(0, 0, 0, 0);\n\n  color = style_get_color(style, STYLE_ID_BORDER_COLOR, trans);\n  radius = style_get_int(style, STYLE_ID_ROUND_RADIUS, 0);\n\n  if (color.rgba.a) {\n    canvas_set_fill_color(c, color);\n    if (radius > 3) {\n      canvas_fill_rounded_rect(c, r, NULL, &color, radius);\n    } else {\n      canvas_fill_rect(c, r->x, r->y, r->w, r->h);\n    }\n  }\n\n  if (slider_load_icon(widget, &img) == RET_OK) {\n    canvas_draw_image_ex(c, &img, IMAGE_DRAW_ICON, r);\n  }\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  162,
                  "dr->y"
               ],
               [
                  165,
                  "br->w"
               ],
               [
                  166,
                  "br->x"
               ],
               [
                  167,
                  "dr->y"
               ],
               [
                  176,
                  "dr->x"
               ],
               [
                  178,
                  "br->h"
               ],
               [
                  179,
                  "br->y"
               ]
            ]
         },
         {
            "type": "func",
            "name": "slider_pointer_up_cleanup",
            "line_range": [
               204,
               215
            ],
            "source_code": "static ret_t slider_pointer_up_cleanup(widget_t* widget) {\n  slider_t* slider = SLIDER(widget);\n  return_value_if_fail(widget != NULL && slider != NULL, RET_BAD_PARAMS);\n\n  slider->pressed = FALSE;\n  slider->dragging = FALSE;\n  widget_ungrab(widget->parent, widget);\n  widget_set_state(widget, WIDGET_STATE_NORMAL);\n  widget_invalidate(widget, NULL);\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  226,
                  "slider->min"
               ],
               [
                  230,
                  "slider->max"
               ]
            ]
         },
         {
            "type": "func",
            "name": "slider_inc",
            "line_range": [
               235,
               247
            ],
            "source_code": "ret_t slider_inc(widget_t* widget) {\n  ret_t ret = RET_OK;\n  slider_t* slider = SLIDER(widget);\n  return_value_if_fail(widget != NULL && slider != NULL, RET_BAD_PARAMS);\n\n  if (slider->step) {\n    ret = slider_add_value(widget, slider->step);\n  } else {\n    ret = slider_add_value(widget, 1);\n  }\n\n  return ret;\n}",
            "key_variables": [
               [
                  267,
                  "slider->min"
               ],
               [
                  272,
                  "widget->h"
               ],
               [
                  274,
                  "widget->w"
               ],
               [
                  276,
                  "slider->min"
               ]
            ]
         },
         {
            "type": "func",
            "name": "slider_on_event",
            "line_range": [
               281,
               407
            ],
            "source_code": "static ret_t slider_on_event(widget_t* widget, event_t* e) {\n  ret_t ret = RET_OK;\n  uint16_t type = e->type;\n  slider_t* slider = SLIDER(widget);\n  return_value_if_fail(widget != NULL && slider != NULL, RET_BAD_PARAMS);\n\n  ret = slider->dragging ? RET_STOP : RET_OK;\n  switch (type) {\n    case EVT_POINTER_DOWN: {\n      rect_t br, fr;\n      pointer_event_t* evt = (pointer_event_t*)e;\n      point_t p = {evt->x, evt->y};\n      rect_t* dr = &(slider->dragger_rect);\n\n      return_value_if_fail(RET_OK == slider_get_bar_rect(widget, &br, &fr), RET_STOP);\n\n      widget_to_local(widget, &p);\n      slider->saved_value = slider->value;\n      if (slider->slide_with_bar || rect_contains(dr, p.x, p.y) || rect_contains(&br, p.x, p.y) ||\n          rect_contains(&fr, p.x, p.y)) {\n        slider_change_value_by_pointer_event(widget, evt);\n\n        slider->down = p;\n        slider->pressed = TRUE;\n        slider->dragging = TRUE;\n        widget_set_state(widget, WIDGET_STATE_PRESSED);\n        widget_grab(widget->parent, widget);\n        widget_invalidate(widget, NULL);\n      }\n      ret = slider->dragging ? RET_STOP : RET_OK;\n      break;\n    }\n    case EVT_POINTER_DOWN_ABORT: {\n      slider_pointer_up_cleanup(widget);\n      break;\n    }\n    case EVT_POINTER_MOVE: {\n      pointer_event_t* evt = (pointer_event_t*)e;\n      if (slider->dragging) {\n        slider_change_value_by_pointer_event(widget, evt);\n      }\n\n      break;\n    }\n    case EVT_POINTER_UP: {\n      if (slider->dragging || slider->pressed) {\n        double value = 0;\n        pointer_event_t* evt = (pointer_event_t*)e;\n\n        slider_change_value_by_pointer_event(widget, evt);\n\n        value = slider->value;\n        slider->dragging = FALSE;\n        slider->value = slider->saved_value;\n        slider_set_value(widget, value);\n      }\n      slider_pointer_up_cleanup(widget);\n      break;\n    }\n    case EVT_POINTER_LEAVE:\n      widget_set_state(widget, slider->dragging ? WIDGET_STATE_PRESSED : WIDGET_STATE_NORMAL);\n      break;\n    case EVT_POINTER_ENTER:\n      widget_set_state(widget, slider->dragging ? WIDGET_STATE_PRESSED : WIDGET_STATE_OVER);\n      break;\n    case EVT_KEY_DOWN: {\n      bool_t inc = FALSE;\n      bool_t dec = FALSE;\n      key_event_t* evt = (key_event_t*)e;\n      keyboard_type_t keyboard_type = system_info()->keyboard_type;\n\n      if (slider->vertical || keyboard_type == KEYBOARD_3KEYS) {\n        if (evt->key == TK_KEY_UP) {\n          inc = TRUE;\n        } else if (evt->key == TK_KEY_DOWN) {\n          dec = TRUE;\n        }\n      }\n\n      if (!slider->vertical || keyboard_type == KEYBOARD_3KEYS) {\n        if (evt->key == TK_KEY_RIGHT) {\n          inc = TRUE;\n        } else if (evt->key == TK_KEY_LEFT) {\n          dec = TRUE;\n        }\n      }\n\n      if (dec) {\n        slider_dec(widget);\n        ret = RET_STOP;\n      } else if (inc) {\n        slider_inc(widget);\n        ret = RET_STOP;\n      }\n      slider->last_user_action_time = e->time;\n      break;\n    }\n    case EVT_KEY_UP: {\n      key_event_t* evt = (key_event_t*)e;\n      if (slider->vertical) {\n        if (evt->key == TK_KEY_UP) {\n          ret = RET_STOP;\n        } else if (evt->key == TK_KEY_DOWN) {\n          ret = RET_STOP;\n        }\n      } else {\n        if (evt->key == TK_KEY_LEFT) {\n          ret = RET_STOP;\n        } else if (evt->key == TK_KEY_RIGHT) {\n          ret = RET_STOP;\n        }\n      }\n      slider->last_user_action_time = e->time;\n      break;\n    }\n    case EVT_RESIZE:\n    case EVT_MOVE_RESIZE: {\n      slider_update_dragger_rect(widget, NULL);\n    }\n    default: {\n      ret = RET_OK;\n      break;\n    }\n  }\n\n  return ret;\n}",
            "key_variables": [
               [
                  284,
                  "e->type"
               ],
               [
                  299,
                  "slider->value"
               ],
               [
                  333,
                  "slider->value"
               ],
               [
                  335,
                  "slider->saved_value"
               ],
               [
                  376,
                  "e->time"
               ],
               [
                  394,
                  "e->time"
               ],
               [
                  416,
                  "slider->step"
               ],
               [
                  420,
                  "slider->min"
               ]
            ]
         },
         {
            "type": "func",
            "name": "slider_set_bar_size",
            "line_range": [
               487,
               494
            ],
            "source_code": "ret_t slider_set_bar_size(widget_t* widget, uint32_t bar_size) {\n  slider_t* slider = SLIDER(widget);\n  return_value_if_fail(slider != NULL, RET_BAD_PARAMS);\n\n  slider->bar_size = bar_size;\n\n  return widget_invalidate(widget, NULL);\n}",
            "key_variables": [
               [
                  540,
                  "widget->focused"
               ]
            ]
         }
      ],
      "src/widgets/system_bar.c": [
         {
            "type": "func",
            "name": "system_bar_on_top_window_prop_changed",
            "line_range": [
               75,
               93
            ],
            "source_code": "static ret_t system_bar_on_top_window_prop_changed(void* ctx, event_t* e) {\n  widget_t* widget = WIDGET(ctx);\n  prop_change_event_t* evt = (prop_change_event_t*)e;\n  widget_t* top_window = window_manager_get_top_main_window(widget->parent);\n\n  if (top_window != WIDGET(e->target)) {\n    return RET_OK;\n  }\n\n  if (tk_str_eq(evt->name, WIDGET_PROP_TEXT) || tk_str_eq(evt->name, WIDGET_PROP_NAME)) {\n    system_bar_update_title(widget, top_window);\n  }\n\n  if (tk_str_eq(evt->name, WIDGET_PROP_CLOSABLE)) {\n    system_bar_update_close(widget, top_window);\n  }\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  99,
                  "evt->window"
               ]
            ]
         }
      ],
      "src/widgets/tab_button.c": [
         {
            "type": "func",
            "name": "tab_button_on_event",
            "line_range": [
               39,
               77
            ],
            "source_code": "static ret_t tab_button_on_event(widget_t* widget, event_t* e) {\n  uint16_t type = e->type;\n  tab_button_t* tab_button = TAB_BUTTON(widget);\n  return_value_if_fail(tab_button != NULL && e != NULL, RET_BAD_PARAMS);\n  switch (type) {\n    case EVT_POINTER_DOWN: {\n      widget_set_state(widget, WIDGET_STATE_PRESSED);\n      tab_button->pressed = TRUE;\n      widget_grab(widget->parent, widget);\n      break;\n    }\n    case EVT_POINTER_UP: {\n      pointer_event_t evt = *(pointer_event_t*)e;\n      if (tab_button->pressed && widget_is_point_in(widget, evt.x, evt.y, FALSE)) {\n        evt.e.type = EVT_CLICK;\n        widget_dispatch(widget, (event_t*)&(evt));\n      }\n      tab_button_pointer_up_cleanup(widget);\n      break;\n    }\n    case EVT_CLICK: {\n      tab_button_set_value(widget, TRUE);\n      break;\n    }\n    case EVT_POINTER_DOWN_ABORT:\n      tab_button_pointer_up_cleanup(widget);\n      break;\n    case EVT_POINTER_LEAVE:\n      widget_set_state(widget, WIDGET_STATE_NORMAL);\n      break;\n    case EVT_POINTER_ENTER:\n      widget_set_state(widget, WIDGET_STATE_OVER);\n      break;\n    default:\n      break;\n  }\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  41,
                  "e->type"
               ]
            ]
         },
         {
            "type": "func",
            "name": "tab_button_on_paint_self",
            "line_range": [
               79,
               87
            ],
            "source_code": "static ret_t tab_button_on_paint_self(widget_t* widget, canvas_t* c) {\n  const char* icon = NULL;\n  tab_button_t* tab_button = TAB_BUTTON(widget);\n  return_value_if_fail(tab_button != NULL, RET_BAD_PARAMS);\n\n  icon = tab_button->value ? tab_button->active_icon : tab_button->icon;\n\n  return widget_paint_helper(widget, c, icon, NULL);\n}",
            "key_variables": [
               [
                  85,
                  "tab_button->icon"
               ]
            ]
         },
         {
            "type": "func",
            "name": "tab_button_load_ui",
            "line_range": [
               128,
               133
            ],
            "source_code": "static void tab_button_load_ui(tab_button_t* tab_button, widget_t* pages) {\n  tab_button->ui = ui_loader_load_widget(tab_button->load_ui);\n  if (tab_button->ui != NULL) {\n    widget_add_child(pages, tab_button->ui);\n  }\n}",
            "key_variables": [
               [
                  141,
                  "widget->parent"
               ]
            ]
         },
         {
            "type": "func",
            "name": "tab_button_index_of",
            "line_range": [
               135,
               152
            ],
            "source_code": "int32_t tab_button_index_of(widget_t* widget) {\n  int32_t index = 0;\n  widget_t* parent = NULL;\n  return_value_if_fail(widget != NULL && widget->parent != NULL, -1);\n\n  parent = widget->parent;\n  WIDGET_FOR_EACH_CHILD_BEGIN(parent, iter, i)\n  if (tk_str_eq(iter->vt->type, WIDGET_TYPE_TAB_BUTTON)) {\n    if (iter == widget) {\n      return index;\n    } else {\n      index++;\n    }\n  }\n  WIDGET_FOR_EACH_CHILD_END();\n\n  return -1;\n}",
            "key_variables": [
               [
                  180,
                  "widget->parent"
               ]
            ]
         },
         {
            "type": "func",
            "name": "tab_button_set_load_ui",
            "line_range": [
               217,
               224
            ],
            "source_code": "ret_t tab_button_set_load_ui(widget_t* widget, const char* name) {\n  tab_button_t* tab_button = TAB_BUTTON(widget);\n  return_value_if_fail(widget != NULL, RET_BAD_PARAMS);\n\n  tab_button->load_ui = tk_str_copy(tab_button->load_ui, name);\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  232,
                  "widget->h"
               ]
            ]
         }
      ],
      "src/widgets/tab_button_group.c": [
         {
            "type": "func",
            "name": "tab_button_group_on_layout_children_non_compact",
            "line_range": [
               24,
               46
            ],
            "source_code": "static ret_t tab_button_group_on_layout_children_non_compact(widget_t* widget) {\n  int32_t x = 0;\n  int32_t y = 0;\n  int32_t w = 0;\n  int32_t h = widget->h;\n  int32_t nr = widget->children->size;\n  int32_t item_w = widget->w / nr;\n  int32_t first_w = widget->w - (nr - 1) * item_w;\n  tab_button_group_t* tab_button_group = TAB_BUTTON_GROUP(widget);\n\n  WIDGET_FOR_EACH_CHILD_BEGIN(widget, iter, i)\n  w = i == 0 ? first_w : item_w;\n  widget_move_resize(iter, x, y, w, h);\n  x += w;\n  widget_layout_children(iter);\n  WIDGET_FOR_EACH_CHILD_END();\n\n  hscrollable_set_xoffset(tab_button_group->hscrollable, 0);\n  hscrollable_set_virtual_w(tab_button_group->hscrollable, widget->w);\n  hscrollable_set_always_scrollable(tab_button_group->hscrollable, FALSE);\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  29,
                  "widget->h"
               ],
               [
                  30,
                  "children->size"
               ]
            ]
         },
         {
            "type": "func",
            "name": "tab_button_group_on_layout_children_compact",
            "line_range": [
               48,
               81
            ],
            "source_code": "static ret_t tab_button_group_on_layout_children_compact(widget_t* widget) {\n  value_t v;\n  int32_t x = 0;\n  int32_t y = 0;\n  int32_t w = 0;\n  int32_t h = widget->h;\n  widget_t* active = NULL;\n  tab_button_group_t* tab_button_group = TAB_BUTTON_GROUP(widget);\n\n  WIDGET_FOR_EACH_CHILD_BEGIN(widget, iter, i)\n  iter->h = h;\n  if (widget_get_prop(iter, WIDGET_PROP_MIN_W, &v) == RET_OK) {\n    w = value_int(&v);\n  } else {\n    w = iter->w;\n  }\n\n  widget_move_resize(iter, x, y, w, h);\n  widget_layout_children(iter);\n  x += w;\n  if (widget_get_value(iter)) {\n    active = iter;\n  }\n  WIDGET_FOR_EACH_CHILD_END();\n\n  hscrollable_set_virtual_w(tab_button_group->hscrollable, x - 1);\n  hscrollable_set_always_scrollable(tab_button_group->hscrollable, FALSE);\n\n  if (active != NULL) {\n    widget_ensure_visible_in_viewport(active);\n  }\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  54,
                  "widget->h"
               ],
               [
                  63,
                  "iter->w"
               ]
            ]
         },
         {
            "type": "func",
            "name": "tab_button_group_on_destroy",
            "line_range": [
               221,
               228
            ],
            "source_code": "static ret_t tab_button_group_on_destroy(widget_t* widget) {\n  tab_button_group_t* tab_button_group = TAB_BUTTON_GROUP(widget);\n  return_value_if_fail(widget != NULL && tab_button_group != NULL, RET_BAD_PARAMS);\n\n  hscrollable_destroy(tab_button_group->hscrollable);\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  251,
                  "children->size"
               ]
            ]
         }
      ],
      "src/widget_animators/widget_animator_factory.c": [
         {
            "type": "block",
            "name": "block",
            "line_range": "",
            "source_code": "",
            "key_variables": [
               53,
               "type[TK_NAME_LEN + 1]"
            ]
         },
         {
            "type": "block",
            "name": "block",
            "line_range": "",
            "source_code": "",
            "key_variables": [
               54,
               "name[TK_NAME_LEN + 1]"
            ]
         },
         {
            "type": "func",
            "name": "parser_on_name",
            "line_range": [
               80,
               124
            ],
            "source_code": "static ret_t parser_on_name(func_call_parser_t* parser, const char* func_name) {\n  value_t v;\n  widget_animator_parser_t* p = (widget_animator_parser_t*)parser;\n  widget_t* widget = p->params.widget;\n  const char* type = p->params.type;\n\n  tk_strncpy(p->params.type, func_name, TK_NAME_LEN);\n  if (tk_str_eq(type, \"move\")) {\n    move_params_t* params = &p->params.u.move;\n\n    params->x_from = widget->x;\n    params->y_from = widget->y;\n    params->x_to = widget->x;\n    params->y_to = widget->y;\n  } else if (tk_str_eq(type, \"scale\")) {\n    float_t scale_x = 1.0f;\n    float_t scale_y = 1.0f;\n    scale_params_t* params = &p->params.u.scale;\n\n    if (widget_get_prop(widget, WIDGET_PROP_SCALE_X, &v) == RET_OK) {\n      scale_x = value_float(&v);\n    }\n    if (widget_get_prop(widget, WIDGET_PROP_SCALE_Y, &v) == RET_OK) {\n      scale_y = value_float(&v);\n    }\n\n    params->x_from = scale_x;\n    params->y_from = scale_y;\n    params->x_to = scale_x;\n    params->y_to = scale_y;\n  } else {\n    float_t value = 0;\n    const char* prop_name = p->params.type;\n    prop_params_t* params = &p->params.u.prop;\n\n    if (widget_get_prop(widget, prop_name, &v) == RET_OK) {\n      value = value_float(&v);\n    }\n\n    params->from = value;\n    params->to = value;\n  }\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  91,
                  "widget->x"
               ],
               [
                  92,
                  "widget->y"
               ],
               [
                  93,
                  "widget->x"
               ],
               [
                  94,
                  "widget->y"
               ]
            ]
         }
      ],
      "src/window_animators/window_animator_center_scale.c": [
         {
            "type": "func",
            "name": "window_animator_center_scale_draw_curr",
            "line_range": [
               42,
               82
            ],
            "source_code": "static ret_t window_animator_center_scale_draw_curr(window_animator_t* wa) {\n  canvas_t* c = wa->canvas;\n  widget_t* win = wa->curr_win;\n  float_t scale = wa->percent;\n\n#ifndef WITHOUT_WINDOW_ANIMATOR_CACHE\n  rectf_t src = rectf_init(win->x, win->y, win->w, win->h);\n  rectf_t dst = rectf_init(0.0f, 0.0f, win->w * scale, win->h * scale);\n  if (wa->time_percent < 5) {\n    float_t alpha = wa->open ? wa->time_percent : 1 - wa->time_percent;\n    lcd_set_global_alpha(c->lcd, alpha * 0xff);\n  } else {\n    lcd_set_global_alpha(c->lcd, 0xff);\n  }\n\n  dst.x = win->x + ((win->w - dst.w) / 2.0f);\n  dst.y = win->y + ((win->h - dst.h) / 2.0f);\n\n  return lcd_draw_image(c->lcd, &(wa->curr_img), rectf_scale(&src, wa->ratio), &dst);\n#else\n#ifdef WITH_GPU\n  vgcanvas_t* vg = canvas_get_vgcanvas(c);\n  float x = win->x + (win->w / 2);\n  float y = win->y + (win->h / 2);\n  float alpha = 1 - (1 - scale) / (1 - START_PERCENT);\n\n  vgcanvas_save(vg);\n  vgcanvas_translate(vg, x, y);\n  vgcanvas_scale(vg, scale, scale);\n  vgcanvas_translate(vg, -x, -y);\n  vgcanvas_set_global_alpha(vg, alpha);\n  widget_paint(win, c);\n  vgcanvas_restore(vg);\n  return RET_OK;\n#else\n  assert(!\"not supported\");\n  return RET_FAIL;\n#endif /*WITH_GPU*/\n\n#endif /*WITHOUT_WINDOW_ANIMATOR_CACHE*/\n}",
            "key_variables": [
               [
                  44,
                  "wa->canvas"
               ],
               [
                  45,
                  "wa->curr_win"
               ],
               [
                  46,
                  "wa->percent"
               ],
               [
                  52,
                  "wa->time_percent"
               ]
            ]
         }
      ],
      "src/window_animators/window_animator_common.c": [
         {
            "type": "func",
            "name": "window_animator_to_bottom_draw_curr",
            "line_range": [
               31,
               54
            ],
            "source_code": "ret_t window_animator_to_bottom_draw_curr(window_animator_t* wa) {\n  canvas_t* c = wa->canvas;\n  widget_t* win = wa->curr_win;\n  float_t percent = wa->percent;\n#ifndef WITHOUT_WINDOW_ANIMATOR_CACHE\n  int32_t y = win->y;\n  int32_t h = tk_roundi(win->h * percent);\n\n  rectf_t src = rectf_init(win->x, win->y + win->h - h, win->w, h);\n  rectf_t dst = rectf_init(win->x, y, win->w, h);\n\n  if (h == 0) {\n    return RET_OK;\n  }\n\n  return lcd_draw_image(c->lcd, &(wa->curr_img), rectf_scale(&src, wa->ratio), &dst);\n#else\n  int32_t y = -win->h * (1 - percent);\n  canvas_translate(c, 0, y);\n  widget_paint(win, c);\n  canvas_untranslate(c, 0, y);\n  return RET_OK;\n#endif /*WITHOUT_WINDOW_ANIMATOR_CACHE*/\n}",
            "key_variables": [
               [
                  33,
                  "wa->canvas"
               ],
               [
                  34,
                  "wa->curr_win"
               ],
               [
                  35,
                  "wa->percent"
               ],
               [
                  37,
                  "win->y"
               ]
            ]
         },
         {
            "type": "func",
            "name": "window_animator_to_top_draw_curr",
            "line_range": [
               56,
               79
            ],
            "source_code": "ret_t window_animator_to_top_draw_curr(window_animator_t* wa) {\n  canvas_t* c = wa->canvas;\n  widget_t* win = wa->curr_win;\n  float_t percent = wa->percent;\n#ifndef WITHOUT_WINDOW_ANIMATOR_CACHE\n  int32_t y = win->y + tk_roundi(win->h * (1 - percent));\n  int32_t h = win->y + win->h - y;\n\n  rectf_t src = rectf_init(win->x, win->y, win->w, h);\n  rectf_t dst = rectf_init(win->x, y, win->w, h);\n\n  if (h == 0) {\n    return RET_OK;\n  }\n\n  return lcd_draw_image(c->lcd, &(wa->curr_img), rectf_scale(&src, wa->ratio), &dst);\n#else\n  int32_t y = win->h * (1 - percent);\n  canvas_translate(c, 0, y);\n  widget_paint(win, c);\n  canvas_untranslate(c, 0, y);\n  return RET_OK;\n#endif /*WITHOUT_WINDOW_ANIMATOR_CACHE*/\n}",
            "key_variables": [
               [
                  58,
                  "wa->canvas"
               ],
               [
                  59,
                  "wa->curr_win"
               ],
               [
                  60,
                  "wa->percent"
               ]
            ]
         },
         {
            "type": "func",
            "name": "window_animator_to_left_draw_curr",
            "line_range": [
               81,
               105
            ],
            "source_code": "ret_t window_animator_to_left_draw_curr(window_animator_t* wa) {\n  canvas_t* c = wa->canvas;\n  widget_t* win = wa->curr_win;\n  float_t percent = wa->percent;\n#ifndef WITHOUT_WINDOW_ANIMATOR_CACHE\n  int32_t x = win->x + tk_roundi(win->w * (1 - percent));\n  int32_t w = win->x + win->w - x;\n\n  rectf_t src = rectf_init(win->x, win->y, w, win->h);\n  rectf_t dst = rectf_init(x, win->y, w, win->h);\n\n  if (w == 0) {\n    return RET_OK;\n  }\n\n  return lcd_draw_image(c->lcd, &(wa->curr_img), rectf_scale(&src, wa->ratio), &dst);\n#else\n  int32_t x = -win->w * (1 - percent);\n\n  canvas_translate(c, x, 0);\n  widget_paint(win, c);\n  canvas_untranslate(c, x, 0);\n  return RET_OK;\n#endif /*WITHOUT_WINDOW_ANIMATOR_CACHE*/\n}",
            "key_variables": [
               [
                  83,
                  "wa->canvas"
               ],
               [
                  84,
                  "wa->curr_win"
               ],
               [
                  85,
                  "wa->percent"
               ],
               [
                  109,
                  "wa->canvas"
               ],
               [
                  110,
                  "wa->curr_win"
               ],
               [
                  111,
                  "wa->percent"
               ],
               [
                  113,
                  "win->x"
               ]
            ]
         },
         {
            "type": "func",
            "name": "window_animator_destroy",
            "line_range": [
               177,
               185
            ],
            "source_code": "ret_t window_animator_destroy(window_animator_t* wa) {\n  return_value_if_fail(wa != NULL, RET_FAIL);\n\n  if (wa->open) {\n    return window_animator_open_destroy(wa);\n  } else {\n    return window_animator_close_destroy(wa);\n  }\n}",
            "key_variables": [
               [
                  191,
                  "curr_win->parent"
               ]
            ]
         },
         {
            "type": "func",
            "name": "window_animator_prepare",
            "line_range": [
               221,
               239
            ],
            "source_code": "ret_t window_animator_prepare(window_animator_t* wa, canvas_t* c, widget_t* prev_win,\n                              widget_t* curr_win) {\n  widget_t* wm = prev_win->parent;\n\n  wa->canvas = c;\n  wa->prev_win = prev_win;\n  wa->curr_win = curr_win;\n  wa->ratio = c->lcd->ratio;\n  wa->duration = wa->duration ? wa->duration : 500;\n\n  window_animator_init(wa);\n#ifndef WITHOUT_WINDOW_ANIMATOR_CACHE\n  window_manager_snap_prev_window(wm, prev_win, &(wa->prev_img));\n  window_manager_snap_curr_window(wm, curr_win, &(wa->curr_img));\n  wa->dialog_highlighter = window_manager_get_dialog_highlighter(wm);\n#endif /*WITHOUT_WINDOW_ANIMATOR_CACHE*/\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  224,
                  "prev_win->parent"
               ],
               [
                  229,
                  "lcd->ratio"
               ]
            ]
         },
         {
            "type": "func",
            "name": "window_animator_draw_prev_window",
            "line_range": [
               290,
               298
            ],
            "source_code": "static ret_t window_animator_draw_prev_window(window_animator_t* wa) {\n  return_value_if_fail(wa != NULL && wa->vt != NULL && wa->vt->draw_prev_window, RET_BAD_PARAMS);\n\n  if (wa->dialog_highlighter != NULL) {\n    return dialog_highlighter_draw(wa->dialog_highlighter, wa->percent);\n  } else {\n    return wa->vt->draw_prev_window(wa);\n  }\n}",
            "key_variables": [
               [
                  308,
                  "wa->canvas"
               ],
               [
                  309,
                  "wa->prev_win"
               ]
            ]
         }
      ],
      "src/window_animators/window_animator_fade.c": [
         {
            "type": "func",
            "name": "window_animator_fade_draw_curr",
            "line_range": [
               23,
               39
            ],
            "source_code": "static ret_t window_animator_fade_draw_curr(window_animator_t* wa) {\n  canvas_t* c = wa->canvas;\n  widget_t* win = wa->curr_win;\n\n  uint8_t global_alpha = wa->percent * 0xff;\n#ifndef WITHOUT_WINDOW_ANIMATOR_CACHE\n  rectf_t dst = rectf_init(win->x, win->y, win->w, win->h);\n  rectf_t src = rectf_init(win->x, win->y, win->w, win->h);\n  lcd_set_global_alpha(c->lcd, global_alpha);\n\n  return lcd_draw_image(c->lcd, &(wa->curr_img), rectf_scale(&src, wa->ratio), &dst);\n#else\n  lcd_set_global_alpha(c->lcd, global_alpha);\n\n  return widget_paint(win, c);\n#endif /*WITHOUT_WINDOW_ANIMATOR_CACHE*/\n}",
            "key_variables": [
               [
                  25,
                  "wa->canvas"
               ],
               [
                  26,
                  "wa->curr_win"
               ]
            ]
         }
      ],
      "src/window_animators/window_animator_htranslate.c": [
         {
            "type": "func",
            "name": "window_animator_htranslate_draw_prev",
            "line_range": [
               34,
               51
            ],
            "source_code": "static ret_t window_animator_htranslate_draw_prev(window_animator_t* wa) {\n  canvas_t* c = wa->canvas;\n  widget_t* win = wa->prev_win;\n  float_t percent = wa->percent;\n  float_t x = tk_roundi(win->w * percent);\n  float_t w = win->w - x;\n\n#ifndef WITHOUT_WINDOW_ANIMATOR_CACHE\n  rectf_t src = rectf_init(x, win->y, w, win->h);\n  rectf_t dst = rectf_init(0.0f, win->y, w, win->h);\n  return lcd_draw_image(c->lcd, &(wa->prev_img), rectf_scale(&src, wa->ratio), &dst);\n#else\n  canvas_translate(c, -x, 0);\n  widget_paint(win, c);\n  canvas_untranslate(c, -x, 0);\n  return RET_OK;\n#endif /*WITHOUT_WINDOW_ANIMATOR_CACHE*/\n}",
            "key_variables": [
               [
                  36,
                  "wa->canvas"
               ],
               [
                  37,
                  "wa->prev_win"
               ],
               [
                  38,
                  "wa->percent"
               ]
            ]
         },
         {
            "type": "func",
            "name": "window_animator_htranslate_draw_curr",
            "line_range": [
               53,
               71
            ],
            "source_code": "static ret_t window_animator_htranslate_draw_curr(window_animator_t* wa) {\n  canvas_t* c = wa->canvas;\n  widget_t* win = wa->curr_win;\n  float_t percent = wa->percent;\n  float_t x = tk_roundi(win->w * (1 - percent));\n  float_t w = win->w - x;\n\n#ifndef WITHOUT_WINDOW_ANIMATOR_CACHE\n  rectf_t src = rectf_init(0.0f, win->y, w, win->h);\n  rectf_t dst = rectf_init(x, win->y, w, win->h);\n  return lcd_draw_image(c->lcd, &(wa->curr_img), rectf_scale(&src, wa->ratio), &dst);\n#else\n  canvas_translate(c, x, 0);\n  widget_paint(win, c);\n  canvas_untranslate(c, x, 0);\n\n  return RET_OK;\n#endif /*WITHOUT_WINDOW_ANIMATOR_CACHE*/\n}",
            "key_variables": [
               [
                  55,
                  "wa->canvas"
               ],
               [
                  56,
                  "wa->curr_win"
               ],
               [
                  57,
                  "wa->percent"
               ]
            ]
         }
      ],
      "src/window_animators/window_animator_slide.c": [
         {
            "type": "func",
            "name": "window_animator_slide_draw_mask",
            "line_range": [
               23,
               34
            ],
            "source_code": "static ret_t window_animator_slide_draw_mask(window_animator_t* wa, uint8_t alpha) {\n  if (alpha > 1) {\n    canvas_t* c = wa->canvas;\n    widget_t* win = wa->prev_win;\n    color_t mask = color_init(0, 0, 0, alpha);\n\n    canvas_set_fill_color(c, mask);\n    canvas_fill_rect(c, win->x, win->y, win->w, win->h);\n  }\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  26,
                  "wa->canvas"
               ],
               [
                  27,
                  "wa->prev_win"
               ]
            ]
         },
         {
            "type": "func",
            "name": "window_animator_slide_init",
            "line_range": [
               45,
               53
            ],
            "source_code": "ret_t window_animator_slide_init(window_animator_t* wa) {\n  window_animator_slide_t* was = (window_animator_slide_t*)wa;\n\n  if (was->start_alpha == was->end_alpha) {\n    widget_on(wa->prev_win, EVT_PAINT_DONE, on_prev_window_paint_done, wa);\n  }\n\n  return RET_OK;\n}",
            "key_variables": [
               [
                  57,
                  "wa->percent"
               ],
               [
                  66,
                  "was->start_alpha"
               ]
            ]
         }
      ],
      "src/window_animators/window_animator_vtranslate.c": [
         {
            "type": "func",
            "name": "window_animator_vtranslate_draw_prev",
            "line_range": [
               34,
               52
            ],
            "source_code": "static ret_t window_animator_vtranslate_draw_prev(window_animator_t* wa) {\n  canvas_t* c = wa->canvas;\n  widget_t* win = wa->prev_win;\n  widget_t* curr_win = wa->curr_win;\n  float_t percent = wa->percent;\n  float_t y = tk_roundi(curr_win->h * percent);\n  float_t h = win->h - y;\n\n#ifndef WITHOUT_WINDOW_ANIMATOR_CACHE\n  rectf_t src = rectf_init(win->x, y + win->y, win->w, h);\n  rectf_t dst = rectf_init(win->x, win->y, win->w, h);\n  return lcd_draw_image(c->lcd, &(wa->prev_img), rectf_scale(&src, wa->ratio), &dst);\n#else\n  canvas_translate(c, 0, -y);\n  widget_paint(win, c);\n  canvas_untranslate(c, 0, -y);\n  return RET_OK;\n#endif /*WITHOUT_WINDOW_ANIMATOR_CACHE*/\n}",
            "key_variables": [
               [
                  36,
                  "wa->canvas"
               ],
               [
                  37,
                  "wa->prev_win"
               ],
               [
                  38,
                  "wa->curr_win"
               ],
               [
                  39,
                  "wa->percent"
               ]
            ]
         },
         {
            "type": "func",
            "name": "window_animator_vtranslate_draw_curr",
            "line_range": [
               54,
               73
            ],
            "source_code": "static ret_t window_animator_vtranslate_draw_curr(window_animator_t* wa) {\n  canvas_t* c = wa->canvas;\n  widget_t* win = wa->curr_win;\n  float_t percent = wa->percent;\n  float_t h = tk_roundi(win->h * percent);\n  float_t y = win->parent->h - h;\n\n#ifndef WITHOUT_WINDOW_ANIMATOR_CACHE\n  rectf_t src = rectf_init(win->x, win->y, win->w, h);\n  rectf_t dst = rectf_init(win->x, y, win->w, h);\n  return lcd_draw_image(c->lcd, &(wa->curr_img), rectf_scale(&src, wa->ratio), &dst);\n#else\n  y = win->h * (1 - percent);\n  canvas_translate(c, 0, y);\n  widget_paint(win, c);\n  canvas_untranslate(c, 0, y);\n\n  return RET_OK;\n#endif /*WITHOUT_WINDOW_ANIMATOR_CACHE*/\n}",
            "key_variables": [
               [
                  56,
                  "wa->canvas"
               ],
               [
                  57,
                  "wa->curr_win"
               ],
               [
                  58,
                  "wa->percent"
               ]
            ]
         }
      ],
      "src/window_manager/window_manager_default.c": [
         {
            "type": "func",
            "name": "window_is_fullscreen",
            "line_range": [
               98,
               110
            ],
            "source_code": "static bool_t window_is_fullscreen(widget_t* widget) {\n\n  value_t v;\n\n  value_set_bool(&v, FALSE);\n\n  widget_get_prop(widget, WIDGET_PROP_FULLSCREEN, &v);\n\n\n\n  return value_bool(&v);\n\n}",
            "key_variables": [
               [
                  98,
                  "children->size"
               ]
            ]
         },
         {
            "type": "func",
            "name": "window_manager_find_prev_window",
            "line_range": [
               182,
               214
            ],
            "source_code": "static widget_t* window_manager_find_prev_window(widget_t* widget) {\n\n  int32_t i = 0;\n\n  int32_t nr = 0;\n\n  return_value_if_fail(widget != NULL, NULL);\n\n\n\n  if (widget->children != NULL && widget->children->size > 0) {\n\n    nr = widget->children->size;\n\n    for (i = nr - 2; i >= 0; i--) {\n\n      widget_t* iter = (widget_t*)(widget->children->elms[i]);\n\n      if (widget_is_normal_window(iter) || widget_is_dialog(iter) || widget_is_popup(iter)) {\n\n        return iter;\n\n      }\n\n    }\n\n  }\n\n\n\n  return NULL;\n\n}",
            "key_variables": [
               [
                  193,
                  "wm->dialog_highlighter"
               ]
            ]
         },
         {
            "type": "func",
            "name": "window_manager_start_or_reset_screen_saver_timer",
            "line_range": [
               148,
               178
            ],
            "source_code": "static ret_t window_manager_start_or_reset_screen_saver_timer(window_manager_default_t* wm) {\n\n  if (wm->screen_saver_time > 0) {\n\n    if (wm->screen_saver_timer_id == TK_INVALID_ID) {\n\n      wm->screen_saver_timer_id = timer_add(wm_on_screen_saver_timer, wm, wm->screen_saver_time);\n\n    } else {\n\n      timer_modify(wm->screen_saver_timer_id, wm->screen_saver_time);\n\n    }\n\n  } else {\n\n    if (wm->screen_saver_timer_id != TK_INVALID_ID) {\n\n      timer_remove(wm->screen_saver_timer_id);\n\n      wm->screen_saver_timer_id = TK_INVALID_ID;\n\n    }\n\n  }\n\n\n\n  return RET_OK;\n\n}",
            "key_variables": [
               [
                  216,
                  "children[start]"
               ]
            ]
         },
         {
            "type": "func",
            "name": "window_manager_find_prev_normal_window",
            "line_range": [
               218,
               242
            ],
            "source_code": "static widget_t* window_manager_find_prev_normal_window(widget_t* widget) {\n\n  return_value_if_fail(widget != NULL, NULL);\n\n\n\n  if (widget->children != NULL && widget->children->size >= 2) {\n\n    WIDGET_FOR_EACH_CHILD_BEGIN_R(widget, iter, i)\n\n    if (i <= widget->children->size - 2 && widget_is_normal_window(iter) && iter->visible) {\n\n      return iter;\n\n    }\n\n    WIDGET_FOR_EACH_CHILD_END();\n\n  }\n\n\n\n  return NULL;\n\n}",
            "key_variables": [
               [
                  266,
                  "wm->dialog_highlighter"
               ],
               [
                  276,
                  "wm->dialog_highlighter"
               ],
               [
                  278,
                  "dialog_highlighter->dialog"
               ]
            ]
         },
         {
            "type": "func",
            "name": "window_manager_default_create_dialog_highlighter",
            "line_range": [
               536,
               608
            ],
            "source_code": "static ret_t window_manager_default_create_dialog_highlighter(widget_t* widget,\n\n                                                              widget_t* curr_win) {\n\n  value_t v;\n\n  ret_t ret = RET_FAIL;\n\n  dialog_highlighter_t* dialog_highlighter = NULL;\n\n  window_manager_default_t* wm = WINDOW_MANAGER_DEFAULT(widget);\n\n\n\n  dialog_highlighter = wm->dialog_highlighter;\n\n  if (dialog_highlighter != NULL && dialog_highlighter->dialog != curr_win) {\n\n    widget_t* dialog = dialog_highlighter->dialog;\n\n    if (dialog != NULL) {\n\n      widget_off_by_func(dialog, EVT_DESTROY, dialog_highlighter_on_dialog_destroy,\n\n                         dialog_highlighter);\n\n    }\n\n    dialog_highlighter_destroy(dialog_highlighter);\n\n    wm->dialog_highlighter = dialog_highlighter = NULL;\n\n  }\n\n\n\n  if (dialog_highlighter == NULL && (widget_is_dialog(curr_win) || widget_is_popup(curr_win)) &&\n\n      widget_get_prop(curr_win, WIDGET_PROP_HIGHLIGHT, &v) == RET_OK) {\n\n    const char* args = value_str(&v);\n\n    if (args != NULL) {\n\n      dialog_highlighter_factory_t* f = dialog_highlighter_factory();\n\n      dialog_highlighter = dialog_highlighter_factory_create_highlighter(f, args, curr_win);\n\n\n\n      if (dialog_highlighter != NULL) {\n\n        wm->dialog_highlighter = dialog_highlighter;\n\n\n\n        emitter_on(EMITTER(dialog_highlighter), EVT_DESTROY, window_manager_on_highlighter_destroy,\n\n                   widget);\n\n        ret = RET_OK;\n\n      }\n\n    }\n\n  }\n\n\n\n  return ret;\n\n}",
            "key_variables": [
               [
                  646,
                  "wm->last_paint_cost"
               ]
            ]
         },
         {
            "type": "func",
            "name": "window_manager_create_highlighter",
            "line_range": [
               636,
               644
            ],
            "source_code": "static ret_t window_manager_create_highlighter(widget_t* widget, widget_t* curr_win) {\n\n  widget_t* prev_win = window_manager_find_prev_normal_window(widget);\n\n  window_manager_prepare_dialog_highlighter(widget, prev_win, curr_win);\n\n  return RET_OK;\n\n}",
            "key_variables": [
               [
                  778,
                  "children[i]"
               ],
               [
                  799,
                  "animator->open"
               ],
               [
                  801,
                  "animator->prev_win"
               ],
               [
                  802,
                  "animator->curr_win"
               ]
            ]
         },
         {
            "type": "func",
            "name": "on_window_switch_done",
            "line_range": [
               808,
               820
            ],
            "source_code": "static ret_t on_window_switch_done(void* ctx, event_t* e) {\n\n  widget_t* to_close = WIDGET(ctx);\n\n  log_debug(\"window %s close\\n\", to_close->name);\n\n  window_manager_close_window_force(to_close->parent, to_close);\n\n\n\n  return RET_REMOVE;\n\n}",
            "key_variables": [
               [
                  836,
                  "wm->curr_win"
               ],
               [
                  843,
                  "wm->pending_close_window"
               ],
               [
                  853,
                  "wm->pending_open_window"
               ]
            ]
         },
         {
            "type": "func",
            "name": "window_manager_check_if_need_close_animation",
            "line_range": [
               898,
               904
            ],
            "source_code": "static ret_t window_manager_check_if_need_close_animation(window_manager_default_t* wm,\n\n                                                          widget_t* curr_win) {\n\n  return window_manager_create_animator(wm, curr_win, FALSE);\n\n}",
            "key_variables": [
               [
                  940,
                  "wm->prev_win"
               ]
            ]
         },
         {
            "type": "func",
            "name": "window_manager_idle_destroy_window",
            "line_range": [
               1008,
               1018
            ],
            "source_code": "static ret_t window_manager_idle_destroy_window(const idle_info_t* info) {\n\n  widget_t* win = WIDGET(info->ctx);\n\n  widget_destroy(win);\n\n\n\n  return RET_OK;\n\n}",
            "key_variables": [
               [
                  1122,
                  "wm->animating"
               ]
            ]
         },
         {
            "type": "func",
            "name": "window_manager_prepare_close_window",
            "line_range": [
               1022,
               1058
            ],
            "source_code": "static ret_t window_manager_prepare_close_window(widget_t* widget, widget_t* window) {\n\n  return_value_if_fail(widget != NULL && window != NULL, RET_BAD_PARAMS);\n\n\n\n  if (widget->target == window) {\n\n    widget->target = NULL;\n\n  }\n\n\n\n  if (widget->key_target == window) {\n\n    widget->key_target = NULL;\n\n  }\n\n\n\n  if (widget->grab_widget != NULL) {\n\n    if (widget->grab_widget == window) {\n\n      widget->grab_widget = NULL;\n\n    }\n\n  }\n\n\n\n  return RET_OK;\n\n}",
            "key_variables": [
               [
                  1155,
                  "lcd->w"
               ],
               [
                  1156,
                  "lcd->h"
               ],
               [
                  1157,
                  "evt->orientation"
               ],
               [
                  1158,
                  "evt->old_orientation"
               ],
               [
                  1161,
                  "lcd->h"
               ],
               [
                  1162,
                  "lcd->w"
               ]
            ]
         },
         {
            "type": "func",
            "name": "window_manager_default_close_window",
            "line_range": [
               1062,
               1134
            ],
            "source_code": "static ret_t window_manager_default_close_window(widget_t* widget, widget_t* window) {\n\n  window_manager_default_t* wm = WINDOW_MANAGER_DEFAULT(widget);\n\n\n\n  return_value_if_fail(wm != NULL, RET_BAD_PARAMS);\n\n  return_value_if_fail(widget_is_window(window), RET_BAD_PARAMS);\n\n  return_value_if_fail(window_is_opened(window), RET_BAD_PARAMS);\n\n  return_value_if_fail(wm->pending_close_window != window, RET_BAD_PARAMS);\n\n\n\n  window_manager_prepare_close_window(widget, window);\n\n\n\n  if (wm->animator) {\n\n    wm->pending_close_window = window;\n\n    return RET_OK;\n\n  }\n\n\n\n  window_manager_dispatch_window_event(window, EVT_WINDOW_CLOSE);\n\n  if (window_manager_check_if_need_close_animation(wm, window) != RET_OK) {\n\n    widget_t* prev_win = NULL;\n\n\n\n    widget_remove_child(widget, window);\n\n    idle_add(window_manager_idle_destroy_window, window);\n\n    /* 这里是解决没有结束动画，但是 prev_win 是高亮的对话框的情况 */\n\n    prev_win = window_manager_get_top_window(widget);\n\n    if (prev_win != NULL) {\n\n      if (!widget_is_keyboard(window)) {\n\n        window_manager_dispatch_window_event(prev_win, EVT_WINDOW_TO_FOREGROUND);\n\n        window_manager_create_highlighter(widget, prev_win);\n\n      }\n\n    }\n\n  }\n\n\n\n  if (widget->children == NULL || widget->children->size == 0) {\n\n    widget_invalidate_force(widget, NULL);\n\n  }\n\n\n\n  return RET_OK;\n\n}",
            "key_variables": [
               [
                  1193,
                  "iter->h"
               ],
               [
                  1194,
                  "iter->h"
               ],
               [
                  1198,
                  "iter->h"
               ],
               [
                  1207,
                  "widget->w"
               ],
               [
                  1210,
                  "window->h"
               ]
            ]
         },
         {
            "type": "func",
            "name": "window_manager_default_find_target",
            "line_range": [
               1180,
               1184
            ],
            "source_code": "static widget_t* window_manager_default_find_target(widget_t* widget, xy_t x, xy_t y) {\n\n  return window_manager_find_target(widget, NULL, x, y);\n\n}",
            "key_variables": [
               [
                  1220,
                  "window->x"
               ],
               [
                  1221,
                  "window->y"
               ],
               [
                  1222,
                  "window->w"
               ],
               [
                  1223,
                  "window->h"
               ],
               [
                  1229,
                  "widget->w"
               ],
               [
                  1230,
                  "widget->h"
               ],
               [
                  1241,
                  "window->x"
               ],
               [
                  1242,
                  "window->y"
               ],
               [
                  1243,
                  "window->w"
               ],
               [
                  1244,
                  "window->h"
               ]
            ]
         }
      ],
      "src/window_manager/window_manager_simple.c": [
         {
            "type": "block",
            "name": "block",
            "line_range": "",
            "source_code": "",
            "key_variables": [
               60,
               "children->size"
            ]
         },
         {
            "type": "func",
            "name": "window_manager_simple_do_open_window",
            "line_range": [
               166,
               174
            ],
            "source_code": "static ret_t window_manager_simple_do_open_window(widget_t* widget, widget_t* window) {\n\n  widget_add_idle(window, (idle_func_t)window_manager_idle_dispatch_window_open);\n\n\n\n  return RET_OK;\n\n}",
            "key_variables": [
               [
                  248,
                  "wm->prev_win"
               ]
            ]
         },
         {
            "type": "func",
            "name": "window_manager_prepare_close_window",
            "line_range": [
               284,
               330
            ],
            "source_code": "static ret_t window_manager_prepare_close_window(widget_t* widget, widget_t* window) {\n\n  window_manager_simple_t* wm = WINDOW_MANAGER_SIMPLE(widget);\n\n  return_value_if_fail(widget != NULL && window != NULL, RET_BAD_PARAMS);\n\n\n\n  if (widget->target == window) {\n\n    widget->target = NULL;\n\n  }\n\n\n\n  if (widget->key_target == window) {\n\n    widget->key_target = NULL;\n\n  }\n\n\n\n  if (widget->grab_widget != NULL) {\n\n    if (widget->grab_widget == window) {\n\n      widget->grab_widget = NULL;\n\n    }\n\n  }\n\n\n\n  if (wm->system_bar == window) {\n\n    wm->system_bar = NULL;\n\n  }\n\n\n\n  return RET_OK;\n\n}",
            "key_variables": [
               [
                  368,
                  "evt->orientation"
               ],
               [
                  372,
                  "wm->lcd_w"
               ],
               [
                  373,
                  "wm->lcd_h"
               ],
               [
                  375,
                  "wm->lcd_h"
               ],
               [
                  376,
                  "wm->lcd_w"
               ],
               [
                  390,
                  "window->x"
               ],
               [
                  391,
                  "window->y"
               ],
               [
                  392,
                  "window->w"
               ],
               [
                  393,
                  "window->h"
               ],
               [
                  398,
                  "wm->system_bar"
               ]
            ]
         },
         {
            "type": "func",
            "name": "window_manager_idle_destroy_window",
            "line_range": [
               270,
               280
            ],
            "source_code": "static ret_t window_manager_idle_destroy_window(const idle_info_t* info) {\n\n  widget_t* win = WIDGET(info->ctx);\n\n  widget_destroy(win);\n\n\n\n  return RET_OK;\n\n}",
            "key_variables": [
               [
                  406,
                  "widget->w"
               ],
               [
                  407,
                  "widget->h"
               ]
            ]
         },
         {
            "type": "func",
            "name": "window_manager_simple_close_window_force",
            "line_range": [
               380,
               404
            ],
            "source_code": "static ret_t window_manager_simple_close_window_force(widget_t* widget, widget_t* window) {\n\n  window_manager_simple_t* wm = WINDOW_MANAGER_SIMPLE(widget);\n\n\n\n  return_value_if_fail(wm != NULL, RET_BAD_PARAMS);\n\n  return_value_if_fail(widget_is_window(window), RET_BAD_PARAMS);\n\n\n\n  window_manager_prepare_close_window(widget, window);\n\n  window_manager_dispatch_window_event(window, EVT_WINDOW_CLOSE);\n\n  widget_remove_child(widget, window);\n\n  widget_destroy(window);\n\n\n\n  return RET_OK;\n\n}",
            "key_variables": [
               [
                  417,
                  "widget->w"
               ],
               [
                  422,
                  "window->x"
               ],
               [
                  423,
                  "window->y"
               ],
               [
                  424,
                  "window->w"
               ],
               [
                  425,
                  "window->h"
               ]
            ]
         },
         {
            "type": "func",
            "name": "window_manager_simple_get_prev_window",
            "line_range": [
               488,
               496
            ],
            "source_code": "static widget_t* window_manager_simple_get_prev_window(widget_t* widget) {\n\n  window_manager_simple_t* wm = WINDOW_MANAGER_SIMPLE(widget);\n\n\n\n  return wm->prev_win;\n\n}",
            "key_variables": [
               [
                  495,
                  "info->lcd_h"
               ],
               [
                  496,
                  "info->lcd_w"
               ]
            ]
         },
         {
            "type": "func",
            "name": "window_manager_simple_invalidate",
            "line_range": [
               468,
               484
            ],
            "source_code": "static ret_t window_manager_simple_invalidate(widget_t* widget, const rect_t* r) {\n\n  window_manager_simple_t* wm = WINDOW_MANAGER_SIMPLE(widget);\n\n\n\n  if (wm->native_window != NULL) {\n\n    native_window_invalidate(wm->native_window, r);\n\n  }\n\n\n\n  return RET_OK;\n\n}",
            "key_variables": [
               [
                  498,
                  "info->lcd_w"
               ],
               [
                  499,
                  "info->lcd_h"
               ]
            ]
         }
      ],
      "src/xml/xml_builder.c": [
         {
            "type": "func",
            "name": "xml_builder_on_error",
            "line_range": [
               67,
               76
            ],
            "source_code": "void xml_builder_on_error(XmlBuilder* builder, int line, int col, const char* message) {\n  return_if_fail(builder != NULL);\n  if (builder->on_error != NULL) {\n    builder->on_error(builder, line, col, message);\n  } else {\n    log_debug(\"%d:%d %s\\n\", line, col, message);\n  }\n\n  return;\n}",
            "key_variables": [
               [
                  92,
                  "attrs[i]"
               ],
               [
                  93,
                  "attrs[i + 1]"
               ]
            ]
         }
      ],
      "src/xml/xml_parser.c": [
         {
            "type": "block",
            "name": "block",
            "line_range": "",
            "source_code": "",
            "key_variables": [
               37,
               "attrs[MAX_ATTR_KEY_VALUE_NR + 1]"
            ]
         },
         {
            "type": "func",
            "name": "xml_parser_set_builder",
            "line_range": [
               74,
               80
            ],
            "source_code": "void xml_parser_set_builder(XmlParser* parser, XmlBuilder* builder) {\n  return_if_fail(parser != NULL);\n\n  parser->builder = builder;\n\n  return;\n}",
            "key_variables": [
               [
                  102,
                  "read_ptr[0]"
               ]
            ]
         },
         {
            "type": "func",
            "name": "xml_parser_reset_buffer",
            "line_range": [
               190,
               196
            ],
            "source_code": "static void xml_parser_reset_buffer(XmlParser* parser) {\n  parser->buffer_used = 0;\n  parser->attrs_nr = 0;\n  parser->attrs[0] = NULL;\n\n  return;\n}",
            "key_variables": [
               [
                  215,
                  "parser->buffer_used"
               ]
            ]
         },
         {
            "type": "func",
            "name": "xml_parser_strdup",
            "line_range": [
               198,
               223
            ],
            "source_code": "static int xml_parser_strdup(XmlParser* parser, const char* start, int length, bool_t trim) {\n  int offset = -1;\n\n  if ((parser->buffer_used + length) >= parser->capacity) {\n    int new_capacity = parser->capacity + (parser->capacity >> 1) + length + 32;\n    char* buffer = (char*)TKMEM_REALLOCT(char, parser->buffer, new_capacity);\n    if (buffer != NULL) {\n      parser->buffer = buffer;\n      parser->capacity = new_capacity;\n    }\n  }\n\n  if ((parser->buffer_used + length) >= parser->capacity) {\n    return offset;\n  }\n\n  offset = parser->buffer_used;\n  strncpy(parser->buffer + offset, start, length);\n  parser->buffer[offset + length] = '\\0';\n  if (trim) {\n    strtrim(parser->buffer + offset);\n  }\n  parser->buffer_used += length + 1;\n\n  return offset;\n}",
            "key_variables": [
               [
                  237,
                  "parser->read_ptr"
               ],
               [
                  242,
                  "parser->read_ptr"
               ],
               [
                  250,
                  "parser->read_ptr"
               ],
               [
                  286,
                  "parser->attrs_nr"
               ]
            ]
         },
         {
            "type": "func",
            "name": "xml_parser_parse_attrs",
            "line_range": [
               225,
               291
            ],
            "source_code": "static void xml_parser_parse_attrs(XmlParser* parser, char end_char) {\n  int i = 0;\n  enum _State {\n    STAT_PRE_KEY,\n    STAT_KEY,\n    STAT_PRE_VALUE,\n    STAT_VALUE,\n    STAT_END,\n  } state = STAT_PRE_KEY;\n\n  char value_end = '\\\"';\n  const char* start = parser->read_ptr;\n\n  parser->attrs_nr = 0;\n  for (; *parser->read_ptr != '\\0' && parser->attrs_nr < MAX_ATTR_KEY_VALUE_NR;\n       parser->read_ptr++) {\n    char c = *parser->read_ptr;\n\n    switch (state) {\n      case STAT_PRE_KEY: {\n        if (c == end_char || c == '>') {\n          state = STAT_END;\n        } else if (!tk_isspace(c)) {\n          state = STAT_KEY;\n          start = parser->read_ptr;\n        }\n      }\n      case STAT_KEY: {\n        if (c == '=') {\n          parser->attrs[parser->attrs_nr++] =\n              tk_pointer_from_int(xml_parser_strdup(parser, start, parser->read_ptr - start, TRUE));\n          state = STAT_PRE_VALUE;\n        }\n\n        break;\n      }\n      case STAT_PRE_VALUE: {\n        if (c == '\\\"' || c == '\\'') {\n          state = STAT_VALUE;\n          value_end = c;\n          start = parser->read_ptr + 1;\n        }\n        break;\n      }\n      case STAT_VALUE: {\n        if (c == value_end) {\n          parser->attrs[parser->attrs_nr++] = tk_pointer_from_int(\n              xml_parser_strdup(parser, start, parser->read_ptr - start, FALSE));\n          state = STAT_PRE_KEY;\n        }\n      }\n      default:\n        break;\n    }\n\n    if (state == STAT_END) {\n      break;\n    }\n  }\n\n  for (i = 0; i < parser->attrs_nr; i++) {\n    parser->attrs[i] = parser->buffer + tk_pointer_to_int(parser->attrs[i]);\n  }\n  parser->attrs[parser->attrs_nr] = NULL;\n\n  return;\n}",
            "key_variables": [
               [
                  305,
                  "parser->read_ptr"
               ],
               [
                  346,
                  "parser->read_ptr"
               ]
            ]
         },
         {
            "type": "func",
            "name": "xml_parser_parse_doctype",
            "line_range": [
               358,
               367
            ],
            "source_code": "static void xml_parser_parse_doctype(XmlParser* parser) {\n  for (; *parser->read_ptr != '\\0'; parser->read_ptr++) {\n    char c = *parser->read_ptr;\n    if (c == '>') {\n      break;\n    }\n  }\n\n  return;\n}",
            "key_variables": [
               [
                  361,
                  "parser->read_ptr"
               ],
               [
                  377,
                  "parser->read_ptr"
               ],
               [
                  379,
                  "parser->read_ptr"
               ]
            ]
         },
         {
            "type": "func",
            "name": "xml_parser_parse_comment",
            "line_range": [
               369,
               407
            ],
            "source_code": "static void xml_parser_parse_comment(XmlParser* parser) {\n  enum _State {\n    STAT_COMMENT,\n    STAT_MINUS1,\n    STAT_MINUS2,\n  } state = STAT_COMMENT;\n\n  const char* start = ++parser->read_ptr;\n  for (; *parser->read_ptr != '\\0'; parser->read_ptr++) {\n    char c = *parser->read_ptr;\n\n    switch (state) {\n      case STAT_COMMENT: {\n        if (c == '-') {\n          state = STAT_MINUS1;\n        }\n        break;\n      }\n      case STAT_MINUS1: {\n        if (c == '-') {\n          state = STAT_MINUS2;\n        } else {\n          state = STAT_COMMENT;\n        }\n        break;\n      }\n      case STAT_MINUS2: {\n        if (c == '>') {\n          xml_builder_on_comment(parser->builder, start, parser->read_ptr - start - 2);\n          return;\n        }\n      }\n      default:\n        break;\n    }\n  }\n\n  return;\n}",
            "key_variables": [
               [
                  414,
                  "parser->read_ptr"
               ],
               [
                  417,
                  "parser->read_ptr"
               ]
            ]
         },
         {
            "type": "func",
            "name": "xml_parser_parse_pi",
            "line_range": [
               409,
               449
            ],
            "source_code": "static void xml_parser_parse_pi(XmlParser* parser) {\n  enum _State { STAT_NAME, STAT_ATTR, STAT_END } state = STAT_NAME;\n\n  char* tag_name = NULL;\n  const char* start = parser->read_ptr;\n\n  for (; *parser->read_ptr != '\\0'; parser->read_ptr++) {\n    char c = *parser->read_ptr;\n\n    switch (state) {\n      case STAT_NAME: {\n        if (tk_isspace(c) || c == '>') {\n          tag_name =\n              tk_pointer_from_int(xml_parser_strdup(parser, start, parser->read_ptr - start, TRUE));\n          state = c != '>' ? STAT_ATTR : STAT_END;\n        }\n\n        break;\n      }\n      case STAT_ATTR: {\n        xml_parser_parse_attrs(parser, '?');\n        state = STAT_END;\n        break;\n      }\n      default:\n        break;\n    }\n\n    if (state == STAT_END) {\n      break;\n    }\n  }\n\n  tag_name = parser->buffer + tk_pointer_to_int(tag_name);\n  xml_builder_on_pi(parser->builder, tag_name, (const char**)parser->attrs);\n\n  for (; *parser->read_ptr != '>' && *parser->read_ptr != '\\0'; parser->read_ptr++)\n    ;\n\n  return;\n}",
            "key_variables": [
               [
                  485,
                  "parser->read_ptr"
               ],
               [
                  496,
                  "parser->end"
               ]
            ]
         }
      ]
   }
}