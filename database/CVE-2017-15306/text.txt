int kvm_vm_ioctl_check_extension(struct kvm *kvm, long ext)\n{\n\rint r;\n\r/* Assume we're using HV mode when the HV module is loaded */\n\rint hv_enabled = kvmppc_hv_ops ? 1 : 0;\n\n\rif (kvm) {\n\r/*\n\r * Hooray - we know which VM type we're running on. Depend on\n\r * that rather than the guess above.\n\r */\n\rhv_enabled = is_kvmppc_hv_enabled(kvm);\n\r}\n\n\rswitch (ext) {\n#ifdef CONFIG_BOOKE\n\rcase KVM_CAP_PPC_BOOKE_SREGS:\n\rcase KVM_CAP_PPC_BOOKE_WATCHDOG:\n\rcase KVM_CAP_PPC_EPR:\n#else\n\rcase KVM_CAP_PPC_SEGSTATE:\n\rcase KVM_CAP_PPC_HIOR:\n\rcase KVM_CAP_PPC_PAPR:\n#endif\n\rcase KVM_CAP_PPC_UNSET_IRQ:\n\rcase KVM_CAP_PPC_IRQ_LEVEL:\n\rcase KVM_CAP_ENABLE_CAP:\n\rcase KVM_CAP_ENABLE_CAP_VM:\n\rcase KVM_CAP_ONE_REG:\n\rcase KVM_CAP_IOEVENTFD:\n\rcase KVM_CAP_DEVICE_CTRL:\n\rcase KVM_CAP_IMMEDIATE_EXIT:\n\rr = 1;\n\rbreak;\n\rcase KVM_CAP_PPC_PAIRED_SINGLES:\n\rcase KVM_CAP_PPC_OSI:\n\rcase KVM_CAP_PPC_GET_PVINFO:\n#if defined(CONFIG_KVM_E500V2) || defined(CONFIG_KVM_E500MC)\n\rcase KVM_CAP_SW_TLB:\n#endif\n\r/* We support this only for PR */\n\rr = !hv_enabled;\n\rbreak;\n#ifdef CONFIG_KVM_MPIC\n\rcase KVM_CAP_IRQ_MPIC:\n\rr = 1;\n\rbreak;\n#endif\n\n#ifdef CONFIG_PPC_BOOK3S_64\n\rcase KVM_CAP_SPAPR_TCE:\n\rcase KVM_CAP_SPAPR_TCE_64:\n\r/* fallthrough */\n\rcase KVM_CAP_SPAPR_TCE_VFIO:\n\rcase KVM_CAP_PPC_RTAS:\n\rcase KVM_CAP_PPC_FIXUP_HCALL:\n\rcase KVM_CAP_PPC_ENABLE_HCALL:\n#ifdef CONFIG_KVM_XICS\n\rcase KVM_CAP_IRQ_XICS:\n#endif\n\rr = 1;\n\rbreak;\n\n\rcase KVM_CAP_PPC_ALLOC_HTAB:\n\rr = hv_enabled;\n\rbreak;\n#endif /* CONFIG_PPC_BOOK3S_64 */\n#ifdef CONFIG_KVM_BOOK3S_HV_POSSIBLE\n\rcase KVM_CAP_PPC_SMT:\n\rr = 0;\n\rif (kvm) {\n\rif (kvm->arch.emul_smt_mode > 1)\n\rr = kvm->arch.emul_smt_mode;\n\relse\n\rr = kvm->arch.smt_mode;\n\r} else if (hv_enabled) {\n\rif (cpu_has_feature(CPU_FTR_ARCH_300))\n\rr = 1;\n\relse\n\rr = threads_per_subcore;\n\r}\n\rbreak;\n\rcase KVM_CAP_PPC_SMT_POSSIBLE:\n\rr = 1;\n\rif (hv_enabled) {\n\rif (!cpu_has_feature(CPU_FTR_ARCH_300))\n\rr = ((threads_per_subcore << 1) - 1);\n\relse\n\r/* P9 can emulate dbells, so allow any mode */\n\rr = 8 | 4 | 2 | 1;\n\r}\n\rbreak;\n\rcase KVM_CAP_PPC_RMA:\n\rr = 0;\n\rbreak;\n\rcase KVM_CAP_PPC_HWRNG:\n\rr = kvmppc_hwrng_present();\n\rbreak;\n\rcase KVM_CAP_PPC_MMU_RADIX:\n\rr = !!(hv_enabled && radix_enabled());\n\rbreak;\n\rcase KVM_CAP_PPC_MMU_HASH_V3:\n\rr = !!(hv_enabled && !radix_enabled() &&\n\r       cpu_has_feature(CPU_FTR_ARCH_300));\n\rbreak;\n#endif\n\rcase KVM_CAP_SYNC_MMU:\n#ifdef CONFIG_KVM_BOOK3S_HV_POSSIBLE\n\rr = hv_enabled;\n#elif defined(KVM_ARCH_WANT_MMU_NOTIFIER)\n\rr = 1;\n#else\n\rr = 0;\n#endif\n\rbreak;\n#ifdef CONFIG_KVM_BOOK3S_HV_POSSIBLE\n\rcase KVM_CAP_PPC_HTAB_FD:\n\rr = hv_enabled;\n\rbreak;\n#endif\n\rcase KVM_CAP_NR_VCPUS:\n\r/*\n\r * Recommending a number of CPUs is somewhat arbitrary; we\n\r * return the number of present CPUs for -HV (since a host\n\r * will have secondary threads "offline"), and for other KVM\n\r * implementations just count online CPUs.\n\r */\n\rif (hv_enabled)\n\rr = num_present_cpus();\n\relse\n\rr = num_online_cpus();\n\rbreak;\n\rcase KVM_CAP_NR_MEMSLOTS:\n\rr = KVM_USER_MEM_SLOTS;\n\rbreak;\n\rcase KVM_CAP_MAX_VCPUS:\n\rr = KVM_MAX_VCPUS;\n\rbreak;\n#ifdef CONFIG_PPC_BOOK3S_64\n\rcase KVM_CAP_PPC_GET_SMMU_INFO:\n\rr = 1;\n\rbreak;\n\rcase KVM_CAP_SPAPR_MULTITCE:\n\rr = 1;\n\rbreak;\n\rcase KVM_CAP_SPAPR_RESIZE_HPT:\n\r/* Disable this on POWER9 until code handles new HPTE format */\n\rr = !!hv_enabled && !cpu_has_feature(CPU_FTR_ARCH_300);\n\rbreak;\n#endif\n#ifdef CONFIG_KVM_BOOK3S_HV_POSSIBLE\n\rcase KVM_CAP_PPC_FWNMI:\n\rr = hv_enabled;\n\rbreak;\n#endif\n\rcase KVM_CAP_PPC_HTM:\n\rr = cpu_has_feature(CPU_FTR_TM_COMP) &&\n\r    is_kvmppc_hv_enabled(kvm);\n\rbreak;\n\rdefault:\n\rr = 0;\n\rbreak;\n\r}\n\rreturn r;\n\n}
