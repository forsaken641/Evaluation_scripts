SYSCALL_DEFINE5(add_key, const char __user *, _type,\n\rconst char __user *, _description,\n\rconst void __user *, _payload,\n\rsize_t, plen,\n\rkey_serial_t, ringid)\n{\n\rkey_ref_t keyring_ref, key_ref;\n\rchar type[32], *description;\n\rvoid *payload;\n\rlong ret;\n\n\rret = -EINVAL;\n\rif (plen > 1024 * 1024 - 1)\n\rgoto error;\n\n\r/* draw all the data into kernel space */\n\rret = key_get_type_from_user(type, _type, sizeof(type));\n\rif (ret < 0)\n\rgoto error;\n\n\rdescription = NULL;\n\rif (_description) {\n\rdescription = strndup_user(_description, KEY_MAX_DESC_SIZE);\n\rif (IS_ERR(description)) {\n\rret = PTR_ERR(description);\n\rgoto error;\n\r}\n\rif (!*description) {\n\rkfree(description);\n\rdescription = NULL;\n\r} else if ((description[0] == '.') &&\n\r   (strncmp(type, "keyring", 7) == 0)) {\n\rret = -EPERM;\n\rgoto error2;\n\r}\n\r}\n\n\r/* pull the payload in if one was supplied */\n\rpayload = NULL;\n\n\rif (_payload) {\n\rret = -ENOMEM;\n\rpayload = kvmalloc(plen, GFP_KERNEL);\n\rif (!payload)\n\rgoto error2;\n\n\rret = -EFAULT;\n\rif (copy_from_user(payload, _payload, plen) != 0)\n\rgoto error3;\n\r}\n\n\r/* find the target keyring (which must be writable) */\n\rkeyring_ref = lookup_user_key(ringid, KEY_LOOKUP_CREATE, KEY_NEED_WRITE);\n\rif (IS_ERR(keyring_ref)) {\n\rret = PTR_ERR(keyring_ref);\n\rgoto error3;\n\r}\n\n\r/* create or update the requested key and add it to the target\n\r * keyring */\n\rkey_ref = key_create_or_update(keyring_ref, type, description,\n\r       payload, plen, KEY_PERM_UNDEF,\n\r       KEY_ALLOC_IN_QUOTA);\n\rif (!IS_ERR(key_ref)) {\n\rret = key_ref_to_ptr(key_ref)->serial;\n\rkey_ref_put(key_ref);\n\r}\n\relse {\n\rret = PTR_ERR(key_ref);\n\r}\n\n\rkey_ref_put(keyring_ref);\n error3:\n\rkvfree(payload);\n error2:\n\rkfree(description);\n error:\n\rreturn ret;\n}
