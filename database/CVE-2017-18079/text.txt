static irqreturn_t i8042_interrupt(int irq, void *dev_id)\n{\n\rstruct i8042_port *port;\n\rstruct serio *serio;\n\runsigned long flags;\n\runsigned char str, data;\n\runsigned int dfl;\n\runsigned int port_no;\n\rbool filtered;\n\rint ret = 1;\n\n\rspin_lock_irqsave(&i8042_lock, flags);\n\n\rstr = i8042_read_status();\n\rif (unlikely(~str & I8042_STR_OBF)) {\n\rspin_unlock_irqrestore(&i8042_lock, flags);\n\rif (irq)\n\rdbg("Interrupt %d, without any data\n", irq);\n\rret = 0;\n\rgoto out;\n\r}\n\n\rdata = i8042_read_data();\n\n\rif (i8042_mux_present && (str & I8042_STR_AUXDATA)) {\n\rstatic unsigned long last_transmit;\n\rstatic unsigned char last_str;\n\n\rdfl = 0;\n\rif (str & I8042_STR_MUXERR) {\n\rdbg("MUX error, status is %02x, data is %02x\n",\n\r    str, data);\n/*\n * When MUXERR condition is signalled the data register can only contain\n * 0xfd, 0xfe or 0xff if implementation follows the spec. Unfortunately\n * it is not always the case. Some KBCs also report 0xfc when there is\n * nothing connected to the port while others sometimes get confused which\n * port the data came from and signal error leaving the data intact. They\n * _do not_ revert to legacy mode (actually I've never seen KBC reverting\n * to legacy mode yet, when we see one we'll add proper handling).\n * Anyway, we process 0xfc, 0xfd, 0xfe and 0xff as timeouts, and for the\n * rest assume that the data came from the same serio last byte\n * was transmitted (if transmission happened not too long ago).\n */\n\n\rswitch (data) {\n\rdefault:\n\rif (time_before(jiffies, last_transmit + HZ/10)) {\n\rstr = last_str;\n\rbreak;\n\r}\n\r/* fall through - report timeout */\n\rcase 0xfc:\n\rcase 0xfd:\n\rcase 0xfe: dfl = SERIO_TIMEOUT; data = 0xfe; break;\n\rcase 0xff: dfl = SERIO_PARITY;  data = 0xfe; break;\n\r}\n\r}\n\n\rport_no = I8042_MUX_PORT_NO + ((str >> 6) & 3);\n\rlast_str = str;\n\rlast_transmit = jiffies;\n\r} else {\n\n\rdfl = ((str & I8042_STR_PARITY) ? SERIO_PARITY : 0) |\n\r      ((str & I8042_STR_TIMEOUT && !i8042_notimeout) ? SERIO_TIMEOUT : 0);\n\n\rport_no = (str & I8042_STR_AUXDATA) ?\n\rI8042_AUX_PORT_NO : I8042_KBD_PORT_NO;\n\r}\n\n\rport = &i8042_ports[port_no];\n\rserio = port->exists ? port->serio : NULL;\n\n\rfilter_dbg(port->driver_bound, data, "<- i8042 (interrupt, %d, %d%s%s)\n",\n\r   port_no, irq,\n\r   dfl & SERIO_PARITY ? ", bad parity" : "",\n\r   dfl & SERIO_TIMEOUT ? ", timeout" : "");\n\n\rfiltered = i8042_filter(data, str, serio);\n\n\rspin_unlock_irqrestore(&i8042_lock, flags);\n\n\rif (likely(port->exists && !filtered))\n\rserio_interrupt(serio, data, dfl);\n\n out:\n\rreturn IRQ_RETVAL(ret);\n}
