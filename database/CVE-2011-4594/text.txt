static int __sys_sendmsg(struct socket *sock, struct msghdr __user *msg,\n\r struct msghdr *msg_sys, unsigned flags,\n\r struct used_address *used_address)\n{\n\rstruct compat_msghdr __user *msg_compat =\n\r    (struct compat_msghdr __user *)msg;\n\rstruct sockaddr_storage address;\n\rstruct iovec iovstack[UIO_FASTIOV], *iov = iovstack;\n\runsigned char ctl[sizeof(struct cmsghdr) + 20]\n\r    __attribute__ ((aligned(sizeof(__kernel_size_t))));\n\r/* 20 is size of ipv6_pktinfo */\n\runsigned char *ctl_buf = ctl;\n\rint err, ctl_len, iov_size, total_len;\n\n\rerr = -EFAULT;\n\rif (MSG_CMSG_COMPAT & flags) {\n\rif (get_compat_msghdr(msg_sys, msg_compat))\n\rreturn -EFAULT;\n\r} else if (copy_from_user(msg_sys, msg, sizeof(struct msghdr)))\n\rreturn -EFAULT;\n\n\r/* do not move before msg_sys is valid */\n\rerr = -EMSGSIZE;\n\rif (msg_sys->msg_iovlen > UIO_MAXIOV)\n\rgoto out;\n\n\r/* Check whether to allocate the iovec area */\n\rerr = -ENOMEM;\n\riov_size = msg_sys->msg_iovlen * sizeof(struct iovec);\n\rif (msg_sys->msg_iovlen > UIO_FASTIOV) {\n\riov = sock_kmalloc(sock->sk, iov_size, GFP_KERNEL);\n\rif (!iov)\n\rgoto out;\n\r}\n\n\r/* This will also move the address data into kernel space */\n\rif (MSG_CMSG_COMPAT & flags) {\n\rerr = verify_compat_iovec(msg_sys, iov,\n\r  (struct sockaddr *)&address,\n\r  VERIFY_READ);\n\r} else\n\rerr = verify_iovec(msg_sys, iov,\n\r   (struct sockaddr *)&address,\n\r   VERIFY_READ);\n\rif (err < 0)\n\rgoto out_freeiov;\n\rtotal_len = err;\n\n\rerr = -ENOBUFS;\n\n\rif (msg_sys->msg_controllen > INT_MAX)\n\rgoto out_freeiov;\n\rctl_len = msg_sys->msg_controllen;\n\rif ((MSG_CMSG_COMPAT & flags) && ctl_len) {\n\rerr =\n\r    cmsghdr_from_user_compat_to_kern(msg_sys, sock->sk, ctl,\n\r     sizeof(ctl));\n\rif (err)\n\rgoto out_freeiov;\n\rctl_buf = msg_sys->msg_control;\n\rctl_len = msg_sys->msg_controllen;\n\r} else if (ctl_len) {\n\rif (ctl_len > sizeof(ctl)) {\n\rctl_buf = sock_kmalloc(sock->sk, ctl_len, GFP_KERNEL);\n\rif (ctl_buf == NULL)\n\rgoto out_freeiov;\n\r}\n\rerr = -EFAULT;\n\r/*\n\r * Careful! Before this, msg_sys->msg_control contains a user pointer.\n\r * Afterwards, it will be a kernel pointer. Thus the compiler-assisted\n\r * checking falls down on this.\n\r */\n\rif (copy_from_user(ctl_buf,\n\r   (void __user __force *)msg_sys->msg_control,\n\r   ctl_len))\n\rgoto out_freectl;\n\rmsg_sys->msg_control = ctl_buf;\n\r}\n\rmsg_sys->msg_flags = flags;\n\n\rif (sock->file->f_flags & O_NONBLOCK)\n\rmsg_sys->msg_flags |= MSG_DONTWAIT;\n\r/*\n\r * If this is sendmmsg() and current destination address is same as\n\r * previously succeeded address, omit asking LSM's decision.\n\r * used_address->name_len is initialized to UINT_MAX so that the first\n\r * destination address never matches.\n\r */\n\rif (used_address && used_address->name_len == msg_sys->msg_namelen &&\n\r    !memcmp(&used_address->name, msg->msg_name,\n\r    used_address->name_len)) {\n\rerr = sock_sendmsg_nosec(sock, msg_sys, total_len);\n\rgoto out_freectl;\n\r}\n\rerr = sock_sendmsg(sock, msg_sys, total_len);\n\r/*\n\r * If this is sendmmsg() and sending to current destination address was\n\r * successful, remember it.\n\r */\n\rif (used_address && err >= 0) {\n\rused_address->name_len = msg_sys->msg_namelen;\n\rmemcpy(&used_address->name, msg->msg_name,\n\r       used_address->name_len);\n\r}\n\nout_freectl:\n\rif (ctl_buf != ctl)\n\rsock_kfree_s(sock->sk, ctl_buf, ctl_len);\nout_freeiov:\n\rif (iov != iovstack)\n\rsock_kfree_s(sock->sk, iov, iov_size);\nout:\n\rreturn err;\n}
