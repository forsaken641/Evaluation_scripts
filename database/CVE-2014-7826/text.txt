static void ftrace_syscall_exit(void *data, struct pt_regs *regs, long ret)\n{\n\rstruct trace_array *tr = data;\n\rstruct ftrace_event_file *ftrace_file;\n\rstruct syscall_trace_exit *entry;\n\rstruct syscall_metadata *sys_data;\n\rstruct ring_buffer_event *event;\n\rstruct ring_buffer *buffer;\n\runsigned long irq_flags;\n\rint pc;\n\rint syscall_nr;\n\n\rsyscall_nr = trace_get_syscall_nr(current, regs);\n\rif (syscall_nr < 0)\n\rreturn;\n\n\r/* Here we're inside tp handler's rcu_read_lock_sched (__DO_TRACE()) */\n\rftrace_file = rcu_dereference_sched(tr->exit_syscall_files[syscall_nr]);\n\rif (!ftrace_file)\n\rreturn;\n\n\rif (ftrace_trigger_soft_disabled(ftrace_file))\n\rreturn;\n\n\rsys_data = syscall_nr_to_meta(syscall_nr);\n\rif (!sys_data)\n\rreturn;\n\n\rlocal_save_flags(irq_flags);\n\rpc = preempt_count();\n\n\rbuffer = tr->trace_buffer.buffer;\n\revent = trace_buffer_lock_reserve(buffer,\n\rsys_data->exit_event->event.type, sizeof(*entry),\n\rirq_flags, pc);\n\rif (!event)\n\rreturn;\n\n\rentry = ring_buffer_event_data(event);\n\rentry->nr = syscall_nr;\n\rentry->ret = syscall_get_return_value(current, regs);\n\n\revent_trigger_unlock_commit(ftrace_file, buffer, event, entry,\n\r    irq_flags, pc);\n}
