diff --git a/src/http.cpp b/src/http.cpp
index ae89eb3450..4b3cb2437e 100644
--- a/src/http.cpp
+++ b/src/http.cpp
@@ -344,16 +344,29 @@ int Exiv2::http(Exiv2::Dictionary& request, Exiv2::Dictionary& response, std::st
             size_t body = 0;  // start of body
             if (bSearching) {
                 // search for the body
+<<<<<<< HEAD
                 for (size_t b = 0; bSearching && b < lengthof(blankLines); b++) {
                     if (strstr(buffer, blankLines[b])) {
                         bSearching = false;
                         body = (int)(strstr(buffer, blankLines[b]) - buffer) + strlen(blankLines[b]);
                         status = atoi(strchr(buffer, ' '));
+=======
+                for ( size_t b = 0 ; bSearching && b < lengthof(blankLines) ; b++ ) {
+                    const char* blankLinePos = strstr(buffer,blankLines[b]);
+                    if ( blankLinePos ) {
+                        bSearching = false ;
+                        body   = blankLinePos - buffer + strlen(blankLines[b]);
+                        const char* firstSpace = strchr(buffer,' ');
+                        if (firstSpace) {
+                            status = atoi(firstSpace);
+                        }
+>>>>>>> ae20c3080... Avoid null pointer exception due to NULL return value from strchr.
                     }
                 }
 
                 // parse response headers
                 char* h = buffer;
+<<<<<<< HEAD
                 char C = ':';
                 char N = '\n';
                 int i = 0;  // initial byte in buffer
@@ -365,6 +378,28 @@ int Exiv2::http(Exiv2::Dictionary& request, Exiv2::Dictionary& response, std::st
                 char* c = strchr(h, C);
                 char* first_newline = strchr(h, N);
                 while (c && first_newline && c < first_newline && h < buffer + body) {
+=======
+                char  C = ':' ;
+                char  N = '\n';
+                int   i = 0   ; // initial byte in buffer
+                while(buffer[i] == N ) i++;
+                h = strchr(h+i,N);
+                if (!h) {
+                    status = 0;
+                    break;
+                }
+                h++;
+                response[""]=std::string(buffer+i).substr(0,h-buffer-2);
+                const char* firstSpace = strchr(buffer,' ');
+                if ( !firstSpace ) {
+                    status = 0;
+                    break;
+                }
+                result = atoi(firstSpace);
+                char* c = strchr(h,C);
+                char* first_newline = strchr(h,N);
+                while ( c && first_newline && c < first_newline && h < buffer+body ) {
+>>>>>>> ae20c3080... Avoid null pointer exception due to NULL return value from strchr.
                     std::string key(h);
                     std::string value(c + 1);
                     key = key.substr(0, c - h);
