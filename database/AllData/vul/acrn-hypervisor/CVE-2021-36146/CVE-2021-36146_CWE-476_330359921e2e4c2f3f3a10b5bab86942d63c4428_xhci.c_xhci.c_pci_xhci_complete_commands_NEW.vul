static int
pci_xhci_complete_commands(struct pci_xhci_vdev *xdev)
{
	struct xhci_trb	evtrb;
	struct xhci_trb	*trb;
	uint64_t	crcr;
	uint32_t	ccs;		/* cycle state (XHCI 4.9.2) */
	uint32_t	type;
	uint32_t	slot;
	uint32_t	cmderr;

	xdev->opregs.crcr |= XHCI_CRCR_LO_CRR;

	trb = xdev->opregs.cr_p;
	ccs = xdev->opregs.crcr & XHCI_CRCR_LO_RCS;
	crcr = xdev->opregs.crcr & ~0xF;
	if (!trb) {
		UPRINTF(LDBG, "Get the invalid guest address!\r\n");
		goto out;
	}

	while (1) {
		xdev->opregs.cr_p = trb;

		type = XHCI_TRB_3_TYPE_GET(trb->dwTrb3);

		if ((trb->dwTrb3 & XHCI_TRB_3_CYCLE_BIT) !=
		    (ccs & XHCI_TRB_3_CYCLE_BIT))
			break;

		UPRINTF(LDBG, "cmd type 0x%x, Trb0 x%016lx dwTrb2 x%08x"
			" dwTrb3 x%08x, TRB_CYCLE %u/ccs %u\r\n",
			type, trb->qwTrb0, trb->dwTrb2, trb->dwTrb3,
			trb->dwTrb3 & XHCI_TRB_3_CYCLE_BIT, ccs);

		cmderr = XHCI_TRB_ERROR_SUCCESS;
		evtrb.dwTrb2 = 0;
		evtrb.dwTrb3 = (ccs & XHCI_TRB_3_CYCLE_BIT) |
		      XHCI_TRB_3_TYPE_SET(XHCI_TRB_EVENT_CMD_COMPLETE);
		slot = 0;

		switch (type) {
		case XHCI_TRB_TYPE_LINK:			/* 0x06 */
			if (trb->dwTrb3 & XHCI_TRB_3_TC_BIT)
				ccs ^= XHCI_CRCR_LO_RCS;
			break;

		case XHCI_TRB_TYPE_ENABLE_SLOT:			/* 0x09 */
			/*
			 *From xHCI spec 4.5.3.2, the only command that
			 *software is allowed to issue for the slot in
			 *disabled state is the Enable Slot Command.
			 * */
			cmderr = pci_xhci_cmd_enable_slot(xdev, &slot);
			break;

		case XHCI_TRB_TYPE_DISABLE_SLOT:		/* 0x0A */
			XHCI_GET_SLOT(xdev, trb, slot, cmderr);
			if (slot)
				cmderr = pci_xhci_cmd_disable_slot(xdev, slot);
			break;

		case XHCI_TRB_TYPE_ADDRESS_DEVICE:		/* 0x0B */
			XHCI_GET_SLOT(xdev, trb, slot, cmderr);
			if (slot)
				cmderr = pci_xhci_cmd_address_device(xdev, slot, trb);
			break;

		case XHCI_TRB_TYPE_CONFIGURE_EP:		/* 0x0C */
			XHCI_GET_SLOT(xdev, trb, slot, cmderr);
			if (slot)
				cmderr = pci_xhci_cmd_config_ep(xdev, slot, trb);
			break;

		case XHCI_TRB_TYPE_EVALUATE_CTX:		/* 0x0D */
			XHCI_GET_SLOT(xdev, trb, slot, cmderr);
			if (slot)
				cmderr = pci_xhci_cmd_eval_ctx(xdev, slot, trb);
			break;

		case XHCI_TRB_TYPE_RESET_EP:			/* 0x0E */
			UPRINTF(LDBG, "Reset Endpoint on slot %d\r\n", slot);
			XHCI_GET_SLOT(xdev, trb, slot, cmderr);
			if (slot)
				cmderr = pci_xhci_cmd_reset_ep(xdev, slot, trb);
			break;

		case XHCI_TRB_TYPE_STOP_EP:			/* 0x0F */
			UPRINTF(LDBG, "Stop Endpoint on slot %d\r\n", slot);
			XHCI_GET_SLOT(xdev, trb, slot, cmderr);
			if (slot)
				cmderr = pci_xhci_cmd_reset_ep(xdev, slot, trb);
			break;

		case XHCI_TRB_TYPE_SET_TR_DEQUEUE:		/* 0x10 */
			XHCI_GET_SLOT(xdev, trb, slot, cmderr);
			if (slot)
				cmderr = pci_xhci_cmd_set_tr(xdev, slot, trb);
			break;

		case XHCI_TRB_TYPE_RESET_DEVICE:		/* 0x11 */
			XHCI_GET_SLOT(xdev, trb, slot, cmderr);
			if (slot)
				cmderr = pci_xhci_cmd_reset_device(xdev, slot);
			break;

		case XHCI_TRB_TYPE_FORCE_EVENT:			/* 0x12 */
			/* TODO: */
			break;

		case XHCI_TRB_TYPE_NEGOTIATE_BW:		/* 0x13 */
			break;

		case XHCI_TRB_TYPE_SET_LATENCY_TOL:		/* 0x14 */
			break;

		case XHCI_TRB_TYPE_GET_PORT_BW:			/* 0x15 */
			break;

		case XHCI_TRB_TYPE_FORCE_HEADER:		/* 0x16 */
			break;

		case XHCI_TRB_TYPE_NOOP_CMD:			/* 0x17 */
			break;

		default:
			UPRINTF(LDBG, "unsupported cmd %x\r\n", type);
			break;
		}

		if (type != XHCI_TRB_TYPE_LINK) {
			/*
			 * insert command completion event and assert intr
			 */
			evtrb.qwTrb0 = crcr;
			evtrb.dwTrb2 |= XHCI_TRB_2_ERROR_SET(cmderr);
			evtrb.dwTrb3 |= XHCI_TRB_3_SLOT_SET(slot);
			UPRINTF(LDBG, "command 0x%x result: 0x%x\r\n",
				type, cmderr);
			if (pci_xhci_insert_event(xdev, &evtrb, 1) != 0) {
				UPRINTF(LFTL, "Failed to inject command completion event!\r\n");
				return -ENAVAIL;
			}
		}

		trb = pci_xhci_trb_next(xdev, trb, &crcr);
		if (!trb) {
			UPRINTF(LDBG, "Get the invalid trb in %s!\r\n", __func__);
			break;
		}
	}

out:
	xdev->opregs.crcr = crcr | (xdev->opregs.crcr & XHCI_CRCR_LO_CA) | ccs;
	xdev->opregs.crcr &= ~XHCI_CRCR_LO_CRR;
	return 0;
}
