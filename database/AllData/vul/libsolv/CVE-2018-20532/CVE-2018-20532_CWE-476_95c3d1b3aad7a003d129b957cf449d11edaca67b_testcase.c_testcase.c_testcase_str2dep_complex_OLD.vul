static Id
testcase_str2dep_complex(Pool *pool, const char **sp, int relop)
{
  const char *s = *sp;
  Id flags, id, id2, namespaceid = 0;
  struct oplist *op;

  while (*s == ' ' || *s == '\t')
    s++;
  if (!strncmp(s, "namespace:", 10))
    {
      /* special namespace hack */
      const char *s2;
      for (s2 = s + 10; *s2 && *s2 != '('; s2++)
	;
      if (*s2 == '(')
	{
	  namespaceid = pool_strn2id(pool, s, s2 - s, 1);
	  s = s2;
	}
    }
  if (*s == '(')
    {
      s++;
      id = testcase_str2dep_complex(pool, &s, 0);
      if (!s || *s != ')')
	{
	  *sp = 0;
	  return 0;
	}
      s++;
    }
  else
    id = testcase_str2dep_simple(pool, &s, relop ? 0 : 1);
  if (namespaceid)
    id = pool_rel2id(pool, namespaceid, id, REL_NAMESPACE, 1);
    
  for (;;)
    {
      while (*s == ' ' || *s == '\t')
	s++;
      if (!*s || *s == ')' || (relop && strncmp(s, "compat >= ", 10) != 0))
	{
	  *sp = s;
	  return id;
	}

      /* we have an op! Find the end */
      flags = -1;
      if (s[0] == '<' && (s[1] >= '0' && s[1] <= '9'))
	{
	  const char *s2;
	  for (s2 = s + 1; *s2 >= '0' && *s2 <= '9'; s2++)
	    ;
	  if (*s2 == '>')
	    {
	      flags = strtoul(s + 1, 0, 10);
	      s = s2 + 1;
	    }
	}
      if (flags == -1)
	{
	  for (op = oplist; op->flags; op++)
	    if (!strncmp(s, op->opname, strlen(op->opname)))
	      break;
	  if (!op->flags)
	    {
	      *sp = 0;
	      return 0;
	    }
	  flags = op->flags;
	  s += strlen(op->opname);
	}
      id2 = testcase_str2dep_complex(pool, &s, flags > 0 && flags < 8);
      if (!s)
	{
	  *sp = 0;
	  return 0;
	}
      id = pool_rel2id(pool, id, id2, flags, 1);
    }
}
