int
read_plaindir_repo(Repo *repo, const char *dir)
{
  Pool *pool = repo->pool;
  Repodata *data;
  int c;
  FILE *fp;
  int wstatus;
  int fds[2];
  pid_t pid;
  char *buf = 0;
  char *buf_end = 0;
  char *bp = 0;
  char *rpm;
  int res = 0;
  Id p;

  /* run find command */
  if (pipe(fds))
    {
      perror("pipe");
      exit(1);
    }
  while ((pid = fork()) == (pid_t)-1)
    {
      if (errno != EAGAIN)
	{
	  perror("fork");
	  exit(1);
	}
      sleep(3);
    }
  if (pid == 0)
    {
      if (chdir(dir))
	{
	  perror(dir);
	  _exit(1);
	}
      close(fds[0]);
      if (fds[1] != 1)
	{
	  if (dup2(fds[1], 1) == -1)
	    {
	      perror("dup2");
	      _exit(1);
	    }
	  close(fds[1]);
	}
      if (recursive)
	execl("/usr/bin/find", ".", "-name", ".", "-o", "-name", ".*", "-prune", "-o", "-name", "*.delta.rpm", "-o", "-name", "*.patch.rpm", "-o", "-name", "*.rpm", "-a", "-type", "f", "-print0", (char *)0);
      else
	execl("/usr/bin/find", ".", "-maxdepth", "1", "-name", ".", "-o", "-name", ".*", "-prune", "-o", "-name", "*.delta.rpm", "-o", "-name", "*.patch.rpm", "-o", "-name", "*.rpm", "-a", "-type", "f", "-print0", (char *)0);
      perror("/usr/bin/find");
      _exit(1);
    }
  close(fds[1]);
  if ((fp = fdopen(fds[0], "r")) == 0)
    {
      perror("fdopen");
      exit(1);
    }
  data = repo_add_repodata(repo, 0);
  bp = buf;
  while ((c = getc(fp)) != EOF)
    {
      if (bp == buf_end)
	{
	  size_t len = bp - buf;
	  buf = solv_realloc(buf, len + 4096);
	  bp = buf + len;
	  buf_end = bp + 4096;
	}
      *bp++ = c;
      if (c)
	continue;
      bp = buf;
      rpm = solv_dupjoin(dir, "/", bp[0] == '.' && bp[1] == '/' ? bp + 2 : bp);
      if ((p = repo_add_rpm(repo, rpm, REPO_REUSE_REPODATA|REPO_NO_INTERNALIZE|REPO_NO_LOCATION|(filtered_filelist ? RPM_ADD_FILTERED_FILELIST : 0))) == 0)
	{
	  fprintf(stderr, "%s: %s\n", rpm, pool_errstr(pool));
#if 0
	  res = 1;
#endif
	}
      else
	repodata_set_location(data, p, 0, 0, bp[0] == '.' && bp[1] == '/' ? bp + 2 : bp);
      solv_free(rpm);
    }
  fclose(fp);
  while (waitpid(pid, &wstatus, 0) == -1)
    {
      if (errno == EINTR)
	continue;
      perror("waitpid");
      exit(1);
    }
  if (wstatus)
    {
      fprintf(stderr, "find: exit status %d\n", (wstatus >> 8) | (wstatus & 255) << 8);
#if 0
      res = 1;
#endif
    }
  repo_internalize(repo);
  return res;
}
