Id
repo_add_rpm(Repo *repo, const char *rpm, int flags)
{
  unsigned int sigdsize, sigcnt, sigpad, l;
  Pool *pool = repo->pool;
  Solvable *s;
  struct rpmdbstate state;
  char *payloadformat;
  FILE *fp;
  unsigned char lead[4096];
  int headerstart, headerend;
  struct stat stb;
  Repodata *data;
  unsigned char pkgid[16];
  unsigned char leadsigid[16];
  unsigned char hdrid[32];
  int pkgidtype, leadsigidtype, hdridtype;
  Id chksumtype = 0;
  Chksum *chksumh = 0;
  Chksum *leadsigchksumh = 0;

  data = repo_add_repodata(repo, flags);

  if ((flags & RPM_ADD_WITH_SHA256SUM) != 0)
    chksumtype = REPOKEY_TYPE_SHA256;
  else if ((flags & RPM_ADD_WITH_SHA1SUM) != 0)
    chksumtype = REPOKEY_TYPE_SHA1;

  /* open rpm */
  if ((fp = fopen(flags & REPO_USE_ROOTDIR ? pool_prepend_rootdir_tmp(pool, rpm) : rpm, "r")) == 0)
    {
      pool_error(pool, -1, "%s: %s", rpm, strerror(errno));
      return 0;
    }
  if (fstat(fileno(fp), &stb))
    {
      pool_error(pool, -1, "fstat: %s", strerror(errno));
      fclose(fp);
      return 0;
    }

  /* setup state */
  memset(&state, 0, sizeof(state));
  state.pool = pool;

  /* process lead */
  if (chksumtype)
    chksumh = solv_chksum_create(chksumtype);
  if ((flags & RPM_ADD_WITH_LEADSIGID) != 0)
    leadsigchksumh = solv_chksum_create(REPOKEY_TYPE_MD5);
  if (fread(lead, 96 + 16, 1, fp) != 1 || getu32(lead) != 0xedabeedb)
    {
      pool_error(pool, -1, "%s: not a rpm", rpm);
      fclose(fp);
      return 0;
    }
  if (chksumh)
    solv_chksum_add(chksumh, lead, 96 + 16);
  if (leadsigchksumh)
    solv_chksum_add(leadsigchksumh, lead, 96 + 16);

  /* process signature header */
  if (lead[78] != 0 || lead[79] != 5)
    {
      pool_error(pool, -1, "%s: not a rpm v5 header", rpm);
      fclose(fp);
      return 0;
    }
  if (getu32(lead + 96) != 0x8eade801)
    {
      pool_error(pool, -1, "%s: bad signature header", rpm);
      fclose(fp);
      return 0;
    }
  sigcnt = getu32(lead + 96 + 8);
  sigdsize = getu32(lead + 96 + 12);
  if (sigcnt >= MAX_SIG_CNT || sigdsize >= MAX_SIG_DSIZE)
    {
      pool_error(pool, -1, "%s: bad signature header", rpm);
      fclose(fp);
      return 0;
    }
  sigpad = sigdsize & 7 ? 8 - (sigdsize & 7) : 0;
  headerstart = 96 + 16 + sigcnt * 16 + sigdsize + sigpad;
  pkgidtype = leadsigidtype = hdridtype = 0;
  if ((flags & (RPM_ADD_WITH_PKGID | RPM_ADD_WITH_HDRID)) != 0)
    {
      if (!headfromfp(&state, rpm, fp, lead + 96, sigcnt, sigdsize, sigpad, chksumh, leadsigchksumh))
	{
	  fclose(fp);
	  return 0;
	}
      if ((flags & RPM_ADD_WITH_PKGID) != 0)
	{
	  unsigned char *chksum;
	  unsigned int chksumsize;
	  chksum = headbinary(state.rpmhead, SIGTAG_MD5, &chksumsize);
	  if (chksum && chksumsize == 16)
	    {
	      pkgidtype = REPOKEY_TYPE_MD5;
	      memcpy(pkgid, chksum, 16);
	    }
	}
      if ((flags & RPM_ADD_WITH_HDRID) != 0)
	{
	  const char *str = headstring(state.rpmhead, TAG_SHA1HEADER);
	  if (str && strlen(str) == 40)
	    {
	      if (solv_hex2bin(&str, hdrid, 20) == 20)
	        hdridtype = REPOKEY_TYPE_SHA1;
	    }
	  else if (str && strlen(str) == 64)
	    {
	      if (solv_hex2bin(&str, hdrid, 32) == 32)
	        hdridtype = REPOKEY_TYPE_SHA256;
	    }
	}
    }
  else
    {
      /* just skip the signature header */
      unsigned int len = sigcnt * 16 + sigdsize + sigpad;
      while (len)
	{
	  l = len > 4096 ? 4096 : len;
	  if (fread(lead, l, 1, fp) != 1)
	    {
	      pool_error(pool, -1, "%s: unexpected EOF", rpm);
	      fclose(fp);
	      return 0;
	    }
	  if (chksumh)
	    solv_chksum_add(chksumh, lead, l);
	  if (leadsigchksumh)
	    solv_chksum_add(leadsigchksumh, lead, l);
	  len -= l;
	}
    }
  if (leadsigchksumh)
    {
      leadsigchksumh = solv_chksum_free(leadsigchksumh, leadsigid);
      leadsigidtype = REPOKEY_TYPE_MD5;
    }

  /* process main header */
  if (fread(lead, 16, 1, fp) != 1)
    {
      pool_error(pool, -1, "%s: unexpected EOF", rpm);
      fclose(fp);
      return 0;
    }
  if (chksumh)
    solv_chksum_add(chksumh, lead, 16);
  if (getu32(lead) != 0x8eade801)
    {
      pool_error(pool, -1, "%s: bad header", rpm);
      fclose(fp);
      return 0;
    }
  sigcnt = getu32(lead + 8);
  sigdsize = getu32(lead + 12);
  if (sigcnt >= MAX_HDR_CNT || sigdsize >= MAX_HDR_DSIZE)
    {
      pool_error(pool, -1, "%s: bad header", rpm);
      fclose(fp);
      return 0;
    }
  headerend = headerstart + 16 + sigdsize + sigcnt * 16;

  if (!headfromfp(&state, rpm, fp, lead, sigcnt, sigdsize, 0, chksumh, 0))
    {
      fclose(fp);
      return 0;
    }
  if (headexists(state.rpmhead, TAG_PATCHESNAME))
    {
      /* this is a patch rpm, ignore */
      pool_error(pool, -1, "%s: is patch rpm", rpm);
      fclose(fp);
      solv_chksum_free(chksumh, 0);
      headfree(state.rpmhead);
      return 0;
    }
  payloadformat = headstring(state.rpmhead, TAG_PAYLOADFORMAT);
  if (payloadformat && !strcmp(payloadformat, "drpm"))
    {
      /* this is a delta rpm */
      pool_error(pool, -1, "%s: is delta rpm", rpm);
      fclose(fp);
      solv_chksum_free(chksumh, 0);
      headfree(state.rpmhead);
      return 0;
    }
  if (chksumh)
    while ((l = fread(lead, 1, sizeof(lead), fp)) > 0)
      solv_chksum_add(chksumh, lead, l);
  fclose(fp);
  s = pool_id2solvable(pool, repo_add_solvable(repo));
  if (!rpmhead2solv(pool, repo, data, s, state.rpmhead, flags & ~(RPM_ADD_WITH_HDRID | RPM_ADD_WITH_PKGID)))
    {
      s = solvable_free(s, 1);
      solv_chksum_free(chksumh, 0);
      headfree(state.rpmhead);
      return 0;
    }
  if (!(flags & REPO_NO_LOCATION))
    repodata_set_location(data, s - pool->solvables, 0, 0, rpm);
  if (S_ISREG(stb.st_mode))
    repodata_set_num(data, s - pool->solvables, SOLVABLE_DOWNLOADSIZE, (unsigned long long)stb.st_size);
  repodata_set_num(data, s - pool->solvables, SOLVABLE_HEADEREND, headerend);
  if (pkgidtype)
    repodata_set_bin_checksum(data, s - pool->solvables, SOLVABLE_PKGID, pkgidtype, pkgid);
  if (hdridtype)
    repodata_set_bin_checksum(data, s - pool->solvables, SOLVABLE_HDRID, hdridtype, hdrid);
  if (leadsigidtype)
    repodata_set_bin_checksum(data, s - pool->solvables, SOLVABLE_LEADSIGID, leadsigidtype, leadsigid);
  if (chksumh)
    {
      repodata_set_bin_checksum(data, s - pool->solvables, SOLVABLE_CHECKSUM, chksumtype, solv_chksum_get(chksumh, 0));
      chksumh = solv_chksum_free(chksumh, 0);
    }
  headfree(state.rpmhead);
  if (!(flags & REPO_NO_INTERNALIZE))
    repodata_internalize(data);
  return s - pool->solvables;
}
