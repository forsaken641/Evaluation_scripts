void
transaction_order(Transaction *trans, int flags)
{
  Pool *pool = trans->pool;
  Queue *tr = &trans->steps;
  Repo *installed = pool->installed;
  Id p;
  Solvable *s;
  int i, j, k, numte, numedge;
  struct orderdata od;
  struct s_TransactionElement *te;
  Queue todo, obsq, samerepoq, uninstq;
  int cycstart, cycel;
  Id *cycle;
  int oldcount;
  int start, now;
  Repo *lastrepo;
  int lastmedia;
  Id *temedianr;

  start = now = solv_timems(0);
  POOL_DEBUG(SOLV_DEBUG_STATS, "ordering transaction\n");
  /* free old data if present */
  if (trans->orderdata)
    {
      struct s_TransactionOrderdata *od = trans->orderdata;
      od->tes = solv_free(od->tes);
      od->invedgedata = solv_free(od->invedgedata);
      trans->orderdata = solv_free(trans->orderdata);
    }

  /* create a transaction element for every active component */
  numte = 0;
  for (i = 0; i < tr->count; i++)
    {
      p = tr->elements[i];
      s = pool->solvables + p;
      if (installed && s->repo == installed && trans->transaction_installed[p - installed->start])
	continue;
      numte++;
    }
  POOL_DEBUG(SOLV_DEBUG_STATS, "transaction elements: %d\n", numte);
  if (!numte)
    return;	/* nothing to do... */

  numte++;	/* leave first one zero */
  memset(&od, 0, sizeof(od));
  od.trans = trans;
  od.ntes = numte;
  od.tes = solv_calloc(numte, sizeof(*od.tes));
  od.edgedata = solv_extend(0, 0, 1, sizeof(Id), EDGEDATA_BLOCK);
  od.edgedata[0] = 0;
  od.nedgedata = 1;
  queue_init(&od.cycles);

  /* initialize TEs */
  for (i = 0, te = od.tes + 1; i < tr->count; i++)
    {
      p = tr->elements[i];
      s = pool->solvables + p;
      if (installed && s->repo == installed && trans->transaction_installed[p - installed->start])
	continue;
      te->p = p;
      te++;
    }

  /* create dependency graph */
  for (i = 0; i < tr->count; i++)
    addsolvableedges(&od, pool->solvables + tr->elements[i]);

  /* count edges */
  numedge = 0;
  for (i = 1, te = od.tes + i; i < numte; i++, te++)
    for (j = te->edges; od.edgedata[j]; j += 2)
      numedge++;
  POOL_DEBUG(SOLV_DEBUG_STATS, "edges: %d, edge space: %d\n", numedge, od.nedgedata / 2);
  POOL_DEBUG(SOLV_DEBUG_STATS, "edge creation took %d ms\n", solv_timems(now));

#if 0
  dump_tes(&od);
#endif

  now = solv_timems(0);
  /* kill all cycles */
  queue_init(&todo);
  for (i = numte - 1; i > 0; i--)
    queue_push(&todo, i);

  while (todo.count)
    {
      i = queue_pop(&todo);
      /* printf("- look at TE %d\n", i); */
      if (i < 0)
	{
	  i = -i;
	  od.tes[i].mark = 2;	/* done with that one */
	  continue;
	}
      te = od.tes + i;
      if (te->mark == 2)
	continue;		/* already finished before */
      if (te->mark == 0)
	{
	  int edgestovisit = 0;
	  /* new node, visit edges */
	  for (j = te->edges; (k = od.edgedata[j]) != 0; j += 2)
	    {
	      if ((od.edgedata[j + 1] & TYPE_BROKEN) != 0)
		continue;
	      if (od.tes[k].mark == 2)
		continue;	/* no need to visit again */
	      if (!edgestovisit++)
	        queue_push(&todo, -i);	/* end of edges marker */
	      queue_push(&todo, k);
	    }
	  if (!edgestovisit)
	    te->mark = 2;	/* no edges, done with that one */
	  else
	    te->mark = 1;	/* under investigation */
	  continue;
	}
      /* oh no, we found a cycle */
      /* find start of cycle node (<0) */
      for (j = todo.count - 1; j >= 0; j--)
	if (todo.elements[j] == -i)
	  break;
      assert(j >= 0);
      cycstart = j;
      /* build te/edge chain */
      k = cycstart;
      for (j = k; j < todo.count; j++)
	if (todo.elements[j] < 0)
	  todo.elements[k++] = -todo.elements[j];
      cycel = k - cycstart;
      assert(cycel > 1);
      /* make room for edges, two extra element for cycle loop + terminating 0 */
      while (todo.count < cycstart + 2 * cycel + 2)
	queue_push(&todo, 0);
      cycle = todo.elements + cycstart;
      cycle[cycel] = i;		/* close the loop */
      cycle[2 * cycel + 1] = 0;	/* terminator */
      for (k = cycel; k > 0; k--)
	{
	  cycle[k * 2] = cycle[k];
	  te = od.tes + cycle[k - 1];
	  assert(te->mark == 1);
	  te->mark = 0;	/* reset investigation marker */
	  /* printf("searching for edge from %d to %d\n", cycle[k - 1], cycle[k]); */
	  for (j = te->edges; od.edgedata[j]; j += 2)
	    if (od.edgedata[j] == cycle[k])
	      break;
	  assert(od.edgedata[j]);
	  cycle[k * 2 - 1] = j;
	}
      /* now cycle looks like this: */
      /* te1 edge te2 edge te3 ... teN edge te1 0 */
      breakcycle(&od, cycle);
      /* restart with start of cycle */
      todo.count = cycstart + 1;
    }
  POOL_DEBUG(SOLV_DEBUG_STATS, "cycles broken: %d\n", od.ncycles);
  POOL_DEBUG(SOLV_DEBUG_STATS, "cycle breaking took %d ms\n", solv_timems(now));

  now = solv_timems(0);
  /* now go through all broken cycles and create cycle edges to help
     the ordering */
   for (i = od.cycles.count - 4; i >= 0; i -= 4)
     {
       if (od.cycles.elements[i + 2] >= TYPE_REQ)
         addcycleedges(&od, od.cyclesdata.elements + od.cycles.elements[i], &todo);
     }
   for (i = od.cycles.count - 4; i >= 0; i -= 4)
     {
       if (od.cycles.elements[i + 2] < TYPE_REQ)
         addcycleedges(&od, od.cyclesdata.elements + od.cycles.elements[i], &todo);
     }
  POOL_DEBUG(SOLV_DEBUG_STATS, "cycle edge creation took %d ms\n", solv_timems(now));

#if 0
  dump_tes(&od);
#endif
  /* all edges are finally set up and there are no cycles, now the easy part.
   * Create an ordered transaction */
  now = solv_timems(0);
  /* first invert all edges */
  for (i = 1, te = od.tes + i; i < numte; i++, te++)
    te->mark = 1;	/* term 0 */
  for (i = 1, te = od.tes + i; i < numte; i++, te++)
    {
      for (j = te->edges; od.edgedata[j]; j += 2)
        {
	  if ((od.edgedata[j + 1] & TYPE_BROKEN) != 0)
	    continue;
	  od.tes[od.edgedata[j]].mark++;
	}
    }
  j = 1;
  for (i = 1, te = od.tes + i; i < numte; i++, te++)
    {
      te->mark += j;
      j = te->mark;
    }
  POOL_DEBUG(SOLV_DEBUG_STATS, "invedge space: %d\n", j + 1);
  od.invedgedata = solv_calloc(j + 1, sizeof(Id));
  for (i = 1, te = od.tes + i; i < numte; i++, te++)
    {
      for (j = te->edges; od.edgedata[j]; j += 2)
        {
	  if ((od.edgedata[j + 1] & TYPE_BROKEN) != 0)
	    continue;
	  od.invedgedata[--od.tes[od.edgedata[j]].mark] = i;
	}
    }
  for (i = 1, te = od.tes + i; i < numte; i++, te++)
    te->edges = te->mark;	/* edges now points into invedgedata */
  od.edgedata = solv_free(od.edgedata);
  od.nedgedata = j + 1;

  /* now the final ordering */
  for (i = 1, te = od.tes + i; i < numte; i++, te++)
    te->mark = 0;
  for (i = 1, te = od.tes + i; i < numte; i++, te++)
    for (j = te->edges; od.invedgedata[j]; j++)
      od.tes[od.invedgedata[j]].mark++;

  queue_init(&samerepoq);
  queue_init(&uninstq);
  queue_empty(&todo);
  for (i = 1, te = od.tes + i; i < numte; i++, te++)
    if (te->mark == 0)
      {
	if (installed && pool->solvables[te->p].repo == installed)
          queue_push(&uninstq, i);
	else
          queue_push(&todo, i);
      }
  assert(todo.count > 0 || uninstq.count > 0);
  oldcount = tr->count;
  queue_empty(tr);

  queue_init(&obsq);

  lastrepo = 0;
  lastmedia = 0;
  temedianr = solv_calloc(numte, sizeof(Id));
  for (i = 1; i < numte; i++)
    {
      Solvable *s = pool->solvables + od.tes[i].p;
      if (installed && s->repo == installed)
	j = 1;
      else
        j = solvable_lookup_num(s, SOLVABLE_MEDIANR, 1);
      temedianr[i] = j;
    }
  for (;;)
    {
      /* select an TE i */
      if (uninstq.count)
	i = queue_shift(&uninstq);
      else if (samerepoq.count)
	i = queue_shift(&samerepoq);
      else if (todo.count)
	{
	  /* find next repo/media */
	  for (j = 0; j < todo.count; j++)
	    {
	      if (!j || temedianr[todo.elements[j]] < lastmedia)
		{
		  i = j;
		  lastmedia = temedianr[todo.elements[j]];
		}
	    }
	  lastrepo = pool->solvables[od.tes[todo.elements[i]].p].repo;

	  /* move all matching TEs to samerepoq */
	  for (i = j = 0; j < todo.count; j++)
	    {
	      int k = todo.elements[j];
	      if (temedianr[k] == lastmedia && pool->solvables[od.tes[k].p].repo == lastrepo)
		queue_push(&samerepoq, k);
	      else
		todo.elements[i++] = k;
	    }
	  todo.count = i;

	  assert(samerepoq.count);
	  i = queue_shift(&samerepoq);
	}
      else
	break;

      te = od.tes + i;
      queue_push(tr, te->p);
#if 0
printf("do %s [%d]\n", pool_solvid2str(pool, te->p), temedianr[i]);
#endif
      s = pool->solvables + te->p;
      for (j = te->edges; od.invedgedata[j]; j++)
	{
	  struct s_TransactionElement *te2 = od.tes + od.invedgedata[j];
	  assert(te2->mark > 0);
	  if (--te2->mark == 0)
	    {
	      Solvable *s = pool->solvables + te2->p;
#if 0
printf("free %s [%d]\n", pool_solvid2str(pool, te2->p), temedianr[od.invedgedata[j]]);
#endif
	      if (installed && s->repo == installed)
	        queue_push(&uninstq, od.invedgedata[j]);
	      else if (s->repo == lastrepo && temedianr[od.invedgedata[j]] == lastmedia)
	        queue_push(&samerepoq, od.invedgedata[j]);
	      else
	        queue_push(&todo, od.invedgedata[j]);
	    }
	}
    }
  solv_free(temedianr);
  queue_free(&todo);
  queue_free(&samerepoq);
  queue_free(&uninstq);
  queue_free(&obsq);
  for (i = 1, te = od.tes + i; i < numte; i++, te++)
    assert(te->mark == 0);

  /* add back obsoleted packages */
  transaction_add_obsoleted(trans);
  assert(tr->count == oldcount);

  POOL_DEBUG(SOLV_DEBUG_STATS, "creating new transaction took %d ms\n", solv_timems(now));
  POOL_DEBUG(SOLV_DEBUG_STATS, "transaction ordering took %d ms\n", solv_timems(start));

  if ((flags & (SOLVER_TRANSACTION_KEEP_ORDERDATA | SOLVER_TRANSACTION_KEEP_ORDERCYCLES)) != 0)
    {
      struct s_TransactionOrderdata *tod;
      trans->orderdata = tod = solv_calloc(1, sizeof(*trans->orderdata));
      if ((flags & SOLVER_TRANSACTION_KEEP_ORDERCYCLES) != 0)
	{
	  Queue *cycles = tod->cycles = solv_calloc(1, sizeof(Queue));
	  queue_init_clone(cycles, &od.cyclesdata);
	  /* map from tes to packages */
	  for (i = 0; i < cycles->count; i++)
	    if (cycles->elements[i])
	      cycles->elements[i] = od.tes[cycles->elements[i]].p;
	  queue_insertn(cycles, cycles->count, od.cycles.count, od.cycles.elements);
	  queue_push(cycles, od.cycles.count / 4);
	}
      if ((flags & SOLVER_TRANSACTION_KEEP_ORDERDATA) != 0)
	{
	  tod->tes = od.tes;
	  tod->ntes = numte;
	  tod->invedgedata = od.invedgedata;
	  tod->ninvedgedata = od.nedgedata;
	  od.tes = 0;
	  od.invedgedata = 0;
	}
    }
  solv_free(od.tes);
  solv_free(od.invedgedata);
  queue_free(&od.cycles);
  queue_free(&od.cyclesdata);
}
