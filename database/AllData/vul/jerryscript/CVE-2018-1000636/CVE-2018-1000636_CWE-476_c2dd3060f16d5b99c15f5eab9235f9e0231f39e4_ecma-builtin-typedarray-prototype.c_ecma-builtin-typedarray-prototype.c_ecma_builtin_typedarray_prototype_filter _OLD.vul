static ecma_value_t
ecma_builtin_typedarray_prototype_filter (ecma_value_t this_arg, /**< this argument */
                                          ecma_value_t cb_func_val, /**< callback function */
                                          ecma_value_t cb_this_arg) /**< 'this' of the callback function */
{
  if (!ecma_is_typedarray (this_arg))
  {
    return ecma_raise_type_error (ECMA_ERR_MSG ("Argument 'this' is not a TypedArray."));
  }

  if (!ecma_op_is_callable (cb_func_val))
  {
    return ecma_raise_type_error (ECMA_ERR_MSG ("Callback function is not callable."));
  }

  ecma_object_t *obj_p = ecma_get_object_from_value (this_arg);
  uint32_t len = ecma_typedarray_get_length (obj_p);
  lit_utf8_byte_t *buffer_p = ecma_typedarray_get_buffer (obj_p);
  uint8_t shift = ecma_typedarray_get_element_size_shift (obj_p);
  uint8_t element_size = (uint8_t) (1 << shift);
  ecma_object_t *func_object_p = ecma_get_object_from_value (cb_func_val);
  ecma_value_t ret_value = ECMA_VALUE_EMPTY;

  JMEM_DEFINE_LOCAL_ARRAY (pass_value_list_p, len * element_size, lit_utf8_byte_t);

  lit_utf8_byte_t *pass_value_p = pass_value_list_p;

  for (uint32_t index = 0; index < len && ecma_is_value_empty (ret_value); index++)
  {
    ecma_value_t current_index = ecma_make_uint32_value (index);
    ecma_value_t get_value = ecma_op_typedarray_get_index_prop (obj_p, index);

    JERRY_ASSERT (ecma_is_value_number (get_value));

    ecma_value_t call_args[] = { get_value, current_index, this_arg };

    ECMA_TRY_CATCH (call_value, ecma_op_function_call (func_object_p, cb_this_arg, call_args, 3), ret_value);

    if (ecma_op_to_boolean (call_value))
    {
      memcpy (pass_value_p, buffer_p, element_size);
      pass_value_p += element_size;
    }

    buffer_p += element_size;

    ECMA_FINALIZE (call_value);

    ecma_fast_free_value (current_index);
    ecma_fast_free_value (get_value);
  }

  if (ecma_is_value_empty (ret_value))
  {
    uint32_t pass_num = (uint32_t) ((pass_value_p - pass_value_list_p) >> shift);

    ret_value = ecma_op_create_typedarray_with_type_and_length (obj_p, pass_num);


    if (!ECMA_IS_VALUE_ERROR (ret_value))
    {
      obj_p = ecma_get_object_from_value (ret_value);

      JERRY_ASSERT (ecma_typedarray_get_offset (obj_p) == 0);

      memcpy (ecma_typedarray_get_buffer (obj_p),
              pass_value_list_p,
              (size_t) (pass_value_p - pass_value_list_p));
    }
  }

  JMEM_FINALIZE_LOCAL_ARRAY (pass_value_list_p);

  return ret_value;
} /* ecma_builtin_typedarray_prototype_filter */
